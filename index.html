<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>真・結界師VR - Physics Edition</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">

<!-- Three.js & Cannon-es (ESM) -->
<script type="module">
  import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
  import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/VRButton.js';
  import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/XRControllerModelFactory.js';
  import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

  // --- 初期設定 (Three.js) ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x020205);
  scene.fog = new THREE.FogExp2(0x020205, 0.02);

  const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.01, 100);
  const playerGroup = new THREE.Group();
  playerGroup.position.set(0, 0, 2);
  playerGroup.add(camera);
  scene.add(playerGroup);

  const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(innerWidth, innerHeight);
  renderer.xr.enabled = true;
  renderer.toneMapping = THREE.ReinhardToneMapping;
  renderer.toneMappingExposure = 1.5;
  document.body.appendChild(renderer.domElement);
  document.body.appendChild(VRButton.createButton(renderer));

  // --- HUD & Tips ---
  const hud = document.createElement('div');
  hud.id = 'hud';
  hud.innerHTML = `
    <div style="border-bottom:1px solid #4af; padding-bottom:5px; margin-bottom:10px;">
      <strong>烏森守備隊 HUD (Physics)</strong>
    </div>
    <div><span class="label">展開数:</span> <span id="kCount" class="val">0</span> / <span id="kLimit" class="val">5</span></div>
    <div><span class="label">状態:</span> <span id="statusText" style="color:#f0a;">索敵中...</span></div>
  `;
  document.body.appendChild(hud);

  const tips = document.createElement('div');
  tips.id = 'tips';
  tips.textContent = "トリガー:生成 | スティック前:移動(足場へ) | A長押し:滅 | B:解";
  document.body.appendChild(tips);

  // --- スタイル ---
  const style = document.createElement('style');
  style.textContent = `
    html,body{height:100%;margin:0;background:#000;color:#fff;font-family:"Sawarabi Mincho", serif; overflow:hidden;}
    canvas{display:block}
    #hud {
      position: fixed; left: 20px; top: 20px;
      background: rgba(0,20,40,0.7); border: 1px solid #4af;
      padding:15px; border-radius:4px; font-size:16px; width:280px; pointer-events:none; z-index:10;
      box-shadow: 0 0 15px rgba(0,100,255,0.3);
      text-shadow: 0 0 5px #0ff;
    }
    .label { color: #8cf; font-size:12px; }
    .val { font-weight:bold; font-size:18px; color:#fff; }
    #tips {
      position: fixed; left:20px; bottom:20px;
      color: #4af; font-size:14px; background: rgba(0,0,0,0.6); padding:8px; border-radius:4px; pointer-events:none;
    }
    @import url('https://fonts.googleapis.com/css2?family=Sawarabi+Mincho&display=swap');
  `;
  document.head.appendChild(style);

  // --- 物理エンジン設定 (Cannon-es) ---
  const world = new CANNON.World();
  world.gravity.set(0, -9.82, 0);
  const defaultMaterial = new CANNON.Material('default');
  const defaultContactMaterial = new CANNON.ContactMaterial(defaultMaterial, defaultMaterial, {
    friction: 0.1, restitution: 0.7
  });
  world.addContactMaterial(defaultContactMaterial);

  // --- ステージ & 床 ---
  const floorGeo = new THREE.PlaneGeometry(40,40);
  const floorMat = new THREE.MeshStandardMaterial({color:0x050510, roughness:0.8, emissive:0x000011});
  const floorMesh = new THREE.Mesh(floorGeo, floorMat);
  floorMesh.rotation.x = -Math.PI/2;
  scene.add(floorMesh);
  const floorBody = new CANNON.Body({ type: CANNON.Body.STATIC, shape: new CANNON.Plane(), material: defaultMaterial });
  floorBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
  world.addBody(floorBody);

  const grid = new THREE.GridHelper(40, 40, 0x334455, 0x112233);
  scene.add(grid);
  const hemi = new THREE.HemisphereLight(0x4444ff, 0x000000, 0.4); scene.add(hemi);
  const dir = new THREE.DirectionalLight(0xaaccff, 1.0); dir.position.set(5,10,5); scene.add(dir);

  // --- 音声合成 ---
  const synth = window.speechSynthesis;
  function speak(text) {
    if(!synth) return;
    try {
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'ja-JP'; u.rate = 1.3; u.volume = 0.8;
      synth.speak(u);
    } catch(e){}
  }

  // --- 漢字エフェクト ---
  function spawnKanji(text, pos, color="#4af", scale=1.0) {
    const cvs = document.createElement('canvas');
    cvs.width = 256; cvs.height = 256;
    const ctx = cvs.getContext('2d');
    ctx.font = "bold 180px 'Sawarabi Mincho', serif";
    ctx.fillStyle = color; ctx.textAlign="center"; ctx.textBaseline="middle";
    ctx.shadowColor=color; ctx.shadowBlur=20;
    ctx.fillText(text, 128, 128);

    const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(cvs), transparent:true, depthTest:false}));
    sprite.position.copy(pos); sprite.scale.set(0,0,0);
    scene.add(sprite);

    let t=0;
    function anim(){
      t+=0.05;
      const s = Math.min(1, t*2)*scale;
      sprite.scale.set(s,s,s);
      sprite.material.opacity = Math.max(0, 1-(t-0.5)*1.5);
      sprite.position.y+=0.01;
      if(t<1.5) requestAnimationFrame(anim);
      else { scene.remove(sprite); sprite.material.map.dispose(); sprite.material.dispose(); }
    }
    anim();
  }

  // --- 結界管理 ---
  let kekkaiList = [];
  const KEKKAI_LIMIT = 5;
  const KEKKAI_DURATION = 15000;

  const boxMat = new THREE.MeshPhongMaterial({color:0x0088ff, transparent:true, opacity:0.2, emissive:0x002244, side:THREE.DoubleSide});
  const lineMat = new THREE.LineBasicMaterial({color:0x88ccff});

  // コントローラー
  let controller = renderer.xr.getController(0);
  const controllerGrip = renderer.xr.getControllerGrip(0);
  const modelFactory = new XRControllerModelFactory();
  controllerGrip.add(modelFactory.createControllerModel(controllerGrip));
  scene.add(controller); scene.add(controllerGrip);
  playerGroup.add(controller); playerGroup.add(controllerGrip);

  const laser = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-10)]), new THREE.LineBasicMaterial({color:0x00ffff, transparent:true, opacity:0.3}));
  controller.add(laser);

  // --- 操作ロジック ---
  let isDrawing = false;
  let ghost = null;
  let drawStart = new THREE.Vector3();

  controller.addEventListener('selectstart', () => {
    if (kekkaiList.length >= KEKKAI_LIMIT) { pulseHUD("展開限界", "#f44"); return; }
    isDrawing = true;
    drawStart.setFromMatrixPosition(controller.matrixWorld);

    const geo = new THREE.BoxGeometry(1,1,1);
    ghost = new THREE.Mesh(geo, boxMat.clone());
    ghost.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), lineMat));
    ghost.position.copy(drawStart);
    ghost.scale.set(0.1,0.1,0.1);
    scene.add(ghost);
  });

  controller.addEventListener('selectend', () => {
    if(isDrawing && ghost) finalizeKekkai();
    isDrawing = false;
  });

  function updateGhost() {
    if(!isDrawing || !ghost) return;
    const curr = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);
    const center = new THREE.Vector3().addVectors(drawStart, curr).multiplyScalar(0.5);
    const size = new THREE.Vector3().subVectors(curr, drawStart);
    size.x = Math.max(0.1, Math.abs(size.x));
    size.y = Math.max(0.1, Math.abs(size.y));
    size.z = Math.max(0.1, Math.abs(size.z));
    ghost.position.copy(center);
    ghost.scale.copy(size);
  }

  function finalizeKekkai() {
    const size = ghost.scale.clone();
    const pos = ghost.position.clone();
    scene.remove(ghost); ghost = null;

    const mesh = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), boxMat.clone());
    mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(1,1,1)), lineMat.clone()));
    mesh.position.copy(pos);
    mesh.scale.copy(size);
    scene.add(mesh);

    const shape = new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2));
    const body = new CANNON.Body({ mass: 0, material: defaultMaterial });
    body.addShape(shape);
    body.position.copy(pos);
    world.addBody(body);

    const kekkai = { mesh, body, created: performance.now() };
    kekkaiList.push(kekkai);

    spawnKanji("結", pos, "#0af");
    speak("ケツ！");
    pulseHUD("結界 展開", "#0af");

    setTimeout(() => {
      if(kekkaiList.includes(kekkai)) removeKekkai(kekkai);
    }, KEKKAI_DURATION);

    document.getElementById('kCount').textContent = kekkaiList.length;
  }

  function metsKekkai(k) {
    if(!k) return;
    spawnKanji("滅", k.mesh.position, "#f24");
    speak("メツ！");
    world.removeBody(k.body);

    let t=0;
    const startScale = k.mesh.scale.clone();
    function anim(){
      t+=0.1;
      if(t>=1) {
        scene.remove(k.mesh);
        kekkaiList = kekkaiList.filter(x=>x!==k);
        document.getElementById('kCount').textContent = kekkaiList.length;
      } else {
        k.mesh.scale.copy(startScale).multiplyScalar(1-t);
        requestAnimationFrame(anim);
      }
    }
    anim();
  }

  function kaiKekkai(k) {
    spawnKanji("解", k.mesh.position, "#8f8");
    speak("カイ");
    removeKekkai(k);
  }

  function removeKekkai(k) {
    scene.remove(k.mesh);
    world.removeBody(k.body);
    kekkaiList = kekkaiList.filter(x=>x!==k);
    document.getElementById('kCount').textContent = kekkaiList.length;
  }

  // --- 敵管理 ---
  let enemies = [];
  function spawnEnemy() {
    const r = 0.2;
    const mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(r, 1), new THREE.MeshStandardMaterial({color:0xff0044, emissive:0x550011}));
    scene.add(mesh);

    const body = new CANNON.Body({ mass: 1, shape: new CANNON.Sphere(r), material: defaultMaterial });
    body.position.set((Math.random()-0.5)*5, 5, (Math.random()-0.5)*5 - 2);
    world.addBody(body);

    enemies.push({mesh, body});
  }

  function updateEnemies() {
    if(enemies.length < 3 && Math.random()<0.02) spawnEnemy();
    enemies.forEach(en => {
      en.mesh.position.copy(en.body.position);
      en.mesh.quaternion.copy(en.body.quaternion);
      if(en.body.position.y < -5) destroyEnemy(en);
    });
  }

  function destroyEnemy(en) {
    scene.remove(en.mesh);
    world.removeBody(en.body);
    enemies = enemies.filter(e=>e!==en);
    pulseHUD("妖、滅却", "#f0f");
  }

  // --- 入力監視 ---
  function pickKekkai() {
    const origin = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);
    const dir = new THREE.Vector3(0,0,-1).applyQuaternion(controller.quaternion);
    const ray = new THREE.Ray(origin, dir);
    let hit=null, minD=Infinity;
    kekkaiList.forEach(k => {
      const box = new THREE.Box3().setFromObject(k.mesh);
      if(ray.intersectsBox(box)){
        const d = origin.distanceTo(k.mesh.position);
        if(d<minD){ minD=d; hit=k; }
      }
    });
    return hit;
  }

  let btnState = {A:false, B:false, At:0};
  function pollInput() {
    const session = renderer.xr.getSession();
    if(!session) return;
    for(const src of session.inputSources) {
      if(!src.gamepad) continue;
      const gp = src.gamepad;

      if(gp.buttons[4]?.pressed) {
        if(!btnState.A) { btnState.A=true; btnState.At=performance.now(); }
      } else {
        if(btnState.A) {
          if(performance.now()-btnState.At > 300) {
            const k = pickKekkai();
            if(k) metsKekkai(k);
          }
          btnState.A=false;
        }
      }
      if(gp.buttons[5]?.pressed) {
        if(!btnState.B) {
          const k = pickKekkai();
          if(k) kaiKekkai(k);
          btnState.B=true;
        }
      } else { btnState.B=false; }
    }
  }

  function pulseHUD(txt, col){
    const el = document.getElementById('statusText');
    el.textContent=txt; el.style.color=col;
    setTimeout(()=>{ if(el.textContent==txt) el.style.color="#f0a"; }, 1500);
  }

  // --- メインループ ---
  const clock = new THREE.Clock();
  renderer.setAnimationLoop(() => {
    const dt = Math.min(clock.getDelta(), 0.1);
    world.step(1/60, dt, 3);
    updateGhost();
    updateEnemies();
    pollInput();
    renderer.render(scene, camera);
  });

</script>
</head>
<body></body>
</html>

