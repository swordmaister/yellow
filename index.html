<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>VR結界バトル（フル版）</title>

<!-- Three.js CDN（WebXR対応版） -->
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/webxr/VRButton.js"></script>

<style>
    body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
        font-family: sans-serif;
        touch-action: none;
        user-select: none;
    }

    /* スマホ用のUI（Questでは非表示） */
    #mobileUI {
        position: fixed;
        bottom: 20px;
        width: 100%;
        text-align: center;
        z-index: 10;
        display: none;
    }

    #createBtn {
        width: 150px;
        height: 150px;
        background: rgba(255,255,255,0.1);
        border: 2px solid #fff;
        border-radius: 50%;
        color: #fff;
        font-size: 20px;
    }

    /* QuestではVR UIを3D空間内に置くため、画面には何も出さない */
    #vrUIPlaceholder {
        display: none;
    }
</style>
</head>

<body>
    <!-- スマホ用UI（VRでは非表示） -->
    <div id="mobileUI">
        <button id="createBtn">結界</button>
    </div>

<script>
/* --------------------------
    第1部：HTML/スタイル読み込み完了
    次のメッセージで Three.js + WebXR 初期化を送ります
--------------------------- */
</script>

</body>
</html>
<script type="module">
/* 第3部：コントローラ / Gamepad / 腕振り判定 / スティック移動 */
/* 依存: window.__Kekkai (第2部) が存在すること */

const K = window.__Kekkai;
if(!K) throw new Error('Kekkai core (K) not found. Load Part2 first.');

K.controllers = []; // 各コントローラの状態を入れる配列

/* Controller 構築ユーティリティ */
function createXRController(index){
  const controller = K.renderer.xr.getController(index);
  controller.userData.index = index;
  // add visual helper (small line) for debugging (only visible in VR)
  const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1)]);
  const mat = new THREE.LineBasicMaterial({ color: 0x00ffcc });
  const line = new THREE.Line(geometry, mat);
  line.scale.z = 0.2;
  controller.add(line);

  // state object
  const state = {
    index,
    controller,
    grip: K.renderer.xr.getControllerGrip ? K.renderer.xr.getControllerGrip(index) : null,
    prevPos: new THREE.Vector3(),
    vel: new THREE.Vector3(),
    lastFrameTime: performance.now(),
    drawing: false,
    triggerPressed: false,
    lastTriggerPressed: false,
    thumbstick: { x:0, y:0 },
    _uiPressed: false
  };
  K.scene.add(controller);
  if(state.grip) K.scene.add(state.grip);

  // store
  K.controllers[index] = state;
  return state;
}

/* build two controllers normally */
createXRController(0);
createXRController(1);

/* デッドゾーン & 感度 */
K.ctrlConfig = {
  deadzone: 0.18,
  stickSensitivity: 1.0,
  drawVelocityScale: 0.12,
  maxKekkaiScale: 10.0
};

/* 結界イベントのプレースホルダ（第4部でオーバーライドされる） */
K.onKekkaiStart = K.onKekkaiStart || function(controllerState, worldPos){
  // controllerState: object from K.controllers
  // worldPos: THREE.Vector3 where ghost should start
  // console.log('Kekkai Start', controllerState.index, worldPos);
};
K.onKekkaiUpdate = K.onKekkaiUpdate || function(controllerState, scaleVec){
  // scaleVec: THREE.Vector3 of intended scales
  // console.log('Kekkai Update', controllerState.index, scaleVec);
};
K.onKekkaiEnd = K.onKekkaiEnd || function(controllerState){
  // console.log('Kekkai End', controllerState.index);
};

/* Gamepad/Controller 更新（各フレーム） */
function updateControllers(dt){
  const session = K.renderer.xr.getSession ? K.renderer.xr.getSession() : null;
  for(let i=0;i<K.controllers.length;i++){
    const s = K.controllers[i];
    if(!s || !s.controller) continue;

    // get world position
    const pos = new THREE.Vector3();
    s.controller.getWorldPosition(pos);

    // compute simple velocity (world)
    s.vel.copy(pos).sub(s.prevPos).divideScalar(Math.max(dt, 1e-6));
    s.prevPos.copy(pos);

    // process inputSource/gamepad (if any)
    const inputSource = s.controller.userData && s.controller.userData.inputSource ? s.controller.userData.inputSource : null;

    // Fallback: try to find matching XR input sources by index from session
    if(!inputSource && session && session.inputSources && session.inputSources.length > 0){
      const guess = session.inputSources[i] || session.inputSources[0];
      if(guess) s.controller.userData.inputSource = guess;
    }

    const gp = s.controller.userData.inputSource && s.controller.userData.inputSource.gamepad ? s.controller.userData.inputSource.gamepad : null;

    // handle gamepad (trigger and axes)
    if(gp){
      // axes mapping: some controllers put primary stick at [0,1], others at [2,3]
      // prefer (2,3) if present — typical for Oculus
      const axX = gp.axes.length >= 4 ? gp.axes[2] : gp.axes[0] || 0;
      const axY = gp.axes.length >= 4 ? gp.axes[3] : gp.axes[1] || 0;
      // apply deadzone
      s.thumbstick.x = Math.abs(axX) > K.ctrlConfig.deadzone ? axX * K.ctrlConfig.stickSensitivity : 0;
      s.thumbstick.y = Math.abs(axY) > K.ctrlConfig.deadzone ? axY * K.ctrlConfig.stickSensitivity : 0;

      // buttons: 0 is usually trigger, 1 is squeeze/grip, others for menu/thumb
      const trigger = gp.buttons[0] && gp.buttons[0].pressed;
      s.triggerPressed = !!trigger;

      // trigger down event
      if(s.triggerPressed && !s.lastTriggerPressed){
        // start drawing: determine start point slightly in front of controller
        const forward = new THREE.Vector3(0,0,-1).applyQuaternion(s.controller.quaternion);
        const startWorld = new THREE.Vector3().copy(pos).add(forward.multiplyScalar(0.2));
        s.drawing = true;
        K.onKekkaiStart(s, startWorld);
      }
      // while held -> update drawing using velocity in controller local space
      if(s.triggerPressed && s.drawing){
        // transform world vel to controller local space
        const inv = new THREE.Matrix4().copy(s.controller.matrixWorld).invert();
        const localVel = s.vel.clone().applyMatrix4(inv);
        // map to positive scale factors using absolute values
        let sx = 1 + Math.abs(localVel.x) * K.ctrlConfig.drawVelocityScale;
        let sy = 1 + Math.abs(localVel.y) * K.ctrlConfig.drawVelocityScale;
        let sz = 1 + Math.abs(localVel.z) * K.ctrlConfig.drawVelocityScale;
        // clamp by max
        sx = Math.min(K.ctrlConfig.maxKekkaiScale, sx);
        sy = Math.min(K.ctrlConfig.maxKekkaiScale, sy);
        sz = Math.min(K.ctrlConfig.maxKekkaiScale, sz);
        const scaleVec = new THREE.Vector3(sx, sy, sz);
        K.onKekkaiUpdate(s, scaleVec);
      }
      // trigger up -> finalize
      if(!s.triggerPressed && s.drawing){
        s.drawing = false;
        K.onKekkaiEnd(s);
      }
      s.lastTriggerPressed = s.triggerPressed;
    } // end if gp
  } // end for
}

/* スティック移動（カニ歩き維持）: 左コントローラのスティックを想定 */
/* ここでは移動ベクトルを K.xrMove vector に書き込み、物理/プレイヤーモジュールが利用する */
K.xrMove = K.xrMove || new THREE.Vector3();

function updateXRMovement(){
  const left = K.controllers[0];
  if(!left) return;
  const src = left.controller.userData && left.controller.userData.inputSource ? left.controller.userData.inputSource : null;
  if(!src || !src.gamepad) return;
  const gp = src.gamepad;
  // axes mapping again
  const axX = gp.axes.length >= 4 ? gp.axes[2] : gp.axes[0] || 0;
  const axY = gp.axes.length >= 4 ? gp.axes[3] : gp.axes[1] || 0;
  const dz = K.ctrlConfig.deadzone;
  const lx = Math.abs(axX) > dz ? axX : 0;
  const ly = Math.abs(axY) > dz ? axY : 0;
  // convert to world movement relative to camera forward but preserve facing
  if(lx !== 0 || ly !== 0){
    const forward = new THREE.Vector3();
    K.camera.getWorldDirection(forward); forward.y = 0; forward.normalize();
    const theta = Math.atan2(forward.x, forward.z);
    // forward/back uses -ly (thumb up is -1 on many controllers)
    const moveX = (-ly) * Math.sin(theta) + (lx) * Math.sin(theta + Math.PI/2);
    const moveZ = (-ly) * Math.cos(theta) + (lx) * Math.cos(theta + Math.PI/2);
    // write to K.xrMove (not applying magnitude yet)
    K.xrMove.set(moveX, 0, moveZ);
  } else {
    K.xrMove.set(0,0,0);
  }
}

/* フレームに登録する (第2部の K.onFrame を利用) */
K.onFrame((time, frame)=>{
  const dt = Math.min((time - (K._lastFrameTime || time))/1000, 0.1);
  K._lastFrameTime = time;
  try {
    updateControllers(dt);
    updateXRMovement();
  } catch(e){
    console.error('controller update error', e);
  }
});

/* Expose helpers for debugging in console */
window.__Kekkai = K;
console.log('Kekkai controllers module loaded. Controllers count:', K.controllers.length);
</script>
<script type="module">
/* 第4部：結界（ゴースト生成・腕振り判定・確定処理・物理連携） */

const K = window.__Kekkai;
if(!K) throw new Error('Kekkai core (K) not found. Load Part2/3 first.');

/* 初期化：結界リストとユーティリティが無ければ用意 */
K.kekkaiList = K.kekkaiList || [];
K.updateCounts = K.updateCounts || function(){
  // 簡易DOM更新（もし存在すれば）
  try{
    const elK = document.getElementById('kCount'); if(elK) elK.textContent = K.kekkaiList.length;
    const elE = document.getElementById('eCount'); if(elE) elE.textContent = (K.enemies ? K.enemies.length : 0);
    const elKill = document.getElementById('killCount'); if(elKill) elKill.textContent = (K.killCount || 0);
  }catch(e){}
};

/* ゴースト（仮想結界）素材 */
const GHOST_MAT = new THREE.MeshStandardMaterial({
  color: 0x00ccff, transparent: true, opacity: 0.28, side: THREE.DoubleSide, depthWrite: false
});
const GHOST_EDGE = new THREE.LineBasicMaterial({ color: 0x88ffff, linewidth: 2 });

/* 設定 */
K.kekkaiConfig = K.kekkaiConfig || {
  maxKekkai: 6,
  lifeMs: 35000,
  creationScaleClamp: { min: 0.5, max: 12.0 },
  finalizeScaleEaseMs: 350
};

/* helper: world point from controller */
function controllerFrontPoint(controllerState, dist=0.6){
  const pos = new THREE.Vector3();
  controllerState.controller.getWorldPosition(pos);
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(controllerState.controller.quaternion);
  return pos.add(forward.multiplyScalar(dist));
}

/* helper: build ghost */
function buildGhostAt(pos){
  const geo = new THREE.BoxGeometry(1,1,1);
  const mesh = new THREE.Mesh(geo, GHOST_MAT.clone());
  mesh.position.copy(pos);
  mesh.castShadow = false; mesh.receiveShadow = false;
  // edges
  const edges = new THREE.LineSegments(new THREE.EdgesGeometry(geo), GHOST_EDGE.clone());
  mesh.add(edges);
  return mesh;
}

/* helper: finalize visual -> actual kekkai */
function finalizeKekkaiFromGhost(ghostMesh, creatorController){
  // get world size from scaled unit cube
  const worldScale = new THREE.Vector3();
  ghostMesh.getWorldScale(worldScale);

  const size = new THREE.Vector3(worldScale.x, worldScale.y, worldScale.z);
  // clamp sizes
  size.x = Math.max(K.kekkaiConfig.creationScaleClamp.min, Math.min(K.kekkaiConfig.creationScaleClamp.max, size.x));
  size.y = Math.max(K.kekkaiConfig.creationScaleClamp.min, Math.min(K.kekkaiConfig.creationScaleClamp.max, size.y));
  size.z = Math.max(K.kekkaiConfig.creationScaleClamp.min, Math.min(K.kekkaiConfig.creationScaleClamp.max, size.z));

  // center position
  const pos = new THREE.Vector3();
  ghostMesh.getWorldPosition(pos);

  // build final mesh with nicer material
  const mat = new THREE.MeshPhongMaterial({ color: 0x0088ff, transparent:true, opacity:0.32, emissive:0x003355, side: THREE.DoubleSide });
  const finalMesh = new THREE.Mesh(new THREE.BoxGeometry(size.x, size.y, size.z), mat);
  finalMesh.position.copy(pos);
  finalMesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(finalMesh.geometry), new THREE.LineBasicMaterial({ color: 0x66eeff })));
  K.scene.add(finalMesh);

  // optional physics: if CANNON available, create body
  let body = null;
  if(window.CANNON || window.CANNONES || window.CANNON_WORLD || window.CANNON){
    try{
      const C = window.CANNON || window.CANNONES || window.CANNON_WORLD;
      if(C && C.World){ // basic check for cannon-es-like object
        // Use cannon-es if available as window.CANNON
        const cannon = window.CANNON;
        if(cannon && cannon.Body){
          const bodyObj = new cannon.Body({ mass: 0, material: (K.matKekkai || undefined) });
          const hx = size.x/2, hy = size.y/2, hz = size.z/2;
          // thin wall approach: add 6 thin boxes
          const th = 0.25;
          bodyObj.addShape(new cannon.Box(new cannon.Vec3(th, hy, hz)), new cannon.Vec3(hx, 0, 0));
          bodyObj.addShape(new cannon.Box(new cannon.Vec3(th, hy, hz)), new cannon.Vec3(-hx, 0, 0));
          bodyObj.addShape(new cannon.Box(new cannon.Vec3(hx, th, hz)), new cannon.Vec3(0, hy, 0));
          bodyObj.addShape(new cannon.Box(new cannon.Vec3(hx, th, hz)), new cannon.Vec3(0, -hy, 0));
          bodyObj.addShape(new cannon.Box(new cannon.Vec3(hx, hy, th)), new cannon.Vec3(0, 0, hz));
          bodyObj.addShape(new cannon.Box(new cannon.Vec3(hx, hy, th)), new cannon.Vec3(0, 0, -hz));
          bodyObj.position.set(pos.x, pos.y, pos.z);
          if(K.world && K.world.addBody) K.world.addBody(bodyObj);
          body = bodyObj;
        }
      }
    }catch(e){
      console.warn('cannon create failed', e);
    }
  }

  const kek = {
    mesh: finalMesh,
    body: body, // may be null
    createdAt: performance.now(),
    lifeMs: K.kekkaiConfig.lifeMs,
    initialSize: size.clone(),
    isShrinking: false
  };

  K.kekkaiList.push(kek);
  K.updateCounts();

  // auto-expire
  setTimeout(()=>{ try{ removeKekkai(kek); }catch(e){} }, kek.lifeMs);

  // small finalize effect
  spawnFinalizeEffect(pos, size);
  return kek;
}

/* remove function */
function removeKekkai(k){
  if(!k) return;
  try{ K.scene.remove(k.mesh); }catch(e){}
  if(k.body && K.world && K.world.removeBody){ try{ K.world.removeBody(k.body); }catch(e){} }
  K.kekkaiList = K.kekkaiList.filter(x=>x!==k);
  K.updateCounts();
}

/* simple finalize particle effect */
function spawnFinalizeEffect(pos, size){
  const count = 12;
  for(let i=0;i<count;i++){
    const s = 0.12 + Math.random()*0.18;
    const geo = new THREE.BoxGeometry(s,s,s);
    const m = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0xffcc88 }));
    m.position.copy(pos);
    K.scene.add(m);
    const vel = new THREE.Vector3((Math.random()-0.5)*2, Math.random()*1.6, (Math.random()-0.5)*2);
    (function anim(o, v){
      o.position.add(v.multiplyScalar(0.06));
      o.scale.multiplyScalar(0.96);
      o.rotation.x += 0.1;
      if(o.scale.x > 0.02) requestAnimationFrame(()=>anim(o, v));
      else { try{ K.scene.remove(o); o.geometry.dispose(); o.material.dispose(); }catch(e){} }
    })(m, vel);
  }
}

/* attach handlers to K.onKekkaiStart/Update/End provided by previous part */
let perControllerGhost = new Map(); // controller.index -> { ghostMesh, baseTime }

K.onKekkaiStart = function(controllerState, worldPos){
  try{
    // prevent too many kekkai
    if(K.kekkaiList.length >= K.kekkaiConfig.maxKekkai){
      if(K.hud && K.hud.statusText) K.hud.statusText.textContent = '結界数上限';
      return;
    }
    // build ghost at worldPos
    const gm = buildGhostAt(worldPos);
    gm.scale.set(1,1,1);
    K.scene.add(gm);
    perControllerGhost.set(controllerState.index, { ghost: gm, startedAt: performance.now() });
    if(K.hud && K.hud.statusText) K.hud.statusText.textContent = '結界作成中…';
  }catch(e){ console.error('onKekkaiStart error', e); }
};

K.onKekkaiUpdate = function(controllerState, scaleVec){
  try{
    const entry = perControllerGhost.get(controllerState.index);
    if(!entry) return;
    const ghost = entry.ghost;
    // We interpret scaleVec (sx,sy,sz) as multipliers. For better UX, apply easing interpolation.
    // Smooth approach: target = scaleVec; current lerp to target.
    const cur = ghost.scale;
    cur.x += (scaleVec.x - cur.x) * 0.3;
    cur.y += (scaleVec.y - cur.y) * 0.3;
    cur.z += (scaleVec.z - cur.z) * 0.3;
    // reposition ghost slightly in front of controller to follow hand
    const front = controllerFrontPoint(controllerState, 0.4);
    ghost.position.lerp(front, 0.25);

    // visual feedback: pulsing edge intensity based on magnitude
    const mag = (cur.x + cur.y + cur.z) / 3;
    ghost.material.opacity = 0.18 + Math.min(0.6, (mag-1)*0.04);
  }catch(e){ console.error('onKekkaiUpdate error', e); }
};

K.onKekkaiEnd = function(controllerState){
  try{
    const entry = perControllerGhost.get(controllerState.index);
    if(!entry) return;
    const ghost = entry.ghost;
    // animate finalize: scale to final size smoothly, then convert to solid kekkai
    const start = performance.now();
    const duration = Math.max(120, K.kekkaiConfig.finalizeScaleEaseMs);
    const initialScale = ghost.scale.clone();
    // determine final scale by clamping
    const finalScale = new THREE.Vector3(
      Math.min(K.kekkaiConfig.creationScaleClamp.max, Math.max(K.kekkaiConfig.creationScaleClamp.min, initialScale.x)),
      Math.min(K.kekkaiConfig.creationScaleClamp.max, Math.max(K.kekkaiConfig.creationScaleClamp.min, initialScale.y)),
      Math.min(K.kekkaiConfig.creationScaleClamp.max, Math.max(K.kekkaiConfig.creationScaleClamp.min, initialScale.z))
    );
    (function easeOutAnim(){
      const now = performance.now();
      const t = Math.min(1, (now - start)/duration);
      const ease = 1 - Math.pow(1 - t, 3);
      ghost.scale.set(
        initialScale.x + (finalScale.x - initialScale.x) * ease,
        initialScale.y + (finalScale.y - initialScale.y) * ease,
        initialScale.z + (finalScale.z - initialScale.z) * ease
      );
      ghost.material.opacity = 0.28 + 0.6 * ease;
      if(t < 1) requestAnimationFrame(easeOutAnim);
      else {
        // finalize: create persistent kekkai and remove ghost
        const kek = finalizeKekkaiFromGhost(ghost, controllerState);
        try{ K.scene.remove(ghost); }catch(e){}
        perControllerGhost.delete(controllerState.index);
        if(K.hud && K.hud.statusText) K.hud.statusText.textContent = '結界設置済';
        // optional callback for game logic
        if(typeof K.onKekkaiPlaced === 'function') try{ K.onKekkaiPlaced(kek, controllerState); }catch(e){}
      }
    })();
  }catch(e){ console.error('onKekkaiEnd error', e); }
};

/* safety: if session ends while drawing, finalize any ghosts */
K.renderer.xr.addEventListener && K.renderer.xr.addEventListener('sessionend', ()=>{
  for(const [idx, entry] of perControllerGhost.entries()){
    try{ K.onKekkaiEnd({ index: idx }); } catch(e) {}
  }
});

/* expose small util to destroy all kekkai (debug) */
K.clearAllKekkai = function(){
  while(K.kekkaiList.length) removeKekkai(K.kekkaiList[0]);
  perControllerGhost.clear();
  K.updateCounts();
};

console.log('Kekkai visual & finalize module loaded.');

</script>
<script type="module">
/* 第5部：敵AI / Wave管理 / 物理連携（CANNONが無ければ簡易物理） */

const K = window.__Kekkai;
if(!K) throw new Error('Kekkai core (K) not found. Load previous parts first.');

/* 初期値 */
K.enemies = K.enemies || [];
K.killCount = K.killCount || 0;
K.wave = K.wave || 1;
K.killsToNextWave = K.killsToNextWave || 3;
K.MAX_ENEMIES = K.MAX_ENEMIES || 6;
K.RESPAWN_SECONDS = K.RESPAWN_SECONDS || 8;

/* helper: random range */
function rand(a,b){ return a + Math.random()*(b-a); }

/* AABB 判定ユーティリティ（Three.jsベース） */
function boxContainsPoint(boxMesh, point){
  const box = new THREE.Box3().setFromObject(boxMesh);
  return box.containsPoint(point);
}

/* Enemy factory: 物理があればCannon body を作る、無ければ見た目とシンプルな velocity を持たせる */
function spawnEnemy(){
  if(K.enemies.length >= K.MAX_ENEMIES) return;
  const typePool = ['walker','jumper','low_flyer','high_flyer'];
  const type = (K.wave < 2) ? 'static' : typePool[Math.floor(Math.random()*typePool.length)];
  const size = 0.5 + Math.random()*0.6;
  const hue = Math.random();
  const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
  const emissive = new THREE.Color().setHSL(hue, 1.0, 0.3);
  const geo = (Math.random()<0.4) ? new THREE.SphereGeometry(size, 12, 12) : new THREE.BoxGeometry(size*1.2,size*1.2,size*1.2);
  const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color, roughness:0.3, emissive, emissiveIntensity:0.6 }));
  mesh.castShadow = true;
  // spawn position
  const angle = Math.random()*Math.PI*2;
  const dist = 12 + Math.random()*18;
  const spawnY = (type === 'high_flyer' || type === 'low_flyer') ? (3 + Math.random()*6) : (0.8 + Math.random()*1.8);
  mesh.position.set(Math.sin(angle)*dist, spawnY, Math.cos(angle)*dist);
  K.scene.add(mesh);

  // physics branch
  let body = null;
  if(window.CANNON && K.world && typeof window.CANNON.Body === 'function'){
    const C = window.CANNON;
    body = new C.Body({ mass: 3, shape: new C.Sphere(size), material: K.matEnemy || undefined });
    body.position.set(mesh.position.x, mesh.position.y, mesh.position.z);
    body.linearDamping = 0.3;
    K.world.addBody(body);
  } else {
    // fallback: simple velocity vector
    mesh.userData.vel = new THREE.Vector3(rand(-0.6,0.6), 0, rand(-0.6,0.6));
  }

  const enemy = {
    mesh, body, size, type, hp:1, trapped:false, nextMove: performance.now() + rand(0, 1000)
  };
  K.enemies.push(enemy);
  if(typeof K.updateCounts === 'function') K.updateCounts();
}

/* destroy enemy */
function destroyEnemy(enemy){
  try{ K.scene.remove(enemy.mesh); }catch(e){}
  if(enemy.body && K.world && K.world.removeBody){ try{ K.world.removeBody(enemy.body); }catch(e){} }
  K.enemies = K.enemies.filter(e => e !== enemy);
  K.killCount = (K.killCount||0) + 1;
  K.killsToNextWave = (K.killsToNextWave||3) - 1;
  if(K.killsToNextWave <= 0) {
    K.wave = (K.wave||1) + 1;
    K.killsToNextWave = (K.wave < 5) ? 4 : 8;
    if(K.hud && K.hud.statusText) K.hud.statusText.textContent = 'WAVE UP! ' + K.wave;
  }
  if(typeof K.updateCounts === 'function') K.updateCounts();
}

/* pick enemies inside a kekkai box (Three.js Box3 contains) */
function enemiesInsideKekkai(kek){
  const results = [];
  const box = new THREE.Box3().setFromObject(kek.mesh);
  for(const en of K.enemies){
    if(box.containsPoint(en.mesh.position)) results.push(en);
  }
  return results;
}

/* Wave/Spawn loop helper */
let lastSpawnAttempt = performance.now();
K.onFrame((t,f) => {
  const now = performance.now();
  if(K.enemies.length < K.MAX_ENEMIES && (now - lastSpawnAttempt) > K.RESPAWN_SECONDS*1000){
    spawnEnemy(); lastSpawnAttempt = now;
  }
});

/* Enemy behavior update (called each frame) */
function updateEnemyBehavior(dt){
  const ppos = (K.playerBody && K.playerBody.position) ? new THREE.Vector3(K.playerBody.position.x,K.playerBody.position.y,K.playerBody.position.z) : new THREE.Vector3(0,1.2,0);
  for(const en of K.enemies.slice()){
    // sync mesh with body if physics enabled
    if(en.body){
      en.mesh.position.set(en.body.position.x, en.body.position.y, en.body.position.z);
      en.mesh.quaternion.set(en.body.quaternion.x,en.body.quaternion.y,en.body.quaternion.z,en.body.quaternion.w);
    } else {
      // fallback: integrate velocity
      en.mesh.position.add(en.mesh.userData.vel.clone().multiplyScalar(dt*1.0));
      // basic damping
      en.mesh.userData.vel.multiplyScalar(0.995);
    }

    // simple out-of-bounds
    if(en.mesh.position.y < -20) { destroyEnemy(en); continue; }

    if(en.trapped) continue;

    // AI decisions based on type
    const toPlayer = new THREE.Vector3().subVectors(ppos, en.mesh.position);
    const horizontalDist = Math.sqrt(toPlayer.x*toPlayer.x + toPlayer.z*toPlayer.z);
    const nowt = performance.now();
    if(nowt > en.nextMove){
      en.nextMove = nowt + (800 + Math.random()*2000);
      if(en.type === 'static'){ /* do nothing */ }
      else if(en.type === 'walker'){
        // 70% chase, else wander
        if(Math.random() < 0.7){
          const dir = toPlayer.clone().setY(0).normalize().multiplyScalar(6);
          if(en.body) en.body.applyForce(new C.Vec3(dir.x,0,dir.z), en.body.position);
          else en.mesh.userData.vel.add(dir.multiplyScalar(0.02));
        } else {
          en.mesh.userData.vel.add(new THREE.Vector3(rand(-0.5,0.5),0,rand(-0.5,0.5)).multiplyScalar(0.02));
        }
      } else if(en.type === 'jumper'){
        if(Math.random() < 0.75){
          if(en.mesh.position.y < 2.0){
            if(en.body) en.body.velocity.y = 8 + Math.random()*3;
            else en.mesh.position.y += (6 + Math.random()*3) * 0.02;
          }
          const dir = toPlayer.clone().setY(0).normalize();
          if(en.body) en.body.applyForce(new C.Vec3(dir.x*6,0,dir.z*6), en.body.position);
          else en.mesh.userData.vel.add(dir.multiplyScalar(0.02));
        }
      } else if(en.type === 'low_flyer'){
        const hoverY = 3.0 + Math.sin(nowt*0.002);
        const dy = hoverY - en.mesh.position.y;
        if(en.body) en.body.applyForce(new C.Vec3(0, 20*en.body.mass + dy*6, 0), en.body.position);
        else en.mesh.userData.vel.y = dy*0.02;
        const dir = toPlayer.clone().setY(0).normalize();
        if(en.body) en.body.applyForce(new C.Vec3(dir.x*3,0,dir.z*3), en.body.position);
        else en.mesh.userData.vel.add(dir.multiplyScalar(0.01));
      } else if(en.type === 'high_flyer'){
        // 3D chase
        const dy = (ppos.y + 1.0) - en.mesh.position.y;
        const dir = toPlayer.clone().normalize();
        if(en.body) {
          en.body.applyForce(new C.Vec3(0, 12*en.body.mass, 0), en.body.position);
          en.body.applyForce(new C.Vec3(dir.x*8, dir.y*8, dir.z*8), en.body.position);
        } else {
          en.mesh.userData.vel.add(dir.multiplyScalar(0.02));
        }
      }
    }

    // interaction with kekkai: if inside any kekkai, apply trapped logic
    for(const k of K.kekkaiList){
      const box = new THREE.Box3().setFromObject(k.mesh);
      if(box.containsPoint(en.mesh.position)){
        // trap
        en.trapped = true;
        // slow down / pull to center
        const center = new THREE.Vector3(k.mesh.position.x, k.mesh.position.y, k.mesh.position.z);
        const pull = center.clone().sub(en.mesh.position).multiplyScalar(0.2);
        if(en.body) en.body.applyForce(new C.Vec3(pull.x*5, pull.y*5, pull.z*5), en.body.position);
        else en.mesh.userData.vel.add(pull.multiplyScalar(0.02));
        // if the kekkai is shrinking (destroying), kill the enemy
        if(k.isShrinking){
          destroyEnemy(en);
        }
      }
    }
  } // end for
}

/* register frame updater */
K.onFrame((t,f) => {
  const dt = Math.min((t - (K._lastEnemyFrame || t))/1000, 0.1);
  K._lastEnemyFrame = t;
  try{
    updateEnemyBehavior(dt);
  }catch(e){ console.error('enemy update error', e); }
});

/* pickClosestKekkai utility */
function pickClosestKekkai(range){
  let best = null; let bestD2 = range*range;
  const px = (K.playerBody && K.playerBody.position) ? K.playerBody.position.x : 0;
  const py = (K.playerBody && K.playerBody.position) ? K.playerBody.position.y : 1.2;
  const pz = (K.playerBody && K.playerBody.position) ? K.playerBody.position.z : 0;
  for(const k of K.kekkaiList){
    const dx = px - k.mesh.position.x, dy = py - k.mesh.position.y, dz = pz - k.mesh.position.z;
    const d2 = dx*dx + dy*dy + dz*dz;
    if(d2 < bestD2){ bestD2 = d2; best = k; }
  }
  return best;
}

/* 滅 (Metsu) アクション: 最寄りの結界を縮小させ、内部の敵を潰す */
K.metsAction = function(){
  const target = pickClosestKekkai(30);
  if(!target) { if(K.hud) K.hud.statusText.textContent = '対象なし'; return; }
  if(target.isShrinking) return;
  if(K.hud) K.hud.statusText.textContent = '滅！';
  target.isShrinking = true;
  let scale = 1.0;
  const shrink = ()=>{
    if(!K.kekkaiList.includes(target)) return;
    scale -= 0.03;
    if(scale <= 0.04){
      // finalize removal
      removeKekkai(target);
      return;
    }
    // apply visual and logical shrink
    target.mesh.scale.setScalar(scale);
    // check enemies inside and damage/destroy
    const box = new THREE.Box3().setFromObject(target.mesh);
    for(const en of K.enemies.slice()){
      if(box.containsPoint(en.mesh.position)){
        // strong pulling & kill when small enough
        if(scale < (en.size * 0.6)){
          destroyEnemy(en);
        } else {
          // pull toward center
          const center = new THREE.Vector3(target.mesh.position.x, target.mesh.position.y, target.mesh.position.z);
          const pull = center.clone().sub(en.mesh.position).multiplyScalar(0.1);
          if(en.body) en.body.applyForce(new C.Vec3(pull.x*3, pull.y*3, pull.z*3), en.body.position);
          else en.mesh.userData.vel.add(pull.multiplyScalar(0.02));
        }
      }
    }
    requestAnimationFrame(shrink);
  };
  shrink();
};

/* expose pickClosest for other modules and UI */
K.pickClosestKekkai = pickClosestKekkai;

/* wire mobile UI buttons (if present) */
try{
  const metsBtn = document.getElementById('btnMets');
  if(metsBtn) metsBtn.addEventListener('click', (e)=>{ e.preventDefault(); K.metsAction(); });
} catch(e){}

/* initial spawning to seed the world */
for(let i=0;i<3;i++) spawnEnemy();

/* update counts initial */
if(typeof K.updateCounts === 'function') K.updateCounts();

console.log('Kekkai enemies & wave module loaded.');

</script>
<script type="module">
/* 第6部：VR内設定UI（Canvasパネル、Raycast操作、掴み移動、永続化） */

const K = window.__Kekkai;
if(!K) throw new Error('Kekkai core (K) not found. Load previous parts first.');

/* ---------- UI用Canvas と Mesh の作成 ---------- */
const UI_CANVAS_W = 1024, UI_CANVAS_H = 512;
const uiCanvas = document.createElement('canvas');
uiCanvas.width = UI_CANVAS_W; uiCanvas.height = UI_CANVAS_H;
const uiCtx = uiCanvas.getContext('2d');

const uiTexture = new THREE.CanvasTexture(uiCanvas);
uiTexture.encoding = THREE.sRGBEncoding;
const uiMaterial = new THREE.MeshBasicMaterial({ map: uiTexture, side: THREE.DoubleSide, transparent: false });

const uiPlane = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 0.8), uiMaterial);
uiPlane.position.set(0, 1.9, -1.4);
uiPlane.name = 'KekkaiSettingsPanel';
K.scene.add(uiPlane);

/* 保存キー */
const STORAGE_KEY = 'kekkai_vr_ui_settings_v1';

/* UI settings model (shared with K.uiSettings used earlier) */
K.uiSettings = K.uiSettings || {
  moveSpeed: (K.uiSettings && K.uiSettings.moveSpeed) || 6.0,
  maxKekkaiSize: (K.uiSettings && K.uiSettings.maxKekkaiSize) || 6,
  stickSensitivity: (K.uiSettings && K.uiSettings.stickSensitivity) || 1.0,
  joystickInvert: (K.uiSettings && K.uiSettings.joystickInvert) || false,
  buttonLayout: (K.uiSettings && K.uiSettings.buttonLayout) || { draw: 'trigger', mets: 'buttonA' }
};

/* load/save */
function saveUISettings(){
  try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(K.uiSettings)); pulseHUD('設定を保存しました', '#0f8'); }
  catch(e){ console.warn('save failed', e); pulseHUD('保存に失敗しました', '#f44'); }
}
function loadUISettings(){
  try{
    const s = localStorage.getItem(STORAGE_KEY);
    if(s){ Object.assign(K.uiSettings, JSON.parse(s)); }
  }catch(e){ console.warn('load fail', e); }
}
loadUISettings();

/* ---------- 描画ヘルパ（CanvasにUIを描く） ---------- */
function drawUIPanel(){
  uiCtx.clearRect(0,0,UI_CANVAS_W, UI_CANVAS_H);
  // background
  uiCtx.fillStyle = '#021229'; uiCtx.fillRect(0,0,UI_CANVAS_W,UI_CANVAS_H);
  // title
  uiCtx.fillStyle = '#fff'; uiCtx.font = '36px sans-serif'; uiCtx.fillText('結界設定パネル', 28, 48);
  uiCtx.font = '18px sans-serif'; uiCtx.fillStyle = '#88f';
  uiCtx.fillText('VR内でトリガーを押して操作。グリップでパネルを掴めます。', 28, 78);

  // Move Speed slider
  uiCtx.fillStyle = '#ddd'; uiCtx.font = '20px sans-serif';
  uiCtx.fillText('移動速度', 40, 130);
  drawSlider(40, 140, 420, 24, 0.5, 12, K.uiSettings.moveSpeed);

  // Max Kekkai Size
  uiCtx.fillStyle = '#ddd'; uiCtx.fillText('結界最大サイズ', 40, 200);
  drawSlider(40, 210, 420, 24, 1, 12, K.uiSettings.maxKekkaiSize);

  // Stick Sensitivity
  uiCtx.fillStyle = '#ddd'; uiCtx.fillText('スティック感度', 40, 280);
  drawSlider(40, 290, 420, 24, 0.4, 2.5, K.uiSettings.stickSensitivity);

  // Joystick invert toggle
  uiCtx.fillStyle = '#fff'; uiCtx.fillText('スティック反転', 540, 130);
  drawToggle(540, 140, K.uiSettings.joystickInvert);

  // Save button
  drawButton(540, 220, 220, 60, '設定を保存');

  // Reset button
  drawButton(540, 300, 220, 50, '初期化');

  // Remap placeholder
  uiCtx.fillStyle = '#fff'; uiCtx.font = '18px sans-serif'; uiCtx.fillText('ボタンリマップ (準備中)', 540, 380);

  uiTexture.needsUpdate = true;
}

function drawSlider(x,y,w,h,min,max,value){
  // track
  uiCtx.fillStyle = '#333'; uiCtx.fillRect(x, y, w, h);
  // fill
  const t = (value - min)/(max - min);
  uiCtx.fillStyle = '#0ff';
  uiCtx.fillRect(x, y, w * t, h);
  // knob
  uiCtx.fillStyle = '#fff';
  const kx = x + w * t;
  uiCtx.beginPath(); uiCtx.arc(kx, y + h/2, h*0.9, 0, Math.PI*2); uiCtx.fill();
  // label
  uiCtx.fillStyle = '#fff'; uiCtx.font = '18px sans-serif';
  uiCtx.fillText(value.toFixed(2), x + w + 12, y + h/2 + 6);
}

function drawToggle(x,y,on){
  uiCtx.fillStyle = on ? '#0f8' : '#444';
  uiCtx.fillRect(x, y, 80, 36);
  uiCtx.fillStyle = '#000'; uiCtx.font = '18px sans-serif';
  uiCtx.fillText(on ? 'ON' : 'OFF', x + 22, y + 24);
}

function drawButton(x,y,w,h,label){
  uiCtx.fillStyle = '#114'; uiCtx.fillRect(x, y, w, h);
  uiCtx.strokeStyle = '#0ff'; uiCtx.lineWidth = 2; uiCtx.strokeRect(x, y, w, h);
  uiCtx.fillStyle = '#fff'; uiCtx.font = '20px sans-serif'; uiCtx.fillText(label, x + 18, y + h/2 + 8);
}

/* 初回描画 */
drawUIPanel();

/* ---------- パネルインタラクション：RaycasterでUV座標検出 ---------- */
const uiRaycaster = new THREE.Raycaster();
const tempVec = new THREE.Vector3();
const tempMat = new THREE.Matrix4();

function testUIPress(controllerState){
  // returns { hit:bool, uv:{x,y}, point:Vector3 } if hit
  const origin = new THREE.Vector3();
  const dir = new THREE.Vector3(0,0,-1);
  controllerState.controller.getWorldPosition(origin);
  controllerState.controller.getWorldDirection(dir);
  uiRaycaster.set(origin, dir);
  const intersects = uiRaycaster.intersectObject(uiPlane, true);
  if(intersects.length === 0) return { hit:false };
  const I = intersects[0];
  // local coords on plane
  const local = uiPlane.worldToLocal(I.point.clone());
  // Plane geometry is 1.6 x 0.8
  const u = (local.x / 1.6 + 0.5); // 0..1
  const v = ( - local.y / 0.8 + 0.5); // 0..1
  // convert to canvas coords
  const cx = Math.floor(u * UI_CANVAS_W);
  const cy = Math.floor(v * UI_CANVAS_H);
  return { hit:true, uv:{u,v, x:cx, y:cy}, point: I.point.clone() };
}

/* ---------- クリック処理: canvas座標に基づいて設定を変更 ---------- */
function handleUIPress(controllerState){
  const res = testUIPress(controllerState);
  if(!res.hit) return false;
  const x = res.uv.x, y = res.uv.y;
  // detect which control
  // Move Speed slider region: (40,140)-(460,164)
  if(y >= 140 && y <= 164 && x >= 40 && x <= 460){
    // map x to value 0.5..12
    const t = (x - 40) / (420);
    K.uiSettings.moveSpeed = Math.round((0.5 + t*(12-0.5)) * 10) / 10;
    drawUIPanel(); saveUISettingsDebounced();
    return true;
  }
  // Max Kekkai size slider region: (40,210)-(460,234)
  if(y >= 210 && y <= 234 && x >= 40 && x <= 460){
    const t = (x - 40) / (420);
    K.uiSettings.maxKekkaiSize = Math.round((1 + t*(11)) );
    drawUIPanel(); saveUISettingsDebounced();
    return true;
  }
  // Stick sensitivity: (40,290)-(460,314)
  if(y >= 290 && y <= 314 && x >= 40 && x <= 460){
    const t = (x - 40) / 420;
    K.uiSettings.stickSensitivity = Math.round((0.4 + t*(2.1))*100)/100;
    drawUIPanel(); saveUISettingsDebounced();
    return true;
  }
  // Joystick invert: (540,140)-(620,176)
  if(x >= 540 && x <= 620 && y >= 140 && y <= 176){
    K.uiSettings.joystickInvert = !K.uiSettings.joystickInvert;
    drawUIPanel(); saveUISettingsDebounced();
    return true;
  }
  // Save button: (540,220)-(760,280)
  if(x >= 540 && x <= 760 && y >= 220 && y <= 280){
    saveUISettings();
    return true;
  }
  // Reset button: (540,300)-(760,350)
  if(x >= 540 && x <= 760 && y >= 300 && y <= 350){
    // reset to default
    Object.assign(K.uiSettings, { moveSpeed:6.0, maxKekkaiSize:6, stickSensitivity:1.0, joystickInvert:false });
    drawUIPanel(); saveUISettings(); return true;
  }
  return false;
}

/* debounced save to avoid excessive localStorage writes */
let _saveTimer = null;
function saveUISettingsDebounced(){
  if(_saveTimer) clearTimeout(_saveTimer);
  _saveTimer = setTimeout(()=>{ saveUISettings(); }, 800);
}

/* ---------- 掴み（グリップ）でパネル移動 ---------- */
let panelGrab = { grabbed:false, controllerIndex: -1, offset: new THREE.Vector3() };
// We detect grip via gamepad.buttons[1] (squeeze) when intersecting the panel

function tryPanelGrab(controllerState){
  const res = testUIPress(controllerState);
  if(!res.hit) return false;
  // set grabbed if squeeze pressed
  const src = controllerState.controller.userData.inputSource;
  const gp = src && src.gamepad ? src.gamepad : null;
  if(gp && gp.buttons[1] && gp.buttons[1].pressed){
    panelGrab.grabbed = true;
    panelGrab.controllerIndex = controllerState.index;
    // compute offset between controller and panel position in local space
    const ctrlPos = new THREE.Vector3(); controllerState.controller.getWorldPosition(ctrlPos);
    panelGrab.offset.copy(uiPlane.position).sub(ctrlPos);
    return true;
  }
  return false;
}

function releasePanelIfNeeded(controllerState){
  const src = controllerState.controller.userData.inputSource;
  const gp = src && src.gamepad ? src.gamepad : null;
  if(panelGrab.grabbed && panelGrab.controllerIndex === controllerState.index){
    if(!(gp && gp.buttons[1] && gp.buttons[1].pressed)){
      panelGrab.grabbed = false;
      panelGrab.controllerIndex = -1;
    }
  }
}

/* per-frame: update panel grab follow and update texture if moved */
K.onFrame((t,f)=>{
  if(panelGrab.grabbed){
    const c = K.controllers[panelGrab.controllerIndex];
    if(c && c.controller){
      // set panel position = controller position + offset in world space
      const ctrlPos = new THREE.Vector3(); c.controller.getWorldPosition(ctrlPos);
      const newPos = ctrlPos.clone().add(panelGrab.offset);
      uiPlane.position.lerp(newPos, 0.4);
      // optional: face the camera smoothly
      const camPos = new THREE.Vector3(); K.camera.getWorldPosition(camPos);
      uiPlane.lookAt(camPos.x, uiPlane.position.y, camPos.z);
    } else {
      panelGrab.grabbed = false;
      panelGrab.controllerIndex = -1;
    }
  }
});

/* ---------- VRコントローラのトリガーでUIを操作（クリック検出） ---------- */
/* We will listen triggers and when pressed we testUIPress and handleUIPress.
   Need to ensure we don't spam: use per-controller debounce
*/
const uiPressCooldown = {};
K.onFrame((t,f)=>{
  for(const c of K.controllers){
    if(!c || !c.controller) continue;
    const src = c.controller.userData.inputSource;
    const gp = src && src.gamepad ? src.gamepad : null;
    if(!gp) continue;
    const trig = !!(gp.buttons[0] && gp.buttons[0].pressed);
    if(trig && !uiPressCooldown[c.index]){
      // first, try grabbing panel if squeeze active
      tryPanelGrab(c);
      // then try click
      const handled = handleUIPress(c);
      if(handled){
        uiPressCooldown[c.index] = true;
        setTimeout(()=>{ uiPressCooldown[c.index] = false; }, 320);
      }
    } else if(!trig) {
      // on release, also check release of grab
      releasePanelIfNeeded(c);
    }
  }
});

/* ---------- スマホ用（画面上の Save ボタンが押されたら） ---------- */
try{
  const saveBtn = document.getElementById('btnRange'); // repurpose as demo save on mobile
  if(saveBtn){
    saveBtn.addEventListener('click', ()=>{ saveUISettings(); drawUIPanel(); });
  }
}catch(e){}

/* 初期描画 */
drawUIPanel();

/* expose reposition helper for debugging */
K.uiPanel = { mesh: uiPlane, canvas: uiCanvas, redraw: drawUIPanel, save: saveUISettings, load: loadUISettings };

console.log('Kekkai VR UI panel loaded.');

/* 最後に HUD反映 */
if(K.hud && K.hud.statusText) K.hud.statusText.textContent = '設定パネル準備完了';
</script>

<script type="module">
/* ===============================================================
   第4部：腕振り → 歩行速度生成（加速度処理 / リズム検出）
   =============================================================== */

const K = window.__Kekkai;

/* --- 内部ワークスペース --- */
K.walk = {
  accL: { x:0, y:0, z:0, mag:0, history:[], lastZero:0 },
  accR: { x:0, y:0, z:0, mag:0, history:[], lastZero:0 },
  periodL: 0.6,
  periodR: 0.6,
  speed: 0,
  targetSpeed: 0,
  smoothSpeed: 0,
  t: 0
};

const MAX_HISTORY = 60;  // 過去 1 秒程度
const ZERO_THRESHOLD = 0.25; // 揺れゼロ判定
const PEAK_THRESHOLD = 1.15; // 揺れ強度
const MIN_PERIOD = 0.25;
const MAX_PERIOD = 1.1;

function updateAccelFromController(grip, accObj, dt){
  if(!grip || !grip.rawData) return;

  const a = grip.rawData.acceleration;
  accObj.x = a.x || 0;
  accObj.y = a.y || 0;
  accObj.z = a.z || 0;

  accObj.mag = Math.sqrt(accObj.x**2 + accObj.y**2 + accObj.z**2);

  // 履歴更新
  accObj.history.push({ t: performance.now()/1000, mag: accObj.mag });
  if(accObj.history.length > MAX_HISTORY) accObj.history.shift();
}

function detectRhythm(accObj){
  const h = accObj.history;
  if(h.length < 3) return 0;

  const now = h[h.length-1].t;

  // ゼロクロス（揺れの切り替えポイント）
  const last = h[h.length-1].mag;
  const prev = h[h.length-2].mag;

  if(prev > ZERO_THRESHOLD && last <= ZERO_THRESHOLD){
    const period = now - accObj.lastZero;
    accObj.lastZero = now;

    if(period > MIN_PERIOD && period < MAX_PERIOD){
      return period;
    }
  }
  return 0;
}

K.onFrame((t, frame)=>{
  if(!frame || !K.isXRSessionActive) return;

  const dt = 1/90;

  const inputSources = K.renderer.xr.getSession().inputSources;

  let leftGrip = null;
  let rightGrip = null;

  for(const s of inputSources){
    // hand-tracking か controller の両方対応
    if(s.handedness === 'left'){
      leftGrip = s.gamepad;
      K.leftSource = s;
    }
    if(s.handedness === 'right'){
      rightGrip = s.gamepad;
      K.rightSource = s;
    }
  }

  // --- 加速度処理（L/R） ---
  updateAccelFromController(leftGrip,  K.walk.accL, dt);
  updateAccelFromController(rightGrip, K.walk.accR, dt);

  const pL = detectRhythm(K.walk.accL);
  const pR = detectRhythm(K.walk.accR);

  if(pL > 0) K.walk.periodL = pL;
  if(pR > 0) K.walk.periodR = pR;

  // 揺れの強さ＝ピーク検出
  const peakL = Math.max(...K.walk.accL.history.map(v=>v.mag)) - 1.0;
  const peakR = Math.max(...K.walk.accR.history.map(v=>v.mag)) - 1.0;

  const strongL = Math.max(0, peakL / PEAK_THRESHOLD);
  const strongR = Math.max(0, peakR / PEAK_THRESHOLD);

  // 左右の平均リズム
  const period = (K.walk.periodL + K.walk.periodR) / 2;
  const rhythm = 1 / period; // リズムの速さ（周波数）

  // 揺れ強度
  const strength = (strongL + strongR) / 2;

  // 歩行速度 = 揺れ強度 × リズム
  const target = strength * rhythm * 1.2; // 1.2 = 歩行調整係数
  K.walk.targetSpeed = Math.min(target, 2.5); // 上限 2.5 m/s

  // スムージング
  K.walk.smoothSpeed = K.walk.smoothSpeed * 0.85 + K.walk.targetSpeed * 0.15;

  // --- プレイヤー前進 ---
  const cam = K.playerGroup;
  const speed = K.walk.smoothSpeed;

  const dir = new THREE.Vector3();
  K.camera.getWorldDirection(dir);
  dir.y = 0;
  dir.normalize();

  cam.position.addScaledVector(dir, speed * dt);

  // HUD
  if(K.hud.statusText){
    K.hud.statusText.textContent =
      `速度: ${speed.toFixed(2)} m/s | 揺れ ${strength.toFixed(2)} | rhythm ${(rhythm).toFixed(2)}`;
  }
});
</script>

<script type="module">
/* 第7部（最終まとめ）：
   - 物理エンジンが無ければ簡易フォールバックを作成
   - プレイヤー（K.playerBody）を初期化し、XR移動・腕振りの速度・モバイル入力を結合して適用
   - フレーム毎の統合更新処理（位置同期 / 衝突予防の簡易処理）
   - デバッグ・ユーティリティ
   - 初期起動処理を呼び出して安定稼働させる
*/

const K = window.__Kekkai;
if(!K) throw new Error('Kekkai core (K) not found. Load previous parts first.');

/* ------------------------
   1) 物理（CANNON）フォールバック
   ------------------------ */
function ensurePhysics(){
  // If user included cannon-es elsewhere and K.world not set, create cannon world
  if(window.CANNON && !K.world){
    try{
      K.world = new window.CANNON.World();
      K.world.gravity = new window.CANNON.Vec3(0, -15, 0);
      K.matDefault = new window.CANNON.Material('default');
      K.matKekkai = new window.CANNON.Material('kekkai');
      // contact materials could be added here if needed
      console.log('CANNON detected — physics world created.');
    }catch(e){
      console.warn('CANNON detected but failed to init world', e);
      K.world = null;
    }
  }
  // If no cannon, we will use a lightweight kinematic fallback
  if(!K.world){
    if(!K._fallbackPhysics){
      K._fallbackPhysics = { actors: [] };
      console.log('Using fallback physics (no CANNON).');
    }
  }
}
ensurePhysics();

/* ------------------------
   2) プレイヤー物体の初期化（K.playerBody）
   - 既に他で生成されている場合は上書きしない
   ------------------------ */
if(!K.playerBody){
  if(K.world && window.CANNON && typeof window.CANNON.Body === 'function'){
    // create a cannon body for the player
    const c = window.CANNON;
    const pb = new c.Body({
      mass: 80,
      shape: new c.Sphere(0.45),
      material: K.matDefault,
      fixedRotation: true,
      linearDamping: 0.9
    });
    pb.position.set(0, 1.8, 0);
    K.world.addBody(pb);
    K.playerBody = pb;
    console.log('PlayerBody created with CANNON.');
  } else {
    // fallback simple object
    K.playerBody = {
      position: { x:0, y:1.8, z:0 },
      velocity: { x:0, y:0, z:0 },
      radius: 0.45
    };
    console.log('PlayerBody fallback created.');
  }
}

/* ------------------------
   3) 統合更新ループ：K.onFrame に登録する統合処理
   - XRスティック（K.xrMove） と モバイル moveState と K.walk を合成してプレイヤーに適用
   - シンプルな地面保持（y座標） & 衝突簡易防止（壁のすり抜け最小対応）
   ------------------------ */

const integrated = {
  lastT: performance.now(),
  groundY: 0.0,
  moveDamping: 0.88
};

K.onFrame((time, frame) => {
  const now = performance.now();
  const dt = Math.min((now - integrated.lastT)/1000, 0.05);
  integrated.lastT = now;

  // 1) compute desired movement from sources
  // XR movement: K.xrMove (vector in world space direction, magnitude pre-normalized)
  let mx = 0, mz = 0;
  if(K.xrMove && (K.xrMove.x !== 0 || K.xrMove.z !== 0)){
    mx += K.xrMove.x * (K.uiSettings ? K.uiSettings.moveSpeed : 6.0);
    mz += K.xrMove.z * (K.uiSettings ? K.uiSettings.moveSpeed : 6.0);
  }
  // mobile moveState (keyboard/touch): moveState on UI
  if(window.moveState){
    if(moveState.fwd) { mx += Math.sin(playerYaw()); mz += Math.cos(playerYaw()); }
    if(moveState.back){ mx -= Math.sin(playerYaw()); mz -= Math.cos(playerYaw()); }
    if(moveState.left){ mx += Math.sin(playerYaw() + Math.PI/2); mz += Math.cos(playerYaw() + Math.PI/2); }
    if(moveState.right){ mx += Math.sin(playerYaw() - Math.PI/2); mz += Math.cos(playerYaw() - Math.PI/2); }
    // normalize mobile contribution to moveSpeed
    if((moveState.fwd||moveState.back||moveState.left||moveState.right) && K.uiSettings){
      mx *= K.uiSettings.moveSpeed;
      mz *= K.uiSettings.moveSpeed;
    }
  }

  // walk module contribution (arm-swing generated speed): move forward in camera forward direction
  if(K.walk && K.walk.smoothSpeed){
    const dir = new THREE.Vector3();
    K.camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
    mx += dir.x * K.walk.smoothSpeed;
    mz += dir.z * K.walk.smoothSpeed;
  }

  // apply to playerBody (CANNON or fallback)
  if(K.playerBody && K.playerBody.position && K.playerBody.velocity !== undefined){
    // cannon body
    if(K.playerBody.position.x !== undefined && K.playerBody instanceof window.CANNON.Body){
      // use velocity set (smooth)
      K.playerBody.velocity.x = mx;
      K.playerBody.velocity.z = mz;
      // ground check: keep y >= groundY
      if(K.playerBody.position.y < integrated.groundY + 0.1){
        K.playerBody.position.y = integrated.groundY + 0.1;
        K.playerBody.velocity.y = Math.max( K.playerBody.velocity.y, 0 );
      }
    } else {
      // fallback object with simple integration
      K.playerBody.velocity.x = mx;
      K.playerBody.velocity.z = mz;
      // integrate
      K.playerBody.position.x += K.playerBody.velocity.x * dt;
      K.playerBody.position.z += K.playerBody.velocity.z * dt;
      // gravity-like effect and floor
      K.playerBody.velocity.y -= 9.8 * dt;
      K.playerBody.position.y += K.playerBody.velocity.y * dt;
      if(K.playerBody.position.y < integrated.groundY + 0.1){
        K.playerBody.position.y = integrated.groundY + 0.1;
        K.playerBody.velocity.y = 0;
      }
    }
  }

  // sync playerGroup (Three.js) to playerBody
  if(K.playerBody){
    if(K.playerBody instanceof window.CANNON.Body){
      K.playerGroup.position.set(K.playerBody.position.x, K.playerBody.position.y, K.playerBody.position.z);
    } else {
      K.playerGroup.position.set(K.playerBody.position.x, K.playerBody.position.y, K.playerBody.position.z);
    }
  }

  // small collision avoidance: push back enemies that intersect player radius (fallback)
  if(K.enemies && K.enemies.length){
    const px = K.playerGroup.position.x, pz = K.playerGroup.position.z;
    for(const e of K.enemies){
      const ex = e.mesh.position.x, ez = e.mesh.position.z;
      const dx = ex - px, dz = ez - pz;
      const d2 = dx*dx + dz*dz;
      const minR = (e.size || 0.5) + (K.playerBody.radius || 0.45);
      if(d2 < (minR*minR)){
        const d = Math.sqrt(d2) || 0.001;
        const push = (minR - d) * 0.5;
        e.mesh.position.x += (dx/d) * push;
        e.mesh.position.z += (dz/d) * push;
        if(e.body) { e.body.position.x = e.mesh.position.x; e.body.position.z = e.mesh.position.z; }
      }
    }
  }

  // ensure UI canvas texture updates if settings changed externally
  if(K.uiPanel && K.uiPanel.redraw) {
    // optional: update only periodically - here we update every second tick to reduce cost
    if(!K._uiTick) K._uiTick = 0;
    K._uiTick = (K._uiTick + 1) % 10;
    if(K._uiTick === 0) K.uiPanel.redraw();
  }
});

/* helper: read player's yaw (we keep camera rotation in playerGroup.rotation.y) */
function playerYaw(){
  return K.playerGroup ? K.playerGroup.rotation.y : 0;
}

/* ------------------------
   4) デバッグユーティリティ
   ------------------------ */
K.debug = K.debug || {};
K.debug.printState = function(){
  console.log('=== KEKKAI STATE ===');
  console.log('XR Session Active:', K.isXRSessionActive);
  console.log('Controllers:', (K.controllers||[]).length);
  console.log('Player pos:', K.playerBody && (K.playerBody.position ? (K.playerBody.position.x + ',' + K.playerBody.position.y + ',' + K.playerBody.position.z) : K.playerBody));
  console.log('Kekkai count:', (K.kekkaiList||[]).length);
  console.log('Enemies count:', (K.enemies||[]).length);
  console.log('UI settings:', K.uiSettings);
};
K.debug.clearAll = function(){ K.clearAllKekkai && K.clearAllKekkai(); while(K.enemies && K.enemies.length) { try{ K.scene.remove(K.enemies[0].mesh); K.enemies.shift(); }catch(e){ break; } } };

/* ------------------------
   5) 自動起動＆安全措置
   - 確実に K.startMainLoop は回っている想定（第2部で開始済み）
   - 必要なら physics world stepping を行う
   ------------------------ */
(function startUp(){
  // Ensure physics world steps if exists
  if(K.world && typeof K.world.step === 'function'){
    // register stepping in main loop at 60Hz
    K.onFrame((t,f) => {
      // step by fixed dt
      try{
        K.world.step(1/60);
      }catch(e){ console.warn('physics step error', e); }
    });
    console.log('Physics stepping registered.');
  } else {
    console.log('No physics world: skipping physics stepping.');
  }

  // ensure a handful of debug enemies exist if none
  if(!K.enemies || K.enemies.length === 0){
    // create 2 seed enemies
    if(typeof K.spawnEnemy === 'function'){
      K.spawnEnemy && K.spawnEnemy();
      K.spawnEnemy && K.spawnEnemy();
    } else {
      // fallback: use the spawnEnemy from part5 if attached to K; otherwise do nothing
    }
  }

  // final HUD message
  if(K.hud && K.hud.statusText) K.hud.statusText.textContent = 'ゲーム起動済み — VRであるならVRボタンを押して開始';
})();

/* ------------------------
   6) 貼り付けガイド（必ずこの順番でファイルを作ってください）
   - 第1部: HTML + CSS (既に貼ったもの)
   - 第2部: Three.js + WebXR 初期化
   - 第3部: Controller / Gamepad / 腕振り判定基盤
   - 第4部: 結界実装（ゴースト → finalize）
   - 第5部: 敵AI / Wave / 物理連携
   - 第6部: VR内設定UI
   - 第4部(加速度歩行) : ※もし別途貼っているなら腕振り→歩行モジュールも（あなたは既に貼ってます）
   - 第7部: このスクリプト（起動 & 統合） ← いまここ
   ------------------------ */

console.log('Kekkai finalizer loaded. You can call K.debug.printState() in console.');

</script>
