<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>VR Kekkai Sim - Speed & Sensitivity</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

    // ==========================================
    // グローバル変数・設定
    // ==========================================
    let camera, scene, renderer;
    let controller1, controller2;
    let controllerGrip1, controllerGrip2;
    
    // プレイヤー状態
    const playerState = {
        velocity: new THREE.Vector3(),
        isGrounded: false,
        jumpStrength: 10.0,      // ジャンプ力
        gravity: 20.0,           // 重力
        moveSpeed: 3.0,          // 移動速度
        rotationSpeed: 2.0,      // 回転速度
        distanceMode: 'far'      // 'near' or 'far'
    };

    // 結界・オブジェクト管理
    const barriers = [];    // 作成済み結界
    const enemies = [];     // 敵
    const effects = [];     // エフェクト（文字、破片）
    const tempMatrix = new THREE.Matrix4();
    const raycaster = new THREE.Raycaster();

    // 生成中の結界データ
    let activeBarrier = null; 

    // ★修正3: 感度を前回のさらに30倍に設定（ベース値×30）
    const BARRIER_SENSITIVITY = 150.0 * 30.0; 

    // 生成ポイント（赤い点）
    let targetPointMesh;
    const targetDistanceFar = 10.0;
    const targetDistanceNear = 2.0;

    // フォント読み込み用キャンバス
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    // ==========================================
    // 初期化
    // ==========================================
    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x111111, 0, 80);

        // カメラ（ユーザーの頭）
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        // グループに入れて移動操作しやすくする
        const userGroup = new THREE.Group();
        userGroup.position.set(0, 0, 0); // 初期位置
        userGroup.add(camera);
        scene.add(userGroup);
        // 参照用に保持
        playerState.userGroup = userGroup;

        // ライティング
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 10, 0);
        scene.add(directionalLight);

        // 地面
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x333333, 
            roughness: 0.8,
            side: THREE.DoubleSide
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // ターゲットポインター（赤い点）
        const pointGeo = new THREE.SphereGeometry(0.05, 16, 16);
        const pointMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 });
        targetPointMesh = new THREE.Mesh(pointGeo, pointMat);
        scene.add(targetPointMesh);

        // 敵（テスト用ターゲット）
        createTestEnemy(0, 1.5, -5);
        createTestEnemy(3, 1.5, -8);
        createTestEnemy(-3, 1.5, -8);

        // レンダラー設定
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        document.body.appendChild(VRButton.createButton(renderer));

        // コントローラー設定
        setupControllers();

        window.addEventListener('resize', onWindowResize);
    }

    function setupControllers() {
        // Controller 1 (Right assumed usually, but depends on connection order. Logic handles handedness)
        controller1 = renderer.xr.getController(0);
        controller1.addEventListener('selectstart', onSelectStart); // Trigger Down
        controller1.addEventListener('squeeze', onSqueezeStart);    // Grip Down
        controller1.addEventListener('squeezeend', onSqueezeEnd);   // Grip Up
        scene.add(controller1);

        // Controller 2 (Left)
        controller2 = renderer.xr.getController(1);
        controller2.addEventListener('selectstart', onSelectStart);
        controller2.addEventListener('squeeze', onSqueezeStart);
        controller2.addEventListener('squeezeend', onSqueezeEnd);
        scene.add(controller2);

        const controllerModelFactory = new XRControllerModelFactory();

        controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        scene.add(controllerGrip1);

        controllerGrip2 = renderer.xr.getControllerGrip(1);
        controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
        scene.add(controllerGrip2);
    }

    // ==========================================
    // 入力イベントハンドラ
    // ==========================================
    
    // トリガーボタン (人差し指) - アクション実行
    function onSelectStart(event) {
        const controller = event.target;
        const inputSource = controller.inputSource;
        if (!inputSource) return;

        const handedness = inputSource.handedness; // 'left' or 'right'

        if (handedness === 'left') {
            // 左トリガー: 「解」 (一番近い結界を解除)
            removeNearestBarrier();
            showTextEffect("解", targetPointMesh.position, 0x00ffff);
        } else if (handedness === 'right') {
            // 右トリガー: 「滅」 (結界内部の敵を攻撃して結界消滅)
            destroyBarrierAction();
            showTextEffect("滅", targetPointMesh.position, 0xff0000);
        }
    }

    // グリップボタン - 結界生成開始
    function onSqueezeStart(event) {
        const controller = event.target;
        const inputSource = controller.inputSource;
        if (!inputSource) return;

        // 既に作成中は無視（両手同時押しなどの場合、先に押した方優先）
        if (activeBarrier) return;

        const type = (inputSource.handedness === 'left') ? 'solid' : 'ghost'; // 左:顕現(青), 右:ゴースト(緑)
        
        // 開始時のコントローラー位置を記録
        const startPos = controller.position.clone();
        
        // 結界の初期メッシュ作成（ターゲットポイントを中心に）
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        // ピボット調整のため、ジオメトリ自体はずらさず、Scaleで制御する
        
        const material = new THREE.MeshStandardMaterial({
            color: type === 'solid' ? 0x0088ff : 0x00ff88,
            transparent: true,
            opacity: 0.5,
            roughness: 0.1,
            metalness: 0.1,
            side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(targetPointMesh.position);
        mesh.scale.set(0.1, 0.1, 0.1); // 最初は極小
        scene.add(mesh);

        activeBarrier = {
            mesh: mesh,
            controller: controller,
            startControllerPos: startPos,
            type: type,
            initialCenter: targetPointMesh.position.clone()
        };
    }

    // グリップボタン離す - 結界生成完了
    function onSqueezeEnd(event) {
        if (activeBarrier && activeBarrier.controller === event.target) {
            // 配列に保存
            barriers.push(activeBarrier.mesh);
            
            // 完了エフェクト（パッと消える）
            // 「結」などの文字を出しても良いが、ここでは作成完了感のみ
            
            activeBarrier = null;
        }
    }

    // ==========================================
    // メインループ
    // ==========================================
    function animate() {
        renderer.setAnimationLoop(render);
    }

    function render() {
        const dt = 0.016; // 固定デルタタイム簡易版
        
        handleInput(dt);
        updateActiveBarrier();
        updateEffects(dt);
        updateTargetPoint();

        renderer.render(scene, camera);
    }

    // ==========================================
    // ロジック詳細
    // ==========================================

    // プレイヤー移動・視点・ボタン操作
    function handleInput(dt) {
        const session = renderer.xr.getSession();
        if (!session) return;

        let inputSources = session.inputSources;
        
        // ユーザーグループ（カメラ親）の移動用ベクトル
        const moveVector = new THREE.Vector3(0, 0, 0);

        // カメラの向き（Y軸回転のみ抽出）
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);
        cameraDirection.y = 0;
        cameraDirection.normalize();

        const cameraRight = new THREE.Vector3();
        cameraRight.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0));

        // 左右コントローラーの入力走査
        for (const source of inputSources) {
            if (!source.gamepad) continue;
            const gp = source.gamepad;
            const handedness = source.handedness;

            // --- 左手: 移動 ---
            if (handedness === 'left') {
                // axes[2] = X (左右), axes[3] = Y (前後) ※機種により異なる場合あり
                // Quest 2: [2]=stick X, [3]=stick Y. 
                // 左入力で -1, 右入力で +1
                
                if (gp.axes.length >= 4) {
                    // ★修正1: 左右移動の符号を反転 (-gp.axes[2])
                    // 通常: 右(+1)で右へ。左(-1)で左へ。
                    // ユーザー要望「反対」→ 入力値をマイナスにする
                    const inputX = -gp.axes[2]; 
                    const inputY = gp.axes[3]; 

                    // 前後移動 (視点正面基準)
                    if (Math.abs(inputY) > 0.1) {
                        moveVector.addScaledVector(cameraDirection, inputY * playerState.moveSpeed * dt);
                    }
                    // 左右カニ歩き (視点右方向基準)
                    if (Math.abs(inputX) > 0.1) {
                        moveVector.addScaledVector(cameraRight, inputX * playerState.moveSpeed * dt);
                    }
                }

                // A/B/X/Yボタンの処理 (Gamepad buttons)
                // Quest: Left X=[0], Y=[1]? or [3]/[4]? mapping varies.
                // WebXR standard mapping: 
                // [4] = A (or X on left), [5] = B (or Y on left). This is tricky.
                // Checking specific buttons usually requires knowing the profile.
                // 簡易的にボタン押下チェック
            }

            // --- 右手: 視点回転・アクション ---
            if (handedness === 'right') {
                if (gp.axes.length >= 4) {
                    const rotX = gp.axes[2];
                    // 視点回転 (スナップターンまたはスムーズ)
                    if (Math.abs(rotX) > 0.2) {
                        playerState.userGroup.rotation.y -= rotX * playerState.rotationSpeed * dt;
                    }
                }

                // ボタン: A(Jump), B(Distance)
                // standard mapping: [4]=A, [5]=B
                if (gp.buttons[4] && gp.buttons[4].pressed) {
                    // ジャンプ (簡易)
                    if (playerState.userGroup.position.y <= 0.1) { // 地面にいる時
                        // ジャンプ処理は物理演算が必要だが、ここでは簡易的にY位置上昇
                        // 今回は詳細省略（移動メイン）
                    }
                }

                // Bボタン: 遠近切り替え (トグル: 押した瞬間のみ反応させるためのフラグ管理が必要)
                if (gp.buttons[5] && gp.buttons[5].pressed) {
                    if (!playerState.bButtonWasPressed) {
                        playerState.distanceMode = (playerState.distanceMode === 'near') ? 'far' : 'near';
                        playerState.bButtonWasPressed = true;
                    }
                } else {
                    playerState.bButtonWasPressed = false;
                }
            }
        }

        // 移動適用
        playerState.userGroup.position.add(moveVector);
    }

    // ターゲットポイント（赤い点）の更新
    function updateTargetPoint() {
        const dist = (playerState.distanceMode === 'near') ? targetDistanceNear : targetDistanceFar;
        
        // カメラの前方に配置
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        dir.normalize();

        const targetPos = new THREE.Vector3();
        targetPos.copy(camera.position).addScaledVector(dir, dist);
        
        // プレイヤーの足元高さではなく、視線の先だが高さはある程度固定しないと操作しづらい
        // 原作イメージだと「狙った空間座標」なので、そのまま視線の先でOK
        // ただし地面より下には行かないように
        if (targetPos.y < 0) targetPos.y = 0.1;

        targetPointMesh.position.copy(targetPos);
    }

    // 結界生成・変形ロジック
    function updateActiveBarrier() {
        if (!activeBarrier) return;

        const controller = activeBarrier.controller;
        const currentPos = controller.position.clone();
        
        // コントローラーの移動量 (ローカル座標系での差分)
        const diff = new THREE.Vector3().subVectors(currentPos, activeBarrier.startControllerPos);

        // ★修正3: 感度を超強化 (BARRIER_SENSITIVITY)
        // 上(Y)に動かす -> 高さ(Y)拡大
        // 横(X)に動かす -> 幅(X)拡大
        // 奥/手前(Z) -> 奥行き(Z)拡大
        // 斜め -> 立方的拡大
        
        // コントローラーの回転を考慮して「コントローラーにとっての上下左右」にするには
        // コントローラーの逆回転行列をかける必要がありますが、
        // ユーザー指示は「空間で動かす」なのでワールド座標差分で計算します。

        // 基本サイズ1.0 + 移動量 * 感度
        // 負の値にならないようにMath.abs + 最低保証
        const scaleX = 1.0 + Math.abs(diff.x) * BARRIER_SENSITIVITY;
        const scaleY = 1.0 + Math.abs(diff.y) * BARRIER_SENSITIVITY;
        const scaleZ = 1.0 + Math.abs(diff.z) * BARRIER_SENSITIVITY;

        // 斜め（立方体的）判定: 
        // 厳密に分けずとも、X,Y,Z成分それぞれの動きに合わせて拡大すれば、
        // 斜めに動かせばXYZ共に大きくなり立方体的に大きくなる。
        
        activeBarrier.mesh.scale.set(scaleX, scaleY, scaleZ);
    }

    // エフェクト更新
    function updateEffects(dt) {
        for (let i = effects.length - 1; i >= 0; i--) {
            const fx = effects[i];
            
            // ★修正2: エフェクト寿命管理
            fx.life -= dt;
            
            // 拡大アニメーションなど
            if (fx.type === 'text') {
                fx.mesh.position.y += dt * 0.5; // 少し上昇
                fx.mesh.lookAt(camera.position); // 常にカメラ向く
            } else if (fx.type === 'shard') {
                // 破片飛び散り
                fx.mesh.position.addScaledVector(fx.velocity, dt);
                fx.mesh.rotation.x += fx.rotationSpeed.x;
                fx.mesh.rotation.y += fx.rotationSpeed.y;
            }

            // フェードアウト（高速）
            if (fx.life < 0.2) {
                fx.mesh.material.opacity = fx.life / 0.2;
            }

            if (fx.life <= 0) {
                scene.remove(fx.mesh);
                if (fx.mesh.geometry) fx.mesh.geometry.dispose();
                if (fx.mesh.material) fx.mesh.material.dispose();
                effects.splice(i, 1);
            }
        }
    }

    // ==========================================
    // アクション関数
    // ==========================================

    function createTestEnemy(x, y, z) {
        const geo = new THREE.ConeGeometry(0.5, 1.5, 16);
        const mat = new THREE.MeshStandardMaterial({ color: 0xff00ff });
        const enemy = new THREE.Mesh(geo, mat);
        enemy.position.set(x, y, z);
        scene.add(enemy);
        enemies.push(enemy);
    }

    function removeNearestBarrier() {
        // 解：一番近い結界を探して削除
        if (barriers.length === 0) return;

        let nearest = null;
        let minDist = Infinity;
        const pos = targetPointMesh.position;

        barriers.forEach(b => {
            const d = b.position.distanceTo(pos);
            if (d < minDist) {
                minDist = d;
                nearest = b;
            }
        });

        if (nearest && minDist < 5.0) { // ある程度近くないと反応しない
            createDebris(nearest.position, nearest.scale, nearest.material.color);
            scene.remove(nearest);
            barriers.splice(barriers.indexOf(nearest), 1);
        }
    }

    function destroyBarrierAction() {
        // 滅：ターゲットに近い結界を探し、その内部に敵がいれば敵も倒す
        if (barriers.length === 0) return;

        // ターゲットポイントを含む、あるいは一番近い結界
        let targetBarrier = null;
        let minDist = Infinity;
        const targetPos = targetPointMesh.position;

        for (const b of barriers) {
            // シンプルに中心点距離で判定
            const d = b.position.distanceTo(targetPos);
            if (d < minDist) {
                minDist = d;
                targetBarrier = b;
            }
        }

        if (targetBarrier && minDist < 5.0) {
            // 結界の範囲（簡易バウンディングボックス）
            const box = new THREE.Box3().setFromObject(targetBarrier);
            
            // 敵が中に入っているか？
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (box.containsPoint(enemy.position)) {
                    // 敵撃破演出
                    createDebris(enemy.position, new THREE.Vector3(1,1,1), 0xff00ff, 15);
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                }
            }
            
            // 結界破砕演出（内向きに潰れるようなイメージだが、今回は破裂で表現）
            createDebris(targetBarrier.position, targetBarrier.scale, 0xff0000, 20);
            scene.remove(targetBarrier);
            barriers.splice(barriers.indexOf(targetBarrier), 1);
        }
    }

    // 文字エフェクト生成
    function showTextEffect(text, position, colorHex) {
        // Canvasでテクスチャ作成
        const size = 256;
        canvas.width = size;
        canvas.height = size;
        context.clearRect(0, 0, size, size);
        context.fillStyle = '#' + new THREE.Color(colorHex).getHexString();
        context.font = 'bold 180px Arial'; // 明朝体が望ましいが標準フォントで
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, size/2, size/2);

        const texture = new THREE.CanvasTexture(canvas);
        const mat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(mat);
        
        sprite.position.copy(position);
        sprite.scale.set(2, 2, 2);
        scene.add(sprite);

        effects.push({
            type: 'text',
            mesh: sprite,
            life: 0.5 // ★修正2: 寿命を0.5秒に設定（インパクト重視）
        });
    }

    // 破片エフェクト生成
    function createDebris(pos, scale, color, count = 10) {
        const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true });

        for(let i=0; i<count; i++) {
            const mesh = new THREE.Mesh(geo, mat);
            // 結界の大きさの範囲内にランダム配置
            mesh.position.set(
                pos.x + (Math.random() - 0.5) * scale.x,
                pos.y + (Math.random() - 0.5) * scale.y,
                pos.z + (Math.random() - 0.5) * scale.z
            );
            
            // ランダムな飛び散り
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10,
                (Math.random() - 0.5) * 10
            );

            scene.add(mesh);
            effects.push({
                type: 'shard',
                mesh: mesh,
                velocity: velocity,
                rotationSpeed: { x: Math.random(), y: Math.random() },
                life: 0.4 // ★修正2: 寿命短く
            });
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>
