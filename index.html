<!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="utf-8">
<title>真・結界師VR - Ultimate</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<style>
html,body{height:100%;margin:0;padding:0;background:#000;color:#fff;font-family:sans-serif;overflow:hidden;touch-action:none;-webkit-user-select:none;user-select:none;}
canvas{display:block;width:100%;height:100%;touch-action:none;}
#startScreen{position:fixed;top:0;left:0;width:100%;height:100%;background:linear-gradient(180deg,#001133 0%,#000511 100%);z-index:9999;display:flex;align-items:center;justify-content:center;flex-direction:column;}
#startBtn{padding:20px 60px;font-size:24px;font-weight:700;color:#fff;background:linear-gradient(135deg,#0af,#06a);border-radius:16px;border:3px solid #fff;box-shadow:0 0 30px #0af;cursor:pointer;transition:all .2s;}
#startBtn:active{transform:scale(0.95);box-shadow:0 0 50px #0ff;}
#hud{position:fixed;left:12px;top:12px;background:rgba(0,10,30,0.7);border:2px solid #4af;padding:12px;border-radius:8px;font-size:13px;width:200px;pointer-events:none;z-index:100;backdrop-filter:blur(8px);}
.val{font-weight:bold;color:#0ff;}
#mobileUI{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:50;display:none;}
#joystick{position:absolute;bottom:30px;left:30px;width:140px;height:140px;pointer-events:auto;}
#joyBase{width:100%;height:100%;border-radius:50%;background:rgba(255,255,255,0.1);border:2px solid rgba(255,255,255,0.3);position:absolute;}
#joyStick{width:50px;height:50px;border-radius:50%;background:#0ff;box-shadow:0 0 20px #0ff;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transition:transform 0.1s;}
#buttons{position:absolute;bottom:30px;right:30px;display:flex;flex-direction:column;gap:10px;pointer-events:auto;}
.btn{width:80px;height:80px;border-radius:50%;border:3px solid rgba(255,255,255,0.6);color:#fff;font-weight:bold;font-size:16px;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);backdrop-filter:blur(4px);transition:all 0.1s;box-shadow:0 4px 12px rgba(0,0,0,0.4);}
.btn:active{transform:scale(0.9);box-shadow:0 2px 8px rgba(255,255,255,0.3);}
#btnDraw{background:linear-gradient(135deg,#0af,#06a);border-color:#0ff;font-size:20px;width:100px;height:100px;}
#btnDraw.active{background:linear-gradient(135deg,#fff,#0af);color:#000;box-shadow:0 0 25px #0af;}
#btnRow{display:flex;gap:10px;}
#btnMets{background:linear-gradient(135deg,#f24,#a12);}
#btnKai{background:linear-gradient(135deg,#4f8,#284);}
#vrBtn{position:fixed;top:10px;right:10px;padding:10px 20px;background:rgba(0,0,0,0.7);color:#fff;border:2px solid #fff;border-radius:8px;font-size:14px;z-index:100;display:none;pointer-events:auto;}
#crosshair{position:fixed;top:50%;left:50%;width:24px;height:24px;border:2px solid rgba(255,255,255,0.7);border-radius:50%;transform:translate(-50%,-50%);pointer-events:none;z-index:10;box-shadow:0 0 10px rgba(255,255,255,0.5);}
.title{font-size:48px;font-weight:bold;margin-bottom:20px;text-shadow:0 0 20px #0af;}
.subtitle{font-size:18px;color:#aaa;margin-bottom:30px;}
</style>
</head>
<body>
<div id="startScreen">
<div class="title">真・結界師VR</div>
<div class="subtitle">月夜の激闘</div>
<div id="startBtn">タップして開始</div>
</div>

<div id="hud">
<div>WAVE: <span id="wave" class="val">1</span> <span id="waveName">静寂</span></div>
<div>撃破: <span id="kills" class="val">0</span></div>
<div>結界: <span id="kekkaiCount" class="val">0</span>/5</div>
<div id="status" style="color:#0af;margin-top:8px;font-weight:bold;">待機中</div>
</div>

<div id="crosshair"></div>
<button id="vrBtn">VRモード</button>

<div id="mobileUI">
<div id="joystick">
<div id="joyBase"></div>
<div id="joyStick"></div>
</div>
<div id="buttons">
<div class="btn" id="btnDraw">結界</div>
<div id="btnRow">
<div class="btn" id="btnMets">滅</div>
<div class="btn" id="btnKai">解</div>
</div>
</div>
</div>

<script type="importmap">
{
"imports":{
"three":"https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
"three/addons/":"https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
"cannon-es":"https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
}
}
</script>

<script type="module">
import * as THREE from 'three';
import * as CANNON from 'cannon-es';

// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x001133);
scene.fog = new THREE.FogExp2(0x001133, 0.012);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 200);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.xr.enabled = true;
document.body.appendChild(renderer.domElement);

// Physics
const world = new CANNON.World({gravity:new CANNON.Vec3(0,-20,0)});
world.broadphase = new CANNON.SAPBroadphase(world);
world.solver.iterations = 8;

const groundMat = new CANNON.Material('ground');
const playerMat = new CANNON.Material('player');
const enemyMat = new CANNON.Material('enemy');
const kekkaiMat = new CANNON.Material('kekkai');

world.addContactMaterial(new CANNON.ContactMaterial(groundMat,playerMat,{friction:0.1,restitution:0}));
world.addContactMaterial(new CANNON.ContactMaterial(groundMat,enemyMat,{friction:0.4,restitution:0.3}));
world.addContactMaterial(new CANNON.ContactMaterial(kekkaiMat,enemyMat,{friction:0,restitution:0.8}));

// Player
const playerBody = new CANNON.Body({
mass:70,
shape:new CANNON.Sphere(0.5),
material:playerMat,
linearDamping:0.3,
angularDamping:1,
fixedRotation:true
});
playerBody.position.set(0,3,15);
world.addBody(playerBody);

const playerGroup = new THREE.Group();
playerGroup.add(camera);
scene.add(playerGroup);

// Ground
const groundBody = new CANNON.Body({mass:0,material:groundMat});
groundBody.addShape(new CANNON.Plane());
groundBody.quaternion.setFromEuler(-Math.PI/2,0,0);
world.addBody(groundBody);

const groundMesh = new THREE.Mesh(
new THREE.PlaneGeometry(300,300),
new THREE.MeshStandardMaterial({color:0x335533,roughness:0.9})
);
groundMesh.rotation.x = -Math.PI/2;
groundMesh.receiveShadow = true;
scene.add(groundMesh);

// Lighting
const ambient = new THREE.AmbientLight(0x8899ff,0.4);
scene.add(ambient);

const moonLight = new THREE.DirectionalLight(0xccddff,1.2);
moonLight.position.set(30,60,30);
moonLight.castShadow = true;
moonLight.shadow.camera.left = -50;
moonLight.shadow.camera.right = 50;
moonLight.shadow.camera.top = 50;
moonLight.shadow.camera.bottom = -50;
moonLight.shadow.mapSize.set(2048,2048);
scene.add(moonLight);

// Environment
function createObstacle(x,y,z,w,h,d){
const mesh = new THREE.Mesh(
new THREE.BoxGeometry(w,h,d),
new THREE.MeshStandardMaterial({color:0x666677,roughness:0.7})
);
mesh.position.set(x,y,z);
mesh.castShadow = true;
mesh.receiveShadow = true;
scene.add(mesh);

const body = new CANNON.Body({mass:0,material:groundMat});
body.addShape(new CANNON.Box(new CANNON.Vec3(w/2,h/2,d/2)));
body.position.copy(mesh.position);
world.addBody(body);
}

createObstacle(0,3,-30,50,6,6);
createObstacle(-25,2,-10,4,4,4);
createObstacle(25,2.5,-15,5,5,5);
createObstacle(-15,1.5,15,3,3,3);
createObstacle(15,2,12,4,4,4);

// Kekkai system
let kekkaiList = [];
let drawGhost = null;
let isDrawMode = false;
const MAX_KEKKAI = 5;

function createKekkai(pos,scale){
if(kekkaiList.length >= MAX_KEKKAI) return;

const geometry = new THREE.BoxGeometry(scale.x,scale.y,scale.z);
const material = new THREE.MeshPhysicalMaterial({
color:0x00aaff,
transparent:true,
opacity:0.3,
metalness:0.5,
roughness:0.2,
side:THREE.DoubleSide
});
const mesh = new THREE.Mesh(geometry,material);
mesh.position.copy(pos);
scene.add(mesh);

const edges = new THREE.LineSegments(
new THREE.EdgesGeometry(geometry),
new THREE.LineBasicMaterial({color:0xaaffff,linewidth:2})
);
mesh.add(edges);

const body = new CANNON.Body({mass:0,material:kekkaiMat});
const hx=scale.x/2, hy=scale.y/2, hz=scale.z/2;
const t=0.08;

body.addShape(new CANNON.Box(new CANNON.Vec3(hx,hy,t)),new CANNON.Vec3(0,0,hz-t));
body.addShape(new CANNON.Box(new CANNON.Vec3(hx,hy,t)),new CANNON.Vec3(0,0,-(hz-t)));
body.addShape(new CANNON.Box(new CANNON.Vec3(t,hy,hz)),new CANNON.Vec3(hx-t,0,0));
body.addShape(new CANNON.Box(new CANNON.Vec3(t,hy,hz)),new CANNON.Vec3(-(hx-t),0,0));
body.addShape(new CANNON.Box(new CANNON.Vec3(hx,t,hz)),new CANNON.Vec3(0,hy-t,0));
body.addShape(new CANNON.Box(new CANNON.Vec3(hx,t,hz)),new CANNON.Vec3(0,-(hy-t),0));

body.position.copy(pos);
world.addBody(body);

const kekkai = {mesh,body,scale:scale.clone(),timer:Date.now()};
kekkaiList.push(kekkai);
updateHUD();

setTimeout(()=>removeKekkai(kekkai),30000);
}

function removeKekkai(k){
const idx = kekkaiList.indexOf(k);
if(idx === -1) return;
scene.remove(k.mesh);
world.removeBody(k.body);
kekkaiList.splice(idx,1);
updateHUD();
}

function getClosestKekkai(){
let closest = null;
let minDist = 25;
const pp = playerBody.position;
kekkaiList.forEach(k=>{
const d = pp.distanceTo(k.body.position);
if(d < minDist){
minDist = d;
closest = k;
}
});
return closest;
}

// Enemy system
let enemies = [];
let wave = 1;
let killCount = 0;
const WAVES = [
{name:"静寂",spawn:0.01},
{name:"這い寄る影",spawn:0.015},
{name:"跳梁跋扈",spawn:0.02},
{name:"低空の脅威",spawn:0.025},
{name:"百鬼夜行",spawn:0.03}
];

function spawnEnemy(){
if(enemies.length >= 12) return;

const size = 0.4 + Math.random()*0.6;
const isGiant = Math.random() < 0.08;
const actualSize = isGiant ? size*4 : size;

const geometry = new THREE.IcosahedronGeometry(actualSize,1);
const material = new THREE.MeshStandardMaterial({
color:new THREE.Color().setHSL(Math.random(),0.8,0.5),
emissive:0x220000,
roughness:0.3
});
const mesh = new THREE.Mesh(geometry,material);
mesh.castShadow = true;

const angle = Math.random()*Math.PI*2;
const dist = 20 + Math.random()*15;
mesh.position.set(
Math.sin(angle)*dist,
3,
Math.cos(angle)*dist
);
scene.add(mesh);

const body = new CANNON.Body({
mass:actualSize*5,
shape:new CANNON.Sphere(actualSize),
material:enemyMat,
linearDamping:0.1,
angularDamping:0.3
});
body.position.copy(mesh.position);
world.addBody(body);

const enemy = {mesh,body,size:actualSize,isGiant,nextMove:0};
enemies.push(enemy);

if(isGiant) showStatus("巨大種出現！","#f00");
}

function updateEnemies(dt){
const waveData = WAVES[Math.min(wave-1,WAVES.length-1)];
if(Math.random() < waveData.spawn) spawnEnemy();

const now = Date.now();
const pp = playerBody.position;

enemies.forEach(en=>{
en.mesh.position.copy(en.body.position);
en.mesh.quaternion.copy(en.body.quaternion);

if(en.body.position.y < -20){
destroyEnemy(en);
return;
}

if(now > en.nextMove){
const dx = pp.x - en.body.position.x;
const dy = pp.y - en.body.position.y;
const dz = pp.z - en.body.position.z;
const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) || 0.001;
const force = new CANNON.Vec3(
(dx/dist)*15,
(dy/dist)*8,
(dz/dist)*15
);
en.body.applyForce(force,en.body.position);
en.nextMove = now + 500 + Math.random()*500;
}
});
}

function destroyEnemy(en){
const idx = enemies.indexOf(en);
if(idx === -1) return;
scene.remove(en.mesh);
world.removeBody(en.body);
enemies.splice(idx,1);
killCount++;
spawnParticles(en.mesh.position,0xff6600);
showStatus("撃破！","#ff0");
updateHUD();
checkWaveProgress();
}

function checkWaveProgress(){
const threshold = 5 + wave*3;
if(killCount >= threshold){
wave++;
showStatus("WAVE UP!","#0f0");
updateHUD();
}
}

// Effects
function spawnParticles(pos,color){
for(let i=0;i<20;i++){
const particle = new THREE.Mesh(
new THREE.SphereGeometry(0.08,4,4),
new THREE.MeshBasicMaterial({color})
);
particle.position.copy(pos);
scene.add(particle);

const vel = new THREE.Vector3(
(Math.random()-0.5)*0.4,
Math.random()*0.4,
(Math.random()-0.5)*0.4
);

let life = 30;
const anim = ()=>{
if(life-- <= 0){
scene.remove(particle);
return;
}
particle.position.add(vel);
vel.y -= 0.015;
particle.scale.multiplyScalar(0.95);
requestAnimationFrame(anim);
};
anim();
}
}

function spawn3DText(text,pos,color){
const canvas = document.createElement('canvas');
canvas.width = 256;
canvas.height = 128;
const ctx = canvas.getContext('2d');
ctx.font = 'bold 96px sans-serif';
ctx.fillStyle = color;
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.fillText(text,128,64);

const texture = new THREE.CanvasTexture(canvas);
const sprite = new THREE.Sprite(new THREE.SpriteMaterial({map:texture,transparent:true}));
sprite.position.copy(pos);
sprite.scale.set(3,1.5,1);
scene.add(sprite);

let life = 60;
const anim = ()=>{
if(life-- <= 0){
scene.remove(sprite);
texture.dispose();
return;
}
sprite.position.y += 0.03;
sprite.material.opacity = life/60;
requestAnimationFrame(anim);
};
anim();
}

// Abilities
function executeMetsu(){
const k = getClosestKekkai();
if(!k){
showStatus("対象なし","#888");
return;
}

spawn3DText("滅",k.mesh.position,"#ff3333");
showStatus("滅！","#f00");

let scale = 1;
const shrink = ()=>{
if(!kekkaiList.includes(k)) return;
scale -= 0.04;
k.mesh.scale.setScalar(scale);

const box = new THREE.Box3().setFromObject(k.mesh);
enemies.forEach(en=>{
if(box.containsPoint(en.mesh.position)){
const dir = new CANNON.Vec3(
k.body.position.x - en.body.position.x,
k.body.position.y - en.body.position.y,
k.body.position.z - en.body.position.z
);
dir.normalize();
dir.scale(-30,dir);
en.body.applyImpulse(dir,en.body.position);

const kekkaiSize = Math.min(k.scale.x,k.scale.y,k.scale.z)*scale;
if(kekkaiSize < en.size*1.8){
destroyEnemy(en);
spawnParticles(en.mesh.position,0xffaa00);
}
}
});

if(scale > 0.05){
requestAnimationFrame(shrink);
}else{
removeKekkai(k);
spawnParticles(k.mesh.position,0x00aaff);
}
};
shrink();
}

function executeKai(){
const k = getClosestKekkai();
if(!k){
showStatus("対象なし","#888");
return;
}
spawn3DText("解",k.mesh.position,"#88ff88");
showStatus("解除","#0f0");
removeKekkai(k);
}

// Input
let moveX = 0, moveZ = 0;
let rotY = 0, rotX = 0;
let isMobile = false;

// Joystick
const joystick = document.getElementById('joystick');
const joyStick = document.getElementById('joyStick');
let joyActive = false;

joystick.addEventListener('touchstart',(e)=>{
e.preventDefault();
joyActive = true;
updateJoystick(e.touches[0]);
});

joystick.addEventListener('touchmove',(e)=>{
e.preventDefault();
if(joyActive) updateJoystick(e.touches[0]);
});

joystick.addEventListener('touchend',()=>{
joyActive = false;
joyStick.style.transform = 'translate(-50%,-50%)';
moveX = 0;
moveZ = 0;
});

function updateJoystick(touch){
const rect = joystick.getBoundingClientRect();
const centerX = rect.left + rect.width/2;
const centerY = rect.top + rect.height/2;
let dx = touch.clientX - centerX;
let dy = touch.clientY - centerY;
const dist = Math.sqrt(dx*dx + dy*dy);
const maxDist = 45;

if(dist > maxDist){
dx = dx/dist * maxDist;
dy = dy/dist * maxDist;
}

joyStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
moveX = dx/maxDist;
moveZ = -dy/maxDist;
}

// Look controls
let lastTouchX = 0, lastTouchY = 0;
let lookActive = false;

renderer.domElement.addEventListener('touchstart',(e)=>{
if(e.touches.length === 1 && !joyActive && !isDrawMode){
lookActive = true;
lastTouchX = e.touches[0].clientX;
lastTouchY = e.touches[0].clientY;
}
});

renderer.domElement.addEventListener('touchmove',(e)=>{
if(lookActive && e.touches.length === 1){
const dx = e.touches[0].clientX - lastTouchX;
const dy = e.touches[0].clientY - lastTouchY;
rotY -= dx * 0.003;
rotX -= dy * 0.003;
rotX = Math.max(-Math.PI/2.5, Math.min(Math.PI/2.5, rotX));
lastTouchX = e.touches[0].clientX;
lastTouchY = e.touches[0].clientY;
}
});

renderer.domElement.addEventListener('touchend',()=>{
lookActive = false;
});

// Draw button
const btnDraw = document.getElementById('btnDraw');
let drawStartTime = 0;

btnDraw.addEventListener('touchstart',(e)=>{
e.preventDefault();
e.stopPropagation();
if(kekkaiList.length >= MAX_KEKKAI){
showStatus("結界数上限","#f00");
return;
}
isDrawMode = true;
drawStartTime = Date.now();
btnDraw.classList.add('active');

const dir = new THREE.Vector3(0,0,-1);
dir.applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
const pos = new THREE.Vector3().copy(playerBody.position);
pos.y += 0.6;
pos.add(dir.multiplyScalar(5));
if(pos.y < 1) pos.y = 1;

const geometry = new THREE.BoxGeometry(1,1,1);
const material = new THREE.MeshBasicMaterial({color:0x00ffff,wireframe:true});
drawGhost = new THREE.Mesh(geometry,material);
drawGhost.position.copy(pos);
scene.add(drawGhost);
});

btnDraw.addEventListener('touchmove',(e)=>{
if(!isDrawMode || !drawGhost) return;
e.preventDefault();

const touch = e.touches[0];
const nx = (touch.clientX / window.innerWidth - 0.5) * 4;
const ny = (0.5 - touch.clientY / window.innerHeight) * 4;
const sx = Math.max(0.5, 1 + nx);
const sy = Math.max(0.5, 1 + ny);
drawGhost.scale.set(sx,sy,sx);
});

btnDraw.addEventListener('touchend',(e)=>{
e.preventDefault();
if(isDrawMode && drawGhost){
const finalScale = new THREE.Vector3(
drawGhost.scale.x*2,
drawGhost.scale.y*2,
drawGhost.scale.z*2
);
createKekkai(drawGhost.position.clone(),finalScale);
scene.remove(drawGhost);
drawGhost = null;
showStatus("結界展開","#0af");
}
isDrawMode = false;
btnDraw.classList.remove('active');
});

// Action buttons
document.getElementById('btnMets').addEventListener('touchstart',(e)=>{
e.preventDefault();
e.stopPropagation();
executeMetsu();
});

document.getElementById('btnKai').addEventListener('touchstart',(e)=>{
e.preventDefault();
e.stopPropagation();
executeKai();
});

// VR mode
const vrBtn = document.getElementById('vrBtn');
let isVR = false;

vrBtn.addEventListener('click',async ()=>{
if(!navigator.xr) return;
try{
if(!isVR){
const session = await navigator.xr.requestSession('immersive-vr',{
requiredFeatures:['local-floor']
});
await renderer.xr.setSession(session);
isVR = true;
document.getElementById('mobileUI').style.display = 'none';
showStatus("VR開始","#0f0");
}else{
const session = renderer.xr.getSession();
if(session) await session.end();
isVR = false;
document.getElementById('mobileUI').style.display = 'flex';
showStatus("VR終了","#ff0");
}
}catch(err){
showStatus("VR不可","#f00");
console.error(err);
}
});

// HUD
function updateHUD(){
document.getElementById('wave').textContent = wave;
document.getElementById('waveName').textContent = WAVES[Math.min(wave-1,WAVES.length-1)].name;
document.getElementById('kills').textContent = killCount;
document.getElementById('kekkaiCount').textContent = kekkaiList.length;
}

function showStatus(text,color){
const el = document.getElementById('status');
el.textContent = text;
el.style.color = color;
setTimeout(()=>{
el.textContent = "戦闘中";
el.style.color = "#0af";
},1200);
}

// Game loop
const clock = new THREE.Clock();

function animate(){
const dt = Math.min(clock.getDelta(), 0.05);
world.step(1/60, dt, 3);

// Player movement
const speed = 10;
const forward = new THREE.Vector3(0,0,-1);
forward.applyQuaternion(new THREE.Quaternion().setFromEuler(new THREE.Euler(0,rotY,0)));
const right = new THREE.Vector3(1,0,0);
right.applyQuaternion(new THREE.Quaternion().setFromEuler(new THREE.Euler(0,rotY,0)));

playerBody.velocity.x = (right.x*moveX + forward.x*moveZ)*speed;
playerBody.velocity.z = (right.z*moveX + forward.z*moveZ)*speed;

playerGroup.position.copy(playerBody.position);
playerGroup.rotation.y = rotY;
camera.rotation.x = rotX;

updateEnemies(dt);

kekkaiList.forEach(k=>{
k.mesh.position.copy(k.body.position);
k.mesh.quaternion.copy(k.body.quaternion);
});

renderer.render(scene,camera);
}

// Start
document.getElementById('startBtn').addEventListener('click',()=>{
document.getElementById('startScreen').style.display = 'none';
document.getElementById('mobileUI').style.display = 'flex';
document.getElementById('vrBtn').style.display = 'block';
isMobile = true;
renderer.setAnimationLoop(animate);
updateHUD();
showStatus("任務開始","#0f0");

// Spawn initial enemies
for(let i=0;i<3;i++) spawnEnemy();
});

// Resize
window.addEventListener('resize',()=>{
camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();
renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
