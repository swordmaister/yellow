<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>結界師VR - 妖滅シミュレーター (Fixed)</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover">
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/VRButton.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/XRControllerModelFactory.js"></script>

<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:"Sawarabi Mincho", serif; overflow:hidden;}
  canvas{display:block}
  #hud {
    position: fixed; left: 20px; top: 20px;
    background: rgba(0,20,40,0.6); border: 1px solid #4af;
    padding:15px; border-radius:4px; font-size:16px; width:280px; pointer-events:none; z-index:10;
    box-shadow: 0 0 15px rgba(0,100,255,0.3);
    text-shadow: 0 0 5px #0ff;
  }
  #hud div{margin:8px 0;}
  .label { color: #8cf; font-size:12px; }
  .val { font-weight:bold; font-size:18px; color:#fff; }
  #tips {
    position: fixed; left:20px; bottom:20px;
    color: #4af; font-size:14px; opacity:0.8; pointer-events:none;
    background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 4px;
  }
  /* 漢字エフェクト用のフォント指定 */
  @import url('https://fonts.googleapis.com/css2?family=Sawarabi+Mincho&display=swap');
</style>
</head>
<body>

<div id="hud">
  <div style="border-bottom:1px solid #4af; padding-bottom:5px; margin-bottom:10px;">
    <strong>烏森守備隊 HUD (v2.0)</strong>
  </div>
  <div><span class="label">展開数:</span> <span id="kCount" class="val">0</span> / <span id="kLimit" class="val">5</span></div>
  <div><span class="label">適合率(感度):</span> <span id="sensitivity" class="val">1.0</span>x</div>
  <div><span class="label">状態:</span> <span id="statusText" style="color:#f0a;">索敵中...</span></div>
</div>
<div id="tips">トリガー:指定/生成 | グリップ:結(固定) | A長押し:滅 | B:解</div>

<script>
/* -------------------------------------------------------
  結界師VR: Fixed & Enhanced Version
  - XR座標取得バグ修正 (World Coordinates)
  - マテリアル修正 (Emissive Support)
  - 視認性向上
--------------------------------------------------------*/

// --- 初期設定 ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x020205);
scene.fog = new THREE.FogExp2(0x020205, 0.025);

const camera = new THREE.PerspectiveCamera(70, innerWidth / innerHeight, 0.01, 100);
camera.position.set(0, 1.6, 2);

const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;
// 輝き表現のためのトーンマッピング
renderer.toneMapping = THREE.ReinhardToneMapping;
renderer.toneMappingExposure = 1.5;
document.body.appendChild(renderer.domElement);
document.body.appendChild(VRButton.createButton(renderer));

window.addEventListener('resize', ()=> {
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// --- ライティング ---
const hemi = new THREE.HemisphereLight(0x4444ff, 0x000000, 0.4); 
scene.add(hemi);
const dir = new THREE.DirectionalLight(0xaaccff, 1.0); 
dir.position.set(5,10,5); 
scene.add(dir);

// --- ステージ（夜の校庭イメージ） ---
const floorGeo = new THREE.PlaneGeometry(40,40);
const floorMat = new THREE.MeshStandardMaterial({
  color:0x050510, roughness:0.8, metalness:0.2, 
  emissive:0x000011
});
const floor = new THREE.Mesh(floorGeo, floorMat);
floor.rotation.x = -Math.PI/2;
scene.add(floor);

// グリッドヘルパー（視認性向上修正：少し明るく）
const grid = new THREE.GridHelper(40, 40, 0x334455, 0x112233);
scene.add(grid);

// --- 音声合成 (言霊) ---
const synth = window.speechSynthesis;
function speak(text, pitch=1.0, rate=1.2) {
  if(!synth) return;
  try {
    const u = new SpeechSynthesisUtterance(text);
    u.lang = 'ja-JP';
    u.rate = rate; u.pitch = pitch; u.volume = 0.8;
    synth.speak(u);
  } catch(e) {
    // Questブラウザ等でブロックされた場合は無視
    console.warn("Speech API error or blocked");
  }
}

// --- 漢字・エフェクト生成 ---
function createKanjiTexture(text, colorStr) {
  const cvs = document.createElement('canvas');
  cvs.width = 256; cvs.height = 256;
  const ctx = cvs.getContext('2d');
  ctx.font = "bold 180px 'Sawarabi Mincho', serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.shadowColor = colorStr;
  ctx.shadowBlur = 15;
  ctx.fillStyle = colorStr;
  ctx.fillText(text, 128, 128);
  const tex = new THREE.CanvasTexture(cvs);
  return tex;
}

function spawnKanji(text, pos, color="#4af", scale=1.0) {
  const mat = new THREE.SpriteMaterial({
    map: createKanjiTexture(text, color), 
    transparent:true, opacity:1, depthTest:false
  });
  const sprite = new THREE.Sprite(mat);
  sprite.position.copy(pos);
  sprite.scale.set(0,0,0); // start small
  scene.add(sprite);
  
  // Animation
  let t = 0;
  function anim() {
    t += 0.05;
    const s = Math.min(1, t*2) * scale;
    sprite.scale.set(s,s,s);
    sprite.material.opacity = Math.max(0, 1 - (t-0.5)*1.5);
    sprite.position.y += 0.005;
    if(t < 1.5) {
      requestAnimationFrame(anim);
    } else {
      scene.remove(sprite);
      mat.map.dispose();
      mat.dispose();
    }
  }
  anim();
}

// --- 結界システム ---
let kekkaiList = [];
const KEKKAI_LIMIT = 5;
let isDrawing = false;
let ghost = null; // プレビュー用
let drawStart = new THREE.Vector3();
let sensitivity = 1.0;

// マテリアル定義
// 結界内部（半透明）
const barrierBodyMat = new THREE.MeshPhongMaterial({
  color: 0x0088ff, transparent: true, opacity: 0.15, 
  side: THREE.DoubleSide, shininess: 100, emissive: 0x002244
});
// 結界枠線（発光感）
const barrierLineMat = new THREE.LineBasicMaterial({ color: 0x88ccff, linewidth: 2 });

// --- コントローラー ---
let controller = renderer.xr.getController(0);
scene.add(controller);
// 視線ガイド（レーザー）
const laserGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-5)]);
const laser = new THREE.Line(laserGeo, new THREE.LineBasicMaterial({color: 0x224466, transparent:true, opacity:0.3}));
controller.add(laser);

const controllerGrip = renderer.xr.getControllerGrip(0);
const modelFactory = new THREE.XRControllerModelFactory();
controllerGrip.add(modelFactory.createControllerModel(controllerGrip));
scene.add(controllerGrip);

// --- 入力イベント処理 ---

// 1. トリガー: 「芳意（ターゲット指定）」〜「定礎（位置決め）」
controller.addEventListener('selectstart', () => {
  if (kekkaiList.length >= KEKKAI_LIMIT) {
    pulseHUD("結界、展開限界！", "#f44");
    return;
  }
  isDrawing = true;
  // ★重要修正: ワールド座標を取得
  const p = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);
  drawStart.copy(p);
  
  // ゴースト生成
  const geo = new THREE.BoxGeometry(1,1,1);
  ghost = new THREE.Mesh(geo, barrierBodyMat.clone());
  ghost.material.opacity = 0.3;
  // ワイヤーフレーム追加
  const edges = new THREE.EdgesGeometry(geo);
  const line = new THREE.LineSegments(edges, barrierLineMat);
  ghost.add(line);
  
  ghost.position.copy(p);
  ghost.scale.set(0.1, 0.1, 0.1);
  ghost.userData.start = p.clone();
  scene.add(ghost);

  hapticPulse(0.1, 20); // 軽い振動
});

controller.addEventListener('selectend', () => {
  if(isDrawing) finalizeGhost(); // トリガー離したら即「結」する場合
  isDrawing = false;
});

// 2. グリップ: 「結（固定）」
// 結界師らしく「掴んで止める」アクションで固定
controller.addEventListener('squeezestart', () => {
  if (ghost) {
    finalizeGhost(); 
  }
});

// --- ロジック関数 ---

function updateGhost() {
  if (!isDrawing || !ghost) return;
  // ★重要修正: ワールド座標を取得
  const p = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);
  const start = ghost.userData.start;
  // 始点と現在点から中心とサイズを計算
  const center = new THREE.Vector3().addVectors(start, p).multiplyScalar(0.5);
  const size = new THREE.Vector3().subVectors(p, start);
  
  // サイズ計算（絶対値）+ 感度
  size.x = Math.abs(size.x) * sensitivity;
  size.y = Math.abs(size.y) * sensitivity;
  size.z = Math.abs(size.z) * sensitivity;

  // 最小サイズ保証
  size.max(new THREE.Vector3(0.05, 0.05, 0.05));

  ghost.position.copy(center);
  ghost.scale.copy(size);
}

function finalizeGhost() {
  if (!ghost) return;
  
  // 実体化
  const solid = ghost.clone();
  solid.material = barrierBodyMat.clone();
  solid.material.opacity = 0.2;
  
  // ワイヤーフレームもコピーされているが、強さを変える
  solid.children[0].material = new THREE.LineBasicMaterial({ color: 0xaaddff, linewidth: 2 });
  
  solid.userData = { life: 100, type: 'kekkai' };
  scene.add(solid);
  kekkaiList.push(solid);
  
  // 演出
  spawnKanji("結", solid.position, "#0af", 1.5);
  speak("ケツ！", 1.2, 1.5);
  hapticPulse(1.0, 50); // 強い衝撃
  pulseHUD("結界 展開", "#0af");

  // ゴースト削除
  scene.remove(ghost);
  ghost = null;
  isDrawing = false;
  
  document.getElementById('kCount').textContent = kekkaiList.length;
}

// 滅（クラッシュ）アニメーション
function metsKekkai(target) {
  if(!target) return;

  // 敵の巻き込み判定
  enemies.forEach(en => {
    if(intersectsBox(target, en.mesh)) {
      damageEnemy(en, 999); // 即死級ダメージ
    }
  });

  spawnKanji("滅", target.position, "#f24", 2.0);
  speak("メツ！", 0.8, 1.8);
  pulseHUD("滅却完了", "#f24");
  hapticPulse(1.0, 200); // 重い振動

  // 収縮アニメーション
  const startScale = target.scale.clone();
  let t = 0;
  
  // 破片パーティクル生成
  spawnParticles(target.position, target.scale, 0xff2244);

  function loop() {
    t += 0.1;
    const sc = 1.0 - t;
    if(sc > 0) {
      target.scale.copy(startScale).multiplyScalar(sc);
      requestAnimationFrame(loop);
    } else {
      removeKekkai(target);
    }
  }
  loop();
}

// 解（リリース）
function kaiKekkai(target) {
  if(!target) return;
  spawnKanji("解", target.position, "#8fc", 1.0);
  speak("カイ", 1.2, 1.2);
  hapticPulse(0.2, 50);
  removeKekkai(target);
}

function removeKekkai(mesh) {
  if(mesh.parent) mesh.parent.remove(mesh);
  kekkaiList = kekkaiList.filter(x => x !== mesh);
  document.getElementById('kCount').textContent = kekkaiList.length;
}

// パーティクル演出
function spawnParticles(pos, area, colorInt) {
  const geo = new THREE.BufferGeometry();
  const count = 30;
  const posArr = [];
  for(let i=0; i<count*3; i++) {
    posArr.push((Math.random()-0.5)*area.x, (Math.random()-0.5)*area.y, (Math.random()-0.5)*area.z);
  }
  geo.setAttribute('position', new THREE.Float32BufferAttribute(posArr, 3));
  const mat = new THREE.PointsMaterial({color:colorInt, size:0.05, transparent:true});
  const pts = new THREE.Points(geo, mat);
  pts.position.copy(pos);
  scene.add(pts);
  
  let f = 0;
  function anim() {
    f++;
    pts.rotation.y += 0.1;
    pts.scale.multiplyScalar(1.05);
    mat.opacity -= 0.03;
    if(mat.opacity > 0) requestAnimationFrame(anim);
    else {
      scene.remove(pts);
      geo.dispose();
      mat.dispose();
    }
  }
  anim();
}

// --- 敵AI & 判定 ---
let enemies = [];
function spawnEnemy() {
  // 妖っぽい見た目（コア＋オーラ）
  const group = new THREE.Group();
  const core = new THREE.Mesh(
    new THREE.IcosahedronGeometry(0.15, 1), 
    new THREE.MeshStandardMaterial({color:0xff0044, emissive:0xaa0022, roughness:0.2})
  );
  
  // ★重要修正: MeshLambertMaterial -> MeshStandardMaterial
  // Lambertはemissiveを持たないため、光らせる処理が効かなかったバグを修正
  const aura = new THREE.Mesh(
    new THREE.IcosahedronGeometry(0.25, 0),
    new THREE.MeshStandardMaterial({
      color:0x550022, 
      transparent:true, 
      opacity:0.4, 
      wireframe:true,
      emissive: 0x000000 // 初期値は黒（発光なし）
    })
  );
  
  group.add(core); group.add(aura);
  
  // ランダム配置
  group.position.set((Math.random()-0.5)*4, 1.0 + Math.random(), -2 - Math.random()*2);
  scene.add(group);
  
  enemies.push({ mesh: group, hp: 3, time: Math.random()*100 });
}
// 初期敵
spawnEnemy(); spawnEnemy();

function updateEnemies(dt) {
  if(enemies.length < 3 && Math.random() < 0.01) spawnEnemy();

  enemies.forEach(en => {
    en.time += dt;
    en.mesh.position.x += Math.sin(en.time)*0.01;
    en.mesh.position.y += Math.cos(en.time*1.3)*0.01;
    en.mesh.rotation.y += 0.02;
    en.mesh.rotation.z += 0.01;
    
    // 芳意（ターゲット）表示
    const camDir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    const toEn = en.mesh.position.clone().sub(camera.position).normalize();
    const dot = camDir.dot(toEn);
    
    // 視線が合っている(dot > 0.98) なら赤く光らせる＝芳意
    const auraMesh = en.mesh.children[1];
    if(dot > 0.98) {
      // ★修正: StandardMaterialなのでemissiveが効く
      auraMesh.material.emissive.setHex(0xff0000);
      auraMesh.material.opacity = 0.8;
      document.getElementById('statusText').textContent = "芳意：妖確認";
      document.getElementById('statusText').style.color = "#f44";
    } else {
      auraMesh.material.emissive.setHex(0x000000);
      auraMesh.material.opacity = 0.4;
    }
  });
}

function damageEnemy(en, dmg) {
  en.hp -= dmg;
  if(en.hp <= 0) {
    scene.remove(en.mesh);
    enemies = enemies.filter(e => e !== en);
    spawnParticles(en.mesh.position, new THREE.Vector3(1,1,1), 0xaa00ff);
  }
}

function intersectsBox(meshA, meshB) {
  const boxA = new THREE.Box3().setFromObject(meshA);
  const boxB = new THREE.Box3().setFromObject(meshB);
  return boxA.intersectsBox(boxB);
}

// --- コントローラー入力監視 (A/Bボタン) ---
let btnState = { A:false, B:false, A_time:0 };

// ★重要修正: Raycaster用にワールド座標を取得する関数
function pickKekkai() {
  // コントローラーの「ワールド」位置を取得
  const origin = new THREE.Vector3().setFromMatrixPosition(controller.matrixWorld);
  // コントローラーの向きを取得
  const dir = new THREE.Vector3(0,0,-1).applyQuaternion(controller.quaternion);
  
  let ray = new THREE.Ray(origin, dir);
  
  let closest = null; let minD = Infinity;
  kekkaiList.forEach(k => {
    const box = new THREE.Box3().setFromObject(k);
    if(ray.intersectsBox(box)) {
      const d = origin.distanceTo(k.position);
      if(d < minD) { minD = d; closest = k; }
    }
  });
  return closest;
}

function pollGamepad() {
  const session = renderer.xr.getSession();
  if(!session) return;
  
  for(const source of session.inputSources) {
    if(!source.gamepad) continue;
    const gp = source.gamepad;
    // Quest Touch Controller mapping: Button 4 (A/X), Button 5 (B/Y)
    
    // Aボタン（滅）
    if(gp.buttons[4] && gp.buttons[4].pressed) {
      if(!btnState.A) { btnState.A = true; btnState.A_time = performance.now(); }
    } else {
      if(btnState.A) {
        const dur = performance.now() - btnState.A_time;
        btnState.A = false;
        // 長押し判定 (300ms以上)
        if(dur > 300) {
          const target = pickKekkai(); // 修正版のpickKekkaiを使用
          if(target) metsKekkai(target);
          else pulseHUD("対象不在", "#aaa");
        }
      }
    }
    
    // Bボタン（解）
    if(gp.buttons[5] && gp.buttons[5].pressed) {
      if(!btnState.B) {
        btnState.B = true;
        const target = pickKekkai();
        if(target) kaiKekkai(target);
      }
    } else {
      btnState.B = false;
    }
  }
}

// --- ユーティリティ ---
function pulseHUD(text, col="#fff") {
  const el = document.getElementById('statusText');
  el.textContent = text;
  el.style.color = col;
  setTimeout(() => { if(el.textContent === text) el.style.color = "#8cf"; }, 1000);
}

function hapticPulse(intensity, ms) {
  const session = renderer.xr.getSession();
  if(session && session.inputSources[0] && session.inputSources[0].gamepad) {
     const gp = session.inputSources[0].gamepad;
     if(gp.hapticActuators && gp.hapticActuators[0]) {
       gp.hapticActuators[0].pulse(intensity, ms);
     }
  }
}

// --- ループ ---
let lastTime = performance.now();
renderer.setAnimationLoop(() => {
  const now = performance.now();
  const dt = (now - lastTime)/1000; 
  lastTime = now;

  updateGhost();
  pollGamepad();
  updateEnemies(dt);

  renderer.render(scene, camera);
});

</script>
</body>
</html>
