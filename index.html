<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>真・結界師VR - 顕現</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
    body { margin: 0; background-color: #000; overflow: hidden; font-family: 'Sawarabi Mincho', serif; color: white; }
    #overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        background: rgba(0, 5, 10, 0.9); z-index: 10; pointer-events: none;
    }
    h1 { font-size: 40px; text-shadow: 0 0 20px #0af; margin-bottom: 10px; background: linear-gradient(to right, #fff, #0af); -webkit-background-clip: text; color: transparent; }
    p { font-size: 16px; color: #aaa; margin-top: 0; }
    #start-msg { margin-top: 20px; font-size: 20px; color: #0f0; animation: blink 1s infinite; }
    @keyframes blink { 50% { opacity: 0.5; } }
</style>
</head>
<body>

<div id="overlay">
    <h1>真・結界師VR</h1>
    <p>右手トリガー：結界生成（ドラッグ）</p>
    <p>左手グリップ：滅（メツ）</p>
    <p>左スティック：移動 / 右スティック：回転</p>
    <div id="start-msg">画面下の「VR」ボタンを押して起動</div>
</div>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
        "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
import * as CANNON from 'cannon-es';

// --- System Variables ---
let scene, camera, renderer;
let world;
let playerGroup, playerBody;
let controller1, controller2;
let controllerGrip1, controllerGrip2;

// --- Game State ---
let kekkaiList = [];
let enemies = [];
let wave = 1;
let killCount = 0;
const MAX_KEKKAI = 5;

// --- Drawing State ---
let drawing = { active: false, startPos: new THREE.Vector3(), ghost: null };

// --- 3D HUD ---
let hudCanvas, hudCtx, hudTexture, hudMesh;

init();
animate();

function init() {
    // 1. Scene Setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050510);
    scene.fog = new THREE.FogExp2(0x050510, 0.015);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    
    playerGroup = new THREE.Group();
    scene.add(playerGroup);
    playerGroup.add(camera);

    // 2. Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);
    document.body.appendChild(VRButton.createButton(renderer));

    // VR Event Listeners
    renderer.xr.addEventListener('sessionstart', () => {
        document.getElementById('overlay').style.display = 'none';
        playerGroup.position.set(0, 0, 0); // Reset position
        playerBody.position.set(0, 2, 0);
    });

    // 3. Physics
    world = new CANNON.World();
    world.gravity.set(0, -12, 0); // Slightly stronger gravity for feel
    
    // Materials
    const matGround = new CANNON.Material();
    const matPlayer = new CANNON.Material();
    const matEnemy = new CANNON.Material();
    const matKekkai = new CANNON.Material();

    world.addContactMaterial(new CANNON.ContactMaterial(matGround, matPlayer, { friction: 0.1, restitution: 0 }));
    world.addContactMaterial(new CANNON.ContactMaterial(matGround, matEnemy, { friction: 0.5, restitution: 0.2 }));
    world.addContactMaterial(new CANNON.ContactMaterial(matKekkai, matEnemy, { friction: 0.0, restitution: 0.8 })); // Enemies bounce inside

    // Bodies
    const groundBody = new CANNON.Body({ mass: 0, material: matGround });
    groundBody.addShape(new CANNON.Plane());
    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
    world.addBody(groundBody);

    playerBody = new CANNON.Body({ mass: 60, shape: new CANNON.Sphere(0.3), material: matPlayer, fixedRotation: true, linearDamping: 0.9 });
    playerBody.position.set(0, 2, 0);
    world.addBody(playerBody);

    // Visuals
    const grid = new THREE.GridHelper(100, 100, 0x00ffff, 0x222222);
    scene.add(grid);
    const floorMesh = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 }));
    floorMesh.rotation.x = -Math.PI / 2;
    floorMesh.receiveShadow = true;
    scene.add(floorMesh);

    // Lights
    const dirLight = new THREE.DirectionalLight(0xaaccff, 1.5);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    scene.add(dirLight);
    const ambient = new THREE.AmbientLight(0x222244, 0.5);
    scene.add(ambient);

    // 4. Controllers
    setupControllers();

    // 5. HUD
    createHUD();

    // 6. Initial Spawns
    spawnEnemy();
    spawnEnemy();
    
    window.addEventListener('resize', onResize);
}

function setupControllers() {
    // Controller 1 (Right) - Draw Kekkai
    controller1 = renderer.xr.getController(0);
    controller1.addEventListener('selectstart', onDrawStart);
    controller1.addEventListener('selectend', onDrawEnd);
    playerGroup.add(controller1);

    // Controller 2 (Left) - Metsu
    controller2 = renderer.xr.getController(1);
    controller2.addEventListener('squeeze', onMetsu); // Grip button
    controller2.addEventListener('select', onMetsu);  // Trigger backup
    playerGroup.add(controller2);

    // Visual Models
    const factory = new XRControllerModelFactory();
    controllerGrip1 = renderer.xr.getControllerGrip(0);
    controllerGrip1.add(factory.createControllerModel(controllerGrip1));
    playerGroup.add(controllerGrip1);

    controllerGrip2 = renderer.xr.getControllerGrip(1);
    controllerGrip2.add(factory.createControllerModel(controllerGrip2));
    playerGroup.add(controllerGrip2);

    // Guide Line (Right)
    const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-10)]);
    const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3 }));
    controller1.add(line);
}

// --- HUD Logic ---
function createHUD() {
    hudCanvas = document.createElement('canvas');
    hudCanvas.width = 512; hudCanvas.height = 128;
    hudCtx = hudCanvas.getContext('2d');
    hudTexture = new THREE.CanvasTexture(hudCanvas);
    
    const mat = new THREE.MeshBasicMaterial({ map: hudTexture, transparent: true, depthTest: false });
    const geo = new THREE.PlaneGeometry(1, 0.25);
    hudMesh = new THREE.Mesh(geo, mat);
    hudMesh.position.set(0, -0.4, -1.5); // Slightly below eye level
    camera.add(hudMesh); // Attach to camera
    updateHUD("任務開始");
}

function updateHUD(msg = "") {
    if (!hudCtx) return;
    hudCtx.clearRect(0, 0, 512, 128);
    
    // Stats
    hudCtx.font = "bold 30px sans-serif";
    hudCtx.fillStyle = "#0ff";
    hudCtx.fillText(`WAVE: ${wave}  撃破: ${killCount}`, 20, 50);
    
    const kColor = kekkaiList.length >= MAX_KEKKAI ? "#f00" : "#0f0";
    hudCtx.fillText(`結界: ${kekkaiList.length}/${MAX_KEKKAI}`, 20, 90);

    // Message
    if (msg) {
        hudCtx.font = "bold 40px serif";
        hudCtx.fillStyle = "#fff";
        hudCtx.shadowColor = "#f0a";
        hudCtx.shadowBlur = 10;
        hudCtx.textAlign = "right";
        hudCtx.fillText(msg, 490, 70);
        hudCtx.textAlign = "left";
        hudCtx.shadowBlur = 0;
        
        if (msg !== "") setTimeout(() => updateHUD(""), 2000);
    }
    hudTexture.needsUpdate = true;
}

// --- Gameplay Logic ---

// Drawing Kekkai (Right Hand)
function onDrawStart() {
    if (kekkaiList.length >= MAX_KEKKAI) {
        updateHUD("結界上限！");
        return;
    }
    drawing.active = true;
    drawing.startPos.setFromMatrixPosition(controller1.matrixWorld);

    // Create Ghost
    const geo = new THREE.BoxGeometry(1, 1, 1);
    const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, opacity: 0.5, transparent: true });
    drawing.ghost = new THREE.Mesh(geo, mat);
    scene.add(drawing.ghost);
}

function onDrawEnd() {
    if (drawing.active && drawing.ghost) {
        const size = drawing.ghost.scale.clone();
        const pos = drawing.ghost.position.clone();
        
        // Remove ghost
        scene.remove(drawing.ghost);
        drawing.ghost = null;

        // Create Real Kekkai if big enough
        if (size.length() > 0.3) {
            createKekkai(pos, size);
        }
    }
    drawing.active = false;
}

function updateDrawing() {
    if (drawing.active && drawing.ghost) {
        const currentPos = new THREE.Vector3().setFromMatrixPosition(controller1.matrixWorld);
        
        // Calculate center and size based on diagonal drag
        const center = new THREE.Vector3().addVectors(drawing.startPos, currentPos).multiplyScalar(0.5);
        const size = new THREE.Vector3().subVectors(currentPos, drawing.startPos);
        
        // Ensure positive size
        size.x = Math.max(Math.abs(size.x), 0.1);
        size.y = Math.max(Math.abs(size.y), 0.1);
        size.z = Math.max(Math.abs(size.z), 0.1);

        drawing.ghost.position.copy(center);
        drawing.ghost.scale.copy(size);
    }
}

function createKekkai(pos, size) {
    // Visual
    const mesh = new THREE.Mesh(
        new THREE.BoxGeometry(size.x, size.y, size.z),
        new THREE.MeshPhongMaterial({ color: 0x0088ff, transparent: true, opacity: 0.2, side: THREE.DoubleSide, emissive: 0x001133 })
    );
    const edges = new THREE.LineSegments(new THREE.EdgesGeometry(mesh.geometry), new THREE.LineBasicMaterial({ color: 0x00ffff }));
    mesh.add(edges);
    mesh.position.copy(pos);
    scene.add(mesh);

    // Physics (Hollow Box constructed of 6 plates)
    const body = new CANNON.Body({ mass: 0 }); // Static
    const t = 0.1; // thickness
    const h = size.multiplyScalar(0.5);

    // Add shapes for walls
    body.addShape(new CANNON.Box(new CANNON.Vec3(h.x, h.y, t)), new CANNON.Vec3(0, 0, h.z));
    body.addShape(new CANNON.Box(new CANNON.Vec3(h.x, h.y, t)), new CANNON.Vec3(0, 0, -h.z));
    body.addShape(new CANNON.Box(new CANNON.Vec3(t, h.y, h.z)), new CANNON.Vec3(h.x, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(t, h.y, h.z)), new CANNON.Vec3(-h.x, 0, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(h.x, t, h.z)), new CANNON.Vec3(0, h.y, 0));
    body.addShape(new CANNON.Box(new CANNON.Vec3(h.x, t, h.z)), new CANNON.Vec3(0, -h.y, 0));
    
    body.position.copy(pos);
    world.addBody(body);

    const kekkai = { mesh, body, initialSize: size.clone().multiplyScalar(2), id: Date.now(), isShrinking: false };
    kekkaiList.push(kekkai);
    
    spawnKanji("結", pos, "#0af");
    updateHUD();

    // Auto remove
    setTimeout(() => { if (kekkaiList.includes(kekkai) && !kekkai.isShrinking) removeKekkai(kekkai); }, 30000);
}

function removeKekkai(k) {
    scene.remove(k.mesh);
    world.removeBody(k.body);
    kekkaiList = kekkaiList.filter(item => item !== k);
    updateHUD();
}

// Metsu (Left Hand)
function onMetsu() {
    const pPos = playerBody.position;
    let closest = null;
    let minDist = 30.0;

    kekkaiList.forEach(k => {
        if (k.isShrinking) return;
        const dist = pPos.distanceTo(k.body.position);
        if (dist < minDist) {
            minDist = dist;
            closest = k;
        }
    });

    if (closest) {
        updateHUD("滅！！");
        spawnKanji("滅", closest.mesh.position, "#f05");
        closest.isShrinking = true;
        shrinkKekkai(closest);
        
        // Haptic Feedback
        const session = renderer.xr.getSession();
        if (session && session.inputSources[0] && session.inputSources[0].gamepad) {
            session.inputSources[0].gamepad.hapticActuators?.[0]?.pulse(1.0, 200);
        }
    }
}

function shrinkKekkai(k) {
    const startScale = k.mesh.scale.x; // Assumes uniform scaling logic for animation
    let scale = 1.0;
    
    const anim = () => {
        if (!kekkaiList.includes(k)) return;
        scale -= 0.02;

        if (scale <= 0.05) {
            removeKekkai(k);
            spawnParticles(k.mesh.position, 0x00aaff, 10);
            return;
        }

        k.mesh.scale.set(scale, scale, scale);

        // Check Logic: Crush enemies inside
        const box = new THREE.Box3().setFromObject(k.mesh);
        enemies.forEach(en => {
            if (box.containsPoint(en.mesh.position)) {
                // Suck to center
                const dir = k.body.position.vsub(en.body.position);
                dir.normalize();
                dir.scale(20, dir);
                en.body.applyForce(dir, en.body.position);

                // Crush if small enough
                if (scale < 0.5) {
                    destroyEnemy(en);
                    spawnKanji("潰", en.mesh.position, "#fa0");
                }
            }
        });

        requestAnimationFrame(anim);
    };
    anim();
}

// Enemy System
function spawnEnemy() {
    if (enemies.length >= 8 + wave) return;

    const angle = Math.random() * Math.PI * 2;
    const dist = 15 + Math.random() * 15;
    const type = Math.random() > 0.7 ? 'fly' : 'ground';
    const y = type === 'fly' ? 5 + Math.random() * 5 : 2;

    const geo = type === 'fly' ? new THREE.OctahedronGeometry(0.5) : new THREE.IcosahedronGeometry(0.6);
    const color = type === 'fly' ? 0xff4444 : 0xaa2222;
    
    const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: color, roughness: 0.1, emissive: 0x440000 }));
    mesh.position.set(Math.sin(angle) * dist, y, Math.cos(angle) * dist);
    mesh.castShadow = true;
    scene.add(mesh);

    const body = new CANNON.Body({ mass: 5, shape: new CANNON.Sphere(0.5), linearDamping: 0.5 });
    body.position.copy(mesh.position);
    world.addBody(body);

    enemies.push({ mesh, body, type, nextMove: 0 });
}

function updateEnemies() {
    if (Math.random() < 0.01) spawnEnemy();
    const pPos = playerBody.position;

    enemies.forEach(en => {
        en.mesh.position.copy(en.body.position);
        en.mesh.quaternion.copy(en.body.quaternion);

        if (en.body.position.y < -10) { destroyEnemy(en); return; }

        if (Date.now() > en.nextMove) {
            const dir = new CANNON.Vec3(pPos.x - en.body.position.x, pPos.y - en.body.position.y, pPos.z - en.body.position.z);
            dir.normalize();
            
            let force = 15;
            if (en.type === 'ground') dir.y = 0;
            if (en.type === 'fly') { 
                force = 20; 
                en.body.applyForce(new CANNON.Vec3(0, 20, 0), en.body.position); // Anti-gravity
            }

            dir.scale(force, dir);
            en.body.applyForce(dir, en.body.position);
            en.nextMove = Date.now() + 800 + Math.random() * 500;
        }
    });
}

function destroyEnemy(en) {
    scene.remove(en.mesh);
    world.removeBody(en.body);
    enemies = enemies.filter(e => e !== en);
    spawnParticles(en.mesh.position, 0xffaa00, 20);
    killCount++;
    if (killCount % 5 === 0) {
        wave++;
        updateHUD("WAVE UP!");
    } else {
        updateHUD();
    }
}

// Effects
function spawnKanji(text, pos, color) {
    const cvs = document.createElement('canvas'); cvs.width = 128; cvs.height = 128;
    const ctx = cvs.getContext('2d');
    ctx.font = "bold 100px serif"; ctx.fillStyle = color; ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.fillText(text, 64, 64);
    const tex = new THREE.CanvasTexture(cvs);
    const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
    const sp = new THREE.Sprite(mat);
    sp.position.copy(pos); sp.scale.set(2, 2, 2);
    scene.add(sp);
    
    let op = 1.0;
    const anim = () => {
        op -= 0.02; sp.position.y += 0.03; sp.material.opacity = op;
        if (op > 0) requestAnimationFrame(anim);
        else { scene.remove(sp); tex.dispose(); }
    };
    anim();
}

function spawnParticles(pos, color, count) {
    const geo = new THREE.BufferGeometry();
    const posArr = []; const velArr = [];
    for (let i = 0; i < count; i++) {
        posArr.push(pos.x, pos.y, pos.z);
        velArr.push((Math.random() - 0.5), Math.random() + 0.5, (Math.random() - 0.5));
    }
    geo.setAttribute('position', new THREE.Float32BufferAttribute(posArr, 3));
    const pts = new THREE.Points(geo, new THREE.PointsMaterial({ color: color, size: 0.1 }));
    scene.add(pts);

    let life = 40;
    const anim = () => {
        life--;
        const pa = pts.geometry.attributes.position.array;
        for (let i = 0; i < count; i++) {
            pa[i * 3] += velArr[i * 3] * 0.1;
            pa[i * 3 + 1] += velArr[i * 3 + 1] * 0.1;
            pa[i * 3 + 2] += velArr[i * 3 + 2] * 0.1;
        }
        pts.geometry.attributes.position.needsUpdate = true;
        if (life > 0) requestAnimationFrame(anim); else scene.remove(pts);
    };
    anim();
}

// Input Handling
function handleInput() {
    const session = renderer.xr.getSession();
    if (!session) return;

    let mx = 0, mz = 0, rot = 0;

    for (const source of session.inputSources) {
        if (!source.gamepad) continue;
        const gp = source.gamepad;

        // Left Stick: Move
        if (source.handedness === 'left' && gp.axes.length >= 4) {
            mx += gp.axes[2];
            mz += gp.axes[3];
        }
        // Right Stick: Rotate (Snap)
        if (source.handedness === 'right' && gp.axes.length >= 3) {
            if (Math.abs(gp.axes[2]) > 0.5) {
                if (!source.snapLocked) {
                    playerGroup.rotation.y -= Math.sign(gp.axes[2]) * Math.PI / 4;
                    source.snapLocked = true;
                }
            } else {
                source.snapLocked = false;
            }
        }
    }

    // Apply Move
    if (Math.abs(mx) > 0.1 || Math.abs(mz) > 0.1) {
        const speed = 0.1;
        const dir = new THREE.Vector3(mx, 0, mz).applyEuler(new THREE.Euler(0, playerGroup.rotation.y, 0));
        playerGroup.position.add(dir.multiplyScalar(speed));
        playerBody.position.copy(playerGroup.position);
        playerBody.position.y += 2; // Keep physics body upright
    }
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

// Main Loop
function animate() {
    renderer.setAnimationLoop(() => {
        const dt = 1 / 60;
        world.step(dt);
        
        handleInput();
        updateDrawing();
        updateEnemies();
        
        renderer.render(scene, camera);
    });
}
</script>
</body>
</html>
