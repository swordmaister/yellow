<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>真・結界師VR - Meta Quest Edition</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<style>
/* 基本スタイル */
html,body{height:100%;margin:0;padding:0;background:#000;color:#fff;font-family:'Hiragino Kaku Gothic ProN',sans-serif;overflow:hidden;user-select:none;}
canvas{display:block;width:100%;height:100%;}

/* スタート画面（スマホ・PC用） */
#startScreen{position:fixed;top:0;left:0;width:100%;height:100%;background:linear-gradient(180deg,#001133 0%,#000511 100%);z-index:9999;display:flex;align-items:center;justify-content:center;flex-direction:column;pointer-events:auto;}
.title{font-size:48px;font-weight:bold;margin-bottom:10px;text-shadow:0 0 20px #0af;background:linear-gradient(to bottom, #fff, #0af);-webkit-background-clip:text;-webkit-text-fill-color:transparent;}
.subtitle{font-size:20px;color:#aaa;margin-bottom:40px;letter-spacing:4px;}
#startBtn{padding:20px 60px;font-size:24px;font-weight:bold;color:#fff;background:linear-gradient(135deg,#0af,#06a);border-radius:30px;border:2px solid #fff;box-shadow:0 0 30px rgba(0,170,255,0.5);cursor:pointer;transition:transform 0.1s;}
#startBtn:active{transform:scale(0.95);}

/* VRに入れない時用の簡易UI */
#vrOverlay{position:fixed;bottom:20px;width:100%;text-align:center;pointer-events:none;display:none;}
#vrBtn{pointer-events:auto;padding:15px 30px;background:rgba(0,0,0,0.8);border:2px solid #0f0;color:#0f0;font-size:18px;border-radius:10px;cursor:pointer;}

/* インストラクション */
#instructions{margin-top:20px;color:#88aaff;font-size:14px;line-height:1.6;text-align:center;}
</style>
</head>
<body>

<div id="startScreen">
    <div class="title">真・結界師VR</div>
    <div class="subtitle">QUEST EDITION</div>
    <div id="startBtn">任務開始</div>
    <div id="instructions">
        Questブラウザでアクセスしてください。<br>
        右手トリガー長押し＆ドラッグ：結界生成<br>
        左手グリップ：滅（メツ）<br>
        左スティック：移動 / 右スティック：回転
    </div>
</div>

<div id="vrOverlay">
    <button id="vrBtn">VRモード起動</button>
</div>

<!-- ライブラリの読み込み -->
<script type="importmap">
{
    "imports":{
        "three":"https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
        "three/addons/":"https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
        "cannon-es":"https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
import { FontLoader } from 'three/addons/loaders/FontLoader.js';
import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
import * as CANNON from 'cannon-es';

// --- Global Variables ---
let scene, camera, renderer;
let world;
let controller1, controller2;
let controllerGrip1, controllerGrip2;
const raycaster = new THREE.Raycaster();
const tempMatrix = new THREE.Matrix4();

// Game State
let kekkaiList = [];
let enemies = [];
const MAX_KEKKAI = 5;
let wave = 1;
let killCount = 0;
let isVR = false;

// Physics Materials
const groundMat = new CANNON.Material();
const playerMat = new CANNON.Material();
const enemyMat = new CANNON.Material();
const kekkaiMat = new CANNON.Material(); // Slippery for enemies to slide inside

// Player Physics
let playerBody;
const playerGroup = new THREE.Group(); // Contains Camera + Controllers

// Drawing State
let drawingState = {
    active: false,
    startPoint: new THREE.Vector3(),
    currentPoint: new THREE.Vector3(),
    ghostMesh: null
};

// 3D HUD
let hudGroup, hudTextLine1, hudTextLine2;
let font = null;

init();
animate();

function init() {
    // 1. Scene Setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000510);
    scene.fog = new THREE.FogExp2(0x000510, 0.02);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
    playerGroup.add(camera);
    scene.add(playerGroup);

    // 2. Renderer Setup
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // VR Button Logic
    document.getElementById('startBtn').addEventListener('click', async () => {
        document.getElementById('startScreen').style.display = 'none';
        // Check for XR
        if (navigator.xr) {
            try {
                const session = await navigator.xr.requestSession('immersive-vr', {
                    requiredFeatures: ['local-floor', 'bounded-floor']
                });
                renderer.xr.setSession(session);
                document.getElementById('vrOverlay').style.display = 'none';
            } catch (e) {
                console.log("WebXR not supported or cancelled", e);
                document.getElementById('vrOverlay').style.display = 'block';
            }
        }
    });
    
    document.getElementById('vrBtn').addEventListener('click', async () => {
        if(navigator.xr) {
            const session = await navigator.xr.requestSession('immersive-vr', { requiredFeatures: ['local-floor'] });
            renderer.xr.setSession(session);
        }
    });

    // 3. Physics World
    world = new CANNON.World();
    world.gravity.set(0, -9.82, 0);
    world.broadphase = new CANNON.SAPBroadphase(world);

    // Contact Materials
    const groundPhysMat = new CANNON.ContactMaterial(groundMat, playerMat, { friction: 0.0, restitution: 0.0 });
    const enemyPhysMat = new CANNON.ContactMaterial(groundMat, enemyMat, { friction: 0.5, restitution: 0.3 });
    const kekkaiPhysMat = new CANNON.ContactMaterial(kekkaiMat, enemyMat, { friction: 0.0, restitution: 0.8 }); // Bounce inside kekkai
    world.addContactMaterial(groundPhysMat);
    world.addContactMaterial(enemyPhysMat);
    world.addContactMaterial(kekkaiPhysMat);

    // Player Body (Physics representation)
    playerBody = new CANNON.Body({
        mass: 60, // Human weight
        shape: new CANNON.Sphere(0.3),
        material: playerMat,
        fixedRotation: true,
        linearDamping: 0.9 // Stops quickly
    });
    playerBody.position.set(0, 2, 5);
    world.addBody(playerBody);

    // Ground
    const groundBody = new CANNON.Body({ mass: 0, material: groundMat });
    groundBody.addShape(new CANNON.Plane());
    groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
    world.addBody(groundBody);

    const floorMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(200, 200),
        new THREE.MeshStandardMaterial({ 
            color: 0x112233, roughness: 0.8, metalness: 0.2,
            map: createGridTexture()
        })
    );
    floorMesh.rotation.x = -Math.PI/2;
    floorMesh.receiveShadow = true;
    scene.add(floorMesh);

    // Obstacles
    createEnvironment();

    // Lighting
    const hemiLight = new THREE.HemisphereLight(0x606060, 0x202428, 0.5);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xaaccff, 1.5);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    scene.add(dirLight);

    // 4. VR Controllers
    setupControllers();

    // 5. HUD Setup
    loadFontAndCreateHUD();

    // Resize
    window.addEventListener('resize', onWindowResize);
}

function createGridTexture() {
    const cvs = document.createElement('canvas');
    cvs.width = 512; cvs.height = 512;
    const ctx = cvs.getContext('2d');
    ctx.fillStyle = '#112233';
    ctx.fillRect(0,0,512,512);
    ctx.strokeStyle = '#224466';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0,0); ctx.lineTo(512,0);
    ctx.moveTo(0,0); ctx.lineTo(0,512);
    ctx.stroke();
    const tex = new THREE.CanvasTexture(cvs);
    tex.wrapS = THREE.RepeatWrapping;
    tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(50,50);
    return tex;
}

function setupControllers() {
    // --- Controller 1 (Right: Draw Kekkai) ---
    controller1 = renderer.xr.getController(0);
    controller1.addEventListener('selectstart', onRightTriggerStart); // Draw Start
    controller1.addEventListener('selectend', onRightTriggerEnd);     // Draw End
    scene.add(controller1);

    // --- Controller 2 (Left: Metsu / Kai) ---
    controller2 = renderer.xr.getController(1);
    controller2.addEventListener('squeeze', onLeftGripPress); // Metsu
    scene.add(controller2);

    // Models
    const controllerModelFactory = new XRControllerModelFactory();
    controllerGrip1 = renderer.xr.getControllerGrip(0);
    controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
    scene.add(controllerGrip1);

    controllerGrip2 = renderer.xr.getControllerGrip(1);
    const leftModel = controllerModelFactory.createControllerModel(controllerGrip2);
    controllerGrip2.add(leftModel);
    
    // Attach HUD to Left Controller
    hudGroup = new THREE.Group();
    hudGroup.position.set(0, 0.05, 0.1); // Slightly above and in front of hand
    hudGroup.rotation.x = -Math.PI / 4;
    controllerGrip2.add(hudGroup);
    
    scene.add(controllerGrip2);

    // Laser Lines
    const geometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-5)]);
    const line = new THREE.Line(geometry);
    line.name = 'line';
    line.scale.z = 1;
    controller1.add(line.clone());
    // Left controller doesn't need a pointer line for this game
}

function loadFontAndCreateHUD() {
    const loader = new FontLoader();
    // Load a default font for 3D text
    loader.load('https://threejs.org/examples/fonts/helvetiker_bold.typeface.json', (loadedFont) => {
        font = loadedFont;
        update3DHUD();
    });
}

function update3DHUD() {
    if(!font || !hudGroup) return;
    
    // Clear old
    while(hudGroup.children.length > 0){ 
        hudGroup.remove(hudGroup.children[0]); 
    }

    const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
    
    // Line 1: WAVE & Kills
    const geo1 = new TextGeometry(`WAVE: ${wave}  撃破: ${killCount}`, {
        font: font, size: 0.02, height: 0.001
    });
    const mesh1 = new THREE.Mesh(geo1, mat);
    mesh1.position.set(-0.1, 0.03, 0);
    hudGroup.add(mesh1);

    // Line 2: Kekkai
    const color2 = kekkaiList.length >= MAX_KEKKAI ? 0xff0000 : 0x00ff00;
    const geo2 = new TextGeometry(`結界: ${kekkaiList.length}/${MAX_KEKKAI}`, {
        font: font, size: 0.02, height: 0.001
    });
    const mesh2 = new THREE.Mesh(geo2, new THREE.MeshBasicMaterial({color: color2}));
    mesh2.position.set(-0.1, 0, 0);
    hudGroup.add(mesh2);
}

// --- Interaction Logic ---

// 右手トリガー：結界生成開始
function onRightTriggerStart() {
    if(kekkaiList.length >= MAX_KEKKAI) {
        pulseController(controller1, 1.0, 50); // Error buzz
        return;
    }

    drawingState.active = true;
    pulseController(controller1, 0.5, 20);

    // Get position in front of controller
    const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(controller1.quaternion);
    const pos = new THREE.Vector3().copy(controller1.position).add(direction.multiplyScalar(2.0)); // 2m先
    
    // Raycast to floor to see if we are pointing at ground
    tempMatrix.identity().extractRotation(controller1.matrixWorld);
    raycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
    
    // Simple ground intersection (y=0 plane roughly)
    const t = -raycaster.ray.origin.y / raycaster.ray.direction.y;
    if(t > 0 && t < 20) {
        // If hitting ground, start there
        drawingState.startPoint.copy(raycaster.ray.at(t, new THREE.Vector3()));
    } else {
        // Floating start
        drawingState.startPoint.copy(pos);
    }

    // Ghost mesh
    const geo = new THREE.BoxGeometry(1,1,1);
    const mat = new THREE.MeshBasicMaterial({ color: 0x00aaff, wireframe: true, transparent: true, opacity: 0.5 });
    drawingState.ghostMesh = new THREE.Mesh(geo, mat);
    scene.add(drawingState.ghostMesh);
}

// 右手トリガー離す：結界確定
function onRightTriggerEnd() {
    if(drawingState.active && drawingState.ghostMesh) {
        createKekkaiFromGhost();
        pulseController(controller1, 1.0, 50);
    }
    drawingState.active = false;
    if(drawingState.ghostMesh) {
        scene.remove(drawingState.ghostMesh);
        drawingState.ghostMesh = null;
    }
}

function updateDrawing() {
    if(!drawingState.active || !drawingState.ghostMesh) return;

    // 現在のコントローラーの指す先
    tempMatrix.identity().extractRotation(controller1.matrixWorld);
    raycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

    // Calculate endpoint based on drag
    // 簡易的に、始点と同じY平面上の交点、または空中の距離
    // より直感的にするため、コントローラーの移動量(Delta)をスケーリングして加算する方式がVRでは扱いやすい
    // ここでは「始点」から「現在のポインタ位置」までのボックスを作る
    
    // Determine End Point
    const t = -raycaster.ray.origin.y / raycaster.ray.direction.y;
    let endPoint = new THREE.Vector3();
    
    if(t > 0 && t < 30) {
         endPoint.copy(raycaster.ray.at(t, new THREE.Vector3()));
         // 最小の高さを確保
         endPoint.y = Math.max(endPoint.y, drawingState.startPoint.y + 0.1); 
    } else {
        // 空中ドラッグ
        const dist = drawingState.startPoint.distanceTo(controller1.position) + 3;
        endPoint.copy(raycaster.ray.at(dist, new THREE.Vector3()));
    }

    // Calculate Box Center and Size
    const min = new THREE.Vector3().minVectors(drawingState.startPoint, endPoint);
    const max = new THREE.Vector3().maxVectors(drawingState.startPoint, endPoint);
    
    // 最低サイズ保証
    if(max.x - min.x < 0.5) max.x = min.x + 0.5;
    if(max.y - min.y < 0.5) max.y = min.y + 0.5;
    if(max.z - min.z < 0.5) max.z = min.z + 0.5;

    const size = new THREE.Vector3().subVectors(max, min);
    const center = new THREE.Vector3().addVectors(min, max).multiplyScalar(0.5);

    drawingState.ghostMesh.position.copy(center);
    drawingState.ghostMesh.scale.copy(size);
}

function createKekkaiFromGhost() {
    const mesh = drawingState.ghostMesh;
    const size = mesh.scale.clone();
    const pos = mesh.position.clone();
    
    createKekkai(pos, size);
}

// 左手グリップ：滅（最も近い結界を破壊して攻撃）
function onLeftGripPress() {
    const pPos = playerBody.position;
    let closest = null;
    let minDist = 100;

    kekkaiList.forEach(k => {
        const d = pPos.distanceTo(k.body.position);
        if(d < minDist) {
            minDist = d;
            closest = k;
        }
    });

    if(closest && minDist < 30) {
        pulseController(controller2, 1.0, 100); // Heavy rumble
        executeMetsu(closest);
    } else {
        // 空振り
        pulseController(controller2, 0.2, 50);
    }
}

// --- Core Game Logic ---

function createKekkai(pos, scale) {
    // Visual
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshPhysicalMaterial({
        color: 0x00aaff,
        transparent: true, opacity: 0.3,
        metalness: 0.9, roughness: 0.1,
        emissive: 0x0044aa, emissiveIntensity: 0.5,
        side: THREE.DoubleSide
    });
    const mesh = new THREE.Mesh(geometry, material);
    mesh.position.copy(pos);
    mesh.scale.copy(scale);
    scene.add(mesh);

    // Glowing Edges
    const edges = new THREE.LineSegments(
        new THREE.EdgesGeometry(geometry),
        new THREE.LineBasicMaterial({ color: 0xaaffff, linewidth: 2 })
    );
    mesh.add(edges);

    // Physics (Hollow Box constructed of 6 plates for enemies to be trapped inside)
    const body = new CANNON.Body({ mass: 0, material: kekkaiMat });
    body.position.copy(pos);
    
    const sx = scale.x/2, sy = scale.y/2, sz = scale.z/2;
    const t = 0.1; // thickness

    // Walls (Inside facing)
    body.addShape(new CANNON.Box(new CANNON.Vec3(sx, sy, t)), new CANNON.Vec3(0, 0, sz)); // Z+
    body.addShape(new CANNON.Box(new CANNON.Vec3(sx, sy, t)), new CANNON.Vec3(0, 0, -sz)); // Z-
    body.addShape(new CANNON.Box(new CANNON.Vec3(t, sy, sz)), new CANNON.Vec3(sx, 0, 0)); // X+
    body.addShape(new CANNON.Box(new CANNON.Vec3(t, sy, sz)), new CANNON.Vec3(-sx, 0, 0)); // X-
    body.addShape(new CANNON.Box(new CANNON.Vec3(sx, t, sz)), new CANNON.Vec3(0, sy, 0)); // Top
    body.addShape(new CANNON.Box(new CANNON.Vec3(sx, t, sz)), new CANNON.Vec3(0, -sy, 0)); // Bottom

    world.addBody(body);

    const kekkai = { mesh, body, scale, id: Date.now() };
    kekkaiList.push(kekkai);
    update3DHUD();

    // Sound effect visual placeholder (Flash)
    const light = new THREE.PointLight(0x00ffff, 2, 10);
    light.position.copy(pos);
    scene.add(light);
    setTimeout(()=>scene.remove(light), 200);
}

function executeMetsu(kekkai) {
    // Visual "Metsu" Text
    spawnFloatingText("滅", kekkai.mesh.position, 0xff0000);

    // Shrink animation
    const startScale = kekkai.mesh.scale.clone();
    let progress = 0;

    const interval = setInterval(() => {
        progress += 0.05;
        const s = 1.0 - progress;
        
        if(s <= 0.1) {
            // Finish
            clearInterval(interval);
            
            // Check enemies inside final crush
            const box = new THREE.Box3().setFromObject(kekkai.mesh);
            checkEnemiesInBox(box, true); // Kill
            
            removeKekkai(kekkai);
            spawnParticles(kekkai.mesh.position, 0x00aaff, 30);
        } else {
            // Shrinking
            kekkai.mesh.scale.set(startScale.x*s, startScale.y*s, startScale.z*s);
            // Physics body needs update? Too heavy to rebuild shape every frame.
            // Simplified: Just push enemies towards center
            const center = kekkai.body.position;
            enemies.forEach(en => {
                const dist = en.body.position.distanceTo(center);
                // Check if roughly inside original bounds
                const range = Math.max(startScale.x, startScale.z) * 0.6;
                if(dist < range) {
                    // Force inwards
                    const force = new CANNON.Vec3().copy(center).vsub(en.body.position);
                    force.normalize();
                    force.scale(50, force); // Strong suck
                    en.body.applyForce(force, en.body.position);
                }
            });
        }
    }, 16);
}

function checkEnemiesInBox(box3, kill) {
    for(let i = enemies.length - 1; i >= 0; i--) {
        const en = enemies[i];
        if(box3.containsPoint(en.mesh.position)) {
            if(kill) {
                destroyEnemy(en);
            }
        }
    }
}

function removeKekkai(k) {
    const idx = kekkaiList.indexOf(k);
    if(idx > -1) {
        scene.remove(k.mesh);
        world.removeBody(k.body);
        kekkaiList.splice(idx, 1);
        update3DHUD();
    }
}

function destroyEnemy(en) {
    const idx = enemies.indexOf(en);
    if(idx > -1) {
        scene.remove(en.mesh);
        world.removeBody(en.body);
        enemies.splice(idx, 1);
        
        killCount++;
        spawnParticles(en.mesh.position, 0xffaa00, 20);
        spawnFloatingText("撃破", en.mesh.position, 0xffaa00);
        
        // Vibration
        pulseController(controller1, 0.5, 50);
        pulseController(controller2, 0.5, 50);

        if(killCount % 5 === 0) {
            wave++;
            spawnFloatingText(`WAVE ${wave}`, new THREE.Vector3(0,5,0), 0xffffff);
        }
        update3DHUD();
    }
}

function spawnEnemy() {
    if(enemies.length >= 10 + wave) return;

    const angle = Math.random() * Math.PI * 2;
    const dist = 15 + Math.random() * 10;
    const x = Math.sin(angle) * dist;
    const z = Math.cos(angle) * dist;
    
    const size = 0.5 + Math.random() * 0.3;
    const mesh = new THREE.Mesh(
        new THREE.OctahedronGeometry(size),
        new THREE.MeshStandardMaterial({ color: 0xff3333, roughness: 0.4 })
    );
    mesh.position.set(x, 10, z); // Fall from sky
    mesh.castShadow = true;
    scene.add(mesh);

    const body = new CANNON.Body({
        mass: 10,
        shape: new CANNON.Sphere(size),
        material: enemyMat,
        linearDamping: 0.1
    });
    body.position.copy(mesh.position);
    world.addBody(body);

    enemies.push({ mesh, body, nextMove: 0 });
}

function updateEnemies(dt) {
    const pPos = playerBody.position;
    const now = Date.now();

    // Spawn logic
    if(Math.random() < 0.01 + (wave * 0.002)) spawnEnemy();

    enemies.forEach(en => {
        en.mesh.position.copy(en.body.position);
        en.mesh.quaternion.copy(en.body.quaternion);

        // Move towards player
        if(now > en.nextMove) {
            const dir = new CANNON.Vec3().copy(pPos).vsub(en.body.position);
            dir.y = 0; // Don't fly up/down
            dir.normalize();
            dir.scale(15 + wave, dir); // Speed increases with wave
            en.body.applyForce(dir, en.body.position);
            en.nextMove = now + 500 + Math.random() * 500;
        }

        // Kill if fallen
        if(en.body.position.y < -10) destroyEnemy(en);
    });
}

function spawnParticles(pos, color, count) {
    const geo = new THREE.BufferGeometry();
    const posArray = [];
    const velArray = [];
    
    for(let i=0; i<count; i++){
        posArray.push(pos.x, pos.y, pos.z);
        velArray.push(
            (Math.random()-0.5)*2,
            (Math.random()-0.5)*2 + 2,
            (Math.random()-0.5)*2
        );
    }
    
    geo.setAttribute('position', new THREE.Float32BufferAttribute(posArray, 3));
    const mat = new THREE.PointsMaterial({ color: color, size: 0.1 });
    const pts = new THREE.Points(geo, mat);
    scene.add(pts);

    // Simple animation loop for particles
    let frames = 0;
    const anim = () => {
        frames++;
        const positions = pts.geometry.attributes.position.array;
        for(let i=0; i<count; i++){
            positions[i*3] += velArray[i*3] * 0.05;
            positions[i*3+1] += velArray[i*3+1] * 0.05;
            positions[i*3+2] += velArray[i*3+2] * 0.05;
            velArray[i*3+1] -= 0.1; // gravity
        }
        pts.geometry.attributes.position.needsUpdate = true;
        if(frames < 60) requestAnimationFrame(anim);
        else scene.remove(pts);
    };
    anim();
}

function spawnFloatingText(text, pos, color) {
    if(!font) return;
    const geo = new TextGeometry(text, { font: font, size: 0.5, height: 0.1 });
    geo.center();
    const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: color }));
    mesh.position.copy(pos);
    mesh.position.y += 1;
    mesh.lookAt(camera.position);
    scene.add(mesh);

    let frames = 0;
    const anim = () => {
        frames++;
        mesh.position.y += 0.02;
        mesh.lookAt(camera.position);
        if(frames < 60) requestAnimationFrame(anim);
        else scene.remove(mesh);
    };
    anim();
}

// --- Utils ---
function pulseController(controller, intensity, duration) {
    if(controller && controller.gamepad && controller.gamepad.hapticActuators && controller.gamepad.hapticActuators[0]) {
        controller.gamepad.hapticActuators[0].pulse(intensity, duration);
    }
}

function createEnvironment() {
    // Random pillars
    for(let i=0; i<10; i++) {
        const w = 2 + Math.random()*3;
        const h = 4 + Math.random()*6;
        const d = 2 + Math.random()*3;
        const x = (Math.random()-0.5)*80;
        const z = (Math.random()-0.5)*80;
        if(Math.abs(x)<5 && Math.abs(z)<5) continue; // safe zone

        const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(w,h,d),
            new THREE.MeshStandardMaterial({color: 0x445566})
        );
        mesh.position.set(x, h/2, z);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        scene.add(mesh);

        const body = new CANNON.Body({mass:0, material: groundMat});
        body.addShape(new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)));
        body.position.copy(mesh.position);
        world.addBody(body);
    }
}

function handleVRMovement() {
    const session = renderer.xr.getSession();
    if(!session) return;

    let x = 0, z = 0;
    let turn = 0;

    // inputSources loop
    for(const source of session.inputSources) {
        if(source.gamepad) {
            const data = source.gamepad;
            if(!data.axes) continue;

            // Left Stick (Move)
            if(source.handedness === 'left') {
                if(data.axes.length >= 4) { // standard layout
                    x = data.axes[2];
                    z = data.axes[3];
                }
            }
            // Right Stick (Turn)
            if(source.handedness === 'right') {
                if(data.axes.length >= 4) {
                    turn = data.axes[2];
                }
            }
        }
    }

    // Deadzone
    if(Math.abs(x) < 0.1) x = 0;
    if(Math.abs(z) < 0.1) z = 0;
    if(Math.abs(turn) < 0.1) turn = 0;

    // Rotation
    if(turn !== 0) {
        playerGroup.rotation.y -= turn * 0.05;
    }

    // Movement
    const speed = 5.0;
    const direction = new THREE.Vector3(x, 0, z);
    direction.applyEuler(new THREE.Euler(0, playerGroup.rotation.y, 0));
    
    // Move the group (XR camera wrapper)
    // Note: In real physics games, you'd apply velocity to playerBody, 
    // but here we manually sync group position for simpler VR locomotion
    playerGroup.position.x += direction.x * speed * 0.016;
    playerGroup.position.z += direction.z * speed * 0.016;
    
    // Sync Physics Body to Visual Body
    playerBody.position.x = playerGroup.position.x;
    playerBody.position.z = playerGroup.position.z;
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    renderer.setAnimationLoop(render);
}

function render() {
    const dt = 1/60;
    world.step(dt);

    handleVRMovement();
    updateDrawing(); // Kekkai sizing logic
    updateEnemies(dt);

    renderer.render(scene, camera);
}

</script>
</body>
</html>
