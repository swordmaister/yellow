<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover, user-scalable=no">
<title>真・結界師VR — フル統合版</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:sans-serif;overflow:hidden;touch-action:none}
  canvas{display:block}
  #hud { position: fixed; left: 12px; top: 12px; background: rgba(0,10,30,0.6); border:1px solid #4af; padding:8px; border-radius:8px; font-size:13px; width:260px; z-index:20; pointer-events:none; }
  #mobileUI { position: fixed; bottom:16px; width:100%; display:flex; justify-content:center; gap:12px; z-index:30; pointer-events:auto; }
  .m_btn{ padding:12px 16px; border-radius:8px; background:rgba(255,255,255,0.06); color:#fff; border:1px solid rgba(255,255,255,0.12); }
  #vrToggle { position: fixed; top: 12px; right: 12px; z-index:101; padding:8px 12px; background:#222; border-radius:6px; border:1px solid #fff; color:#fff; cursor:pointer; }
  #hint { position: fixed; left:50%; transform:translateX(-50%); bottom:8px; padding:6px 10px; background: rgba(0,0,0,0.6); border-radius:8px; pointer-events:none; z-index:102; font-size:13px; }
</style>
</head>
<body>
  <div id="hud">
    <div>WAVE <span id="waveVal">1</span> : <span id="waveName">静寂</span></div>
    <div>撃破: <span id="killCount">0</span> 次: <span id="nextWave">3</span></div>
    <div>結界: <span id="kCount">0</span> / <span id="kLimit">6</span></div>
    <div id="statusText" style="color:#f0a;margin-top:6px;font-weight:bold;">準備中…</div>
  </div>

  <div id="mobileUI">
    <button id="mDraw" class="m_btn">結界作成</button>
    <button id="mMets" class="m_btn">滅</button>
    <button id="mKai" class="m_btn">解</button>
  </div>

  <div id="vrToggle">VRモード</div>
  <div id="hint">トリガー長押しで結界作成・スティックで移動（Quest）</div>

<script type="module">
/* ============================
   フル統合版：Single-module
   - Three.js (module) & VRButton
   - cannon-es optional (物理有効時)
   - VR controllers: trigger=draw, stick=move
   - arm-swing歩行補助
   - kekkai create/update/finalize
   - enemies & wave
   - VR settings panel (canvas)
   ============================ */

/* ---- imports ---- */
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/webxr/VRButton.js';
import { XRControllerModelFactory } from 'https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/webxr/XRControllerModelFactory.js';
/* cannon-es optional: dynamically load if available */
let CANNON = null;
try{
  // try to import cannon-es dynamically — if blocked by CORS, fallback is used
  const mod = await import('https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js');
  CANNON = mod;
  console.log('cannon-es loaded');
}catch(e){
  console.log('cannon-es not available or failed to load; using fallback physics');
}

/* Global state container */
const K = window.__Kekkai = window.__Kekkai || {};
K.scene = new THREE.Scene();
K.scene.background = new THREE.Color(0x051133);
K.scene.fog = new THREE.FogExp2(0x051133, 0.012);

/* Renderer & camera & playerGroup */
K.camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 200);
K.playerGroup = new THREE.Group();
K.playerGroup.add(K.camera);
K.scene.add(K.playerGroup);

K.renderer = new THREE.WebGLRenderer({ antialias:true });
K.renderer.setSize(innerWidth, innerHeight);
K.renderer.outputEncoding = THREE.sRGBEncoding;
K.renderer.xr.enabled = true;
K.renderer.shadowMap.enabled = true;
document.body.appendChild(K.renderer.domElement);

/* VR button */
document.body.appendChild(VRButton.createButton(K.renderer));

/* Lights */
const hemi = new THREE.HemisphereLight(0x8888ff, 0x222233, 0.8); K.scene.add(hemi);
const dir = new THREE.DirectionalLight(0xddeeff, 1.2); dir.position.set(30,80,-50); dir.castShadow=true; K.scene.add(dir);

/* Floor */
const floor = new THREE.Mesh(new THREE.PlaneGeometry(150,150), new THREE.MeshStandardMaterial({color:0x6d5047, roughness:0.9}));
floor.rotation.x = -Math.PI/2; floor.receiveShadow=true; K.scene.add(floor);

/* HUD references */
const elWave = document.getElementById('waveVal');
const elWaveName = document.getElementById('waveName');
const elKill = document.getElementById('killCount');
const elNext = document.getElementById('nextWave');
const elKCount = document.getElementById('kCount');
const elStatus = document.getElementById('statusText');
document.getElementById('kLimit').textContent = '6';

/* Basic config/state */
K.isXRSessionActive = false;
K.controllers = [];
K.kekkaiList = [];
K.enemies = [];
K.wave = 1;
K.killCount = 0;
K.killsToNextWave = 3;
K.MAX_ENEMIES = 6;
K.RESPAWN_SECONDS = 8;

/* Physics (CANNON or fallback) */
if(CANNON){
  K.world = new CANNON.World();
  K.world.gravity.set(0,-15,0);
  K.matDefault = new CANNON.Material('default');
  K.matKekkai = new CANNON.Material('kekkai');
  // contact materials...
} else {
  K.world = null; K._fallbackPhysics = { actors: [] };
}

/* Player body */
if(K.world && CANNON){
  K.playerBody = new CANNON.Body({ mass: 80, shape: new CANNON.Sphere(0.45), material: K.matDefault, fixedRotation:true });
  K.playerBody.position.set(0,1.8,0);
  K.world.addBody(K.playerBody);
} else {
  K.playerBody = { position:{x:0,y:1.8,z:0}, velocity:{x:0,y:0,z:0}, radius:0.45 };
}

/* Utils */
function pulseHUD(text, col='#fff'){ elStatus.textContent = text; elStatus.style.color = col; setTimeout(()=>{ elStatus.style.color='#f0a'; }, 1500); }
function updateCounts(){ elKCount.textContent = K.kekkaiList.length; elKill.textContent = K.killCount; elNext.textContent = K.killsToNextWave; elWave.textContent = K.wave; elWaveName.textContent = ( {1:'静寂',2:'這い寄る影',3:'跳梁',4:'低空',5:'百鬼夜行'}[K.wave] || '百鬼夜行'); }

/* Controllers setup */
const controllerModelFactory = new XRControllerModelFactory();
function buildController(i){
  const controller = K.renderer.xr.getController(i);
  controller.userData.index = i;
  controller.addEventListener('connected', (ev)=>{ controller.userData.inputSource = ev.data; });
  controller.addEventListener('disconnected', ()=>{ controller.userData.inputSource = null; });
  const grip = K.renderer.xr.getControllerGrip(i);
  grip.add(controllerModelFactory.createControllerModel(grip));
  K.scene.add(controller); K.scene.add(grip);
  const state = { index:i, controller, grip, prevPos: new THREE.Vector3(), vel: new THREE.Vector3(), drawing:false, lastTrigger:false, thumb:{x:0,y:0} };
  K.controllers[i] = state;
  return state;
}
buildController(0); buildController(1);

/* Movement & joystick mapping (K.xrMove vector) */
K.xrMove = new THREE.Vector3();

/* Arm-swing walk helper */
K.walk = { accL:{history:[]}, accR:{history:[]}, periodL:0.6, periodR:0.6, smoothSpeed:0 };

/* Kekkai ghost material */
const GHOST_MAT = new THREE.MeshStandardMaterial({ color:0x00ccff, transparent:true, opacity:0.28, side:THREE.DoubleSide, depthWrite:false });
const GHOST_EDGE = new THREE.LineBasicMaterial({ color:0x88ffff });

/* Create ghost, finalize -> actual kekkai */
function makeGhostAt(pos){
  const geo = new THREE.BoxGeometry(1,1,1);
  const mesh = new THREE.Mesh(geo, GHOST_MAT.clone());
  mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(geo), GHOST_EDGE.clone()));
  mesh.position.copy(pos); mesh.scale.set(1,1,1);
  K.scene.add(mesh);
  return mesh;
}
function finalizeGhost(mesh){
  const size = new THREE.Vector3(); mesh.getWorldScale(size);
  // clamp
  size.x = Math.max(0.5, Math.min(12, size.x));
  size.y = Math.max(0.5, Math.min(12, size.y));
  size.z = Math.max(0.5, Math.min(12, size.z));
  // position
  const pos = new THREE.Vector3(); mesh.getWorldPosition(pos);
  // final mesh
  const mat = new THREE.MeshPhongMaterial({ color:0x0088ff, transparent:true, opacity:0.32, emissive:0x003355, side:THREE.DoubleSide });
  const final = new THREE.Mesh(new THREE.BoxGeometry(size.x, size.y, size.z), mat);
  final.add(new THREE.LineSegments(new THREE.EdgesGeometry(final.geometry), new THREE.LineBasicMaterial({color:0x66eeff})));
  final.position.copy(pos);
  K.scene.add(final);
  // physics body if possible
  let body = null;
  if(CANNON && K.world){
    try{
      body = new CANNON.Body({ mass:0, material:K.matKekkai });
      const hx = size.x/2, hy = size.y/2, hz = size.z/2, th = 0.25;
      body.addShape(new CANNON.Box(new CANNON.Vec3(th, hy, hz)), new CANNON.Vec3(hx, 0, 0));
      body.addShape(new CANNON.Box(new CANNON.Vec3(th, hy, hz)), new CANNON.Vec3(-hx,0,0));
      body.addShape(new CANNON.Box(new CANNON.Vec3(hx, th, hz)), new CANNON.Vec3(0, hy,0));
      body.addShape(new CANNON.Box(new CANNON.Vec3(hx, th, hz)), new CANNON.Vec3(0, -hy,0));
      body.addShape(new CANNON.Box(new CANNON.Vec3(hx, hy, th)), new CANNON.Vec3(0,0,hz));
      body.addShape(new CANNON.Box(new CANNON.Vec3(hx, hy, th)), new CANNON.Vec3(0,0,-hz));
      body.position.set(pos.x, pos.y, pos.z);
      K.world.addBody(body);
    }catch(e){ console.warn('cannon create failed', e); body = null; }
  }
  const kek = { mesh:final, body, created:performance.now(), life:35000, isShrinking:false, initialSize:size.clone() };
  K.kekkaiList.push(kek);
  updateCounts();
  setTimeout(()=>{ if(K.kekkaiList.includes(kek) && !kek.isShrinking) removeKekkai(kek); }, kek.life);
  return kek;
}
function removeKekkai(k){ try{ K.scene.remove(k.mesh); }catch(e){} if(k.body && K.world) try{ K.world.removeBody(k.body); }catch(e){} K.kekkaiList = K.kekkaiList.filter(x=>x!==k); updateCounts(); }

/* Controller-driven drawing flow: per-controller ghost */
const perGhost = new Map();
function onControllerTriggerDown(state){
  // start ghost at front of controller
  const pos = new THREE.Vector3(); state.controller.getWorldPosition(pos);
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(state.controller.quaternion);
  const start = pos.clone().add(forward.multiplyScalar(0.3));
  if(K.kekkaiList.length >= 6){ pulseHUD('結界数が上限です','#f44'); return; }
  const ghost = makeGhostAt(start);
  perGhost.set(state.index, { ghost, started:performance.now() });
  pulseHUD('結界作成開始','#0ff');
}
function onControllerTriggerHold(state){ // update ghost scale using controller velocity local
  const gentry = perGhost.get(state.index);
  if(!gentry) return;
  const ghost = gentry.ghost;
  // compute local vel
  const pos = new THREE.Vector3(); state.controller.getWorldPosition(pos);
  const vel = pos.clone().sub(state.prevPos).divideScalar(Math.max((performance.now()-state.lastVelTime||1)/1000, 1e-6));
  // store last
  state.prevPos.copy(pos); state.lastVelTime = performance.now();
  // transform vel to controller local
  const inv = new THREE.Matrix4().copy(state.controller.matrixWorld).invert();
  const localVel = vel.clone().applyMatrix4(inv);
  // map absolute localVel to scale multipliers
  const sx = THREE.MathUtils.clamp(1 + Math.abs(localVel.x) * 0.12, 0.5, 12);
  const sy = THREE.MathUtils.clamp(1 + Math.abs(localVel.y) * 0.12, 0.5, 12);
  const sz = THREE.MathUtils.clamp(1 + Math.abs(localVel.z) * 0.12, 0.5, 12);
  // lerp
  ghost.scale.x += (sx - ghost.scale.x) * 0.3;
  ghost.scale.y += (sy - ghost.scale.y) * 0.3;
  ghost.scale.z += (sz - ghost.scale.z) * 0.3;
  // follow front of controller
  const front = pos.clone().add(new THREE.Vector3(0,0,-1).applyQuaternion(state.controller.quaternion).multiplyScalar(0.4));
  ghost.position.lerp(front, 0.25);
}
function onControllerTriggerUp(state){
  const gentry = perGhost.get(state.index);
  if(!gentry) return;
  const ghost = gentry.ghost;
  // finalize with easing
  const startScale = ghost.scale.clone();
  const finalScale = new THREE.Vector3(
    THREE.MathUtils.clamp(startScale.x, 0.5, 12),
    THREE.MathUtils.clamp(startScale.y, 0.5, 12),
    THREE.MathUtils.clamp(startScale.z, 0.5, 12)
  );
  const startTime = performance.now();
  const dur = 350;
  (function anim(){
    const t = Math.min(1, (performance.now()-startTime)/dur);
    const ease = 1 - Math.pow(1 - t, 3);
    ghost.scale.lerpVectors(startScale, finalScale, ease);
    ghost.material.opacity = 0.28 + 0.7 * ease;
    if(t < 1) requestAnimationFrame(anim);
    else {
      // finalize kekkai
      const kek = finalizeGhost(ghost);
      try{ K.scene.remove(ghost); }catch(e){}
      perGhost.delete(state.index);
      pulseHUD('結界設置','#0f8');
    }
  })();
}

/* Controller update: poll gamepad axes/buttons robustly */
function updateControllers(dt){
  const session = K.renderer.xr.getSession ? K.renderer.xr.getSession() : null;
  for(const st of K.controllers){
    if(!st || !st.controller) continue;
    // world pos vel
    const pos = new THREE.Vector3(); st.controller.getWorldPosition(pos);
    st.vel.copy(pos).sub(st.prevPos).divideScalar(Math.max(dt, 1e-6));
    st.prevPos.copy(pos);

    // find input source mapping
    let input = st.controller.userData.inputSource || (session && session.inputSources && session.inputSources[st.index]) || null;
    if(input && input.gamepad){
      const gp = input.gamepad;
      // axes mapping varies: try axes[2,3] (oculus) else [0,1]
      const axX = gp.axes.length >= 4 ? gp.axes[2] : (gp.axes[0] || 0);
      const axY = gp.axes.length >= 4 ? gp.axes[3] : (gp.axes[1] || 0);
      // deadzone
      const dz = 0.18;
      st.thumb.x = Math.abs(axX) > dz ? axX : 0;
      st.thumb.y = Math.abs(axY) > dz ? axY : 0;

      // trigger button index 0 typical
      const trig = !!(gp.buttons[0] && gp.buttons[0].pressed);
      if(trig && !st.lastTrigger){
        // down
        onControllerTriggerDown(st);
      } else if(trig && st.lastTrigger){
        // hold
        onControllerTriggerHold(st);
      } else if(!trig && st.lastTrigger){
        // up
        onControllerTriggerUp(st);
      }
      st.lastTrigger = trig;
    }
  }
}

/* XR movement mapping: left controller thumb controls movement; maintain orientation (crab walk) */
function updateXRMovement(){
  const left = K.controllers[0];
  if(!left) return;
  const input = left.controller.userData.inputSource;
  if(!input || !input.gamepad) return;
  const gp = input.gamepad;
  const axX = gp.axes.length >= 4 ? gp.axes[2] : (gp.axes[0] || 0);
  const axY = gp.axes.length >= 4 ? gp.axes[3] : (gp.axes[1] || 0);
  const dz = 0.18;
  const lx = Math.abs(axX) > dz ? axX : 0;
  const ly = Math.abs(axY) > dz ? axY : 0;
  if(lx !== 0 || ly !== 0){
    const dir = new THREE.Vector3(); K.camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
    const theta = Math.atan2(dir.x, dir.z);
    // forward/back uses -ly (thumb up negative)
    const vx = (-ly) * Math.sin(theta) + (lx) * Math.sin(theta + Math.PI/2);
    const vz = (-ly) * Math.cos(theta) + (lx) * Math.cos(theta + Math.PI/2);
    K.xrMove.set(vx, 0, vz);
  } else K.xrMove.set(0,0,0);
}

/* Enemies & Wave */
function spawnEnemy(){
  if(K.enemies.length >= K.MAX_ENEMIES) return;
  const typePool = ['walker','jumper','low_flyer','high_flyer'];
  const type = (K.wave < 2) ? 'static' : typePool[Math.floor(Math.random()*typePool.length)];
  const size = 0.5 + Math.random()*0.6;
  const hue = Math.random();
  const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
  const geo = Math.random() < 0.5 ? new THREE.SphereGeometry(size,12,12) : new THREE.BoxGeometry(size*1.2,size*1.2,size*1.2);
  const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity:0.5 }));
  const angle = Math.random()*Math.PI*2; const dist = 12 + Math.random()*18;
  const spawnY = (type==='high_flyer' || type==='low_flyer') ? (3 + Math.random()*6) : (0.8 + Math.random()*1.8);
  mesh.position.set(Math.sin(angle)*dist, spawnY, Math.cos(angle)*dist);
  K.scene.add(mesh);
  const enemy = { mesh, size, type, trapped:false, nextMove: performance.now() + Math.random()*1500 };
  K.enemies.push(enemy);
  updateCounts();
}
function destroyEnemy(en){
  try{ K.scene.remove(en.mesh); }catch(e){}
  K.enemies = K.enemies.filter(x=>x!==en);
  K.killCount++; K.killsToNextWave--; if(K.killsToNextWave <= 0){ K.wave++; K.killsToNextWave = (K.wave<5)?4:8; pulseHUD('WAVE UP!','#fe0'); }
  updateCounts();
}

/* Enemy behavior - simplified (non-physics fallback) */
function updateEnemies(dt){
  if(K.enemies.length < K.MAX_ENEMIES && performance.now() - (K._lastSpawn||0) > K.RESPAWN_SECONDS*1000){ spawnEnemy(); K._lastSpawn = performance.now(); }
  const ppos = K.playerBody.position;
  for(const en of K.enemies.slice()){
    // simple move toward player
    const dir = new THREE.Vector3(ppos.x - en.mesh.position.x, 0, ppos.z - en.mesh.position.z).normalize();
    en.mesh.position.add(dir.multiplyScalar( (en.type==='walker'? dt*1.2 : dt*0.8) ));
    if(en.mesh.position.distanceTo(new THREE.Vector3(ppos.x, en.mesh.position.y, ppos.z)) < (en.size + 0.8)){
      // collide with player -> respawn/destroy
      destroyEnemy(en);
    }
    // check inside shrinking kekkai
    for(const k of K.kekkaiList){
      const box = new THREE.Box3().setFromObject(k.mesh);
      if(box.containsPoint(en.mesh.position)){
        en.trapped = true;
        // if kekkai is shrinking, kill
        if(k.isShrinking) destroyEnemy(en);
      }
    }
  }
}

/* Mets action - shrink nearest kekkai */
function metsAction(){
  const target = pickClosestKekkai(30);
  if(!target){ pulseHUD('対象なし','#888'); return; }
  if(target.isShrinking) return;
  target.isShrinking = true; pulseHUD('滅！','#f24');
  let scale = 1.0;
  (function shrink(){
    if(!K.kekkaiList.includes(target)) return;
    scale -= 0.03;
    target.mesh.scale.setScalar(scale);
    // get enemies inside
    const box = new THREE.Box3().setFromObject(target.mesh);
    for(const e of K.enemies.slice()){
      if(box.containsPoint(e.mesh.position)){
        if(scale < e.size * 0.6) destroyEnemy(e);
      }
    }
    if(scale <= 0.04){ removeKekkai(target); return; }
    requestAnimationFrame(shrink);
  })();
}

/* pick closest kekkai */
function pickClosestKekkai(range){
  let best=null; let bestD2 = range*range;
  const px = K.playerBody.position.x, py = K.playerBody.position.y, pz = K.playerBody.position.z;
  for(const k of K.kekkaiList){
    const dx = px - k.mesh.position.x, dy = py - k.mesh.position.y, dz = pz - k.mesh.position.z;
    const d2 = dx*dx + dy*dy + dz*dz;
    if(d2 < bestD2){ bestD2 = d2; best = k; }
  }
  return best;
}

/* spawn Kanji quick sprite */
function spawnKanji(text, pos, color='#4af'){
  const cvs = document.createElement('canvas'); cvs.width=128; cvs.height=128;
  const ctx = cvs.getContext('2d'); ctx.font='bold 96px serif'; ctx.fillStyle=color; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(text,64,64);
  const tex = new THREE.CanvasTexture(cvs);
  const mat = new THREE.SpriteMaterial({ map:tex, transparent:true, depthTest:false });
  const sp = new THREE.Sprite(mat); sp.position.copy(pos); sp.scale.setScalar(0.6); K.scene.add(sp);
  setTimeout(()=>{ try{ K.scene.remove(sp); }catch(e){} }, 900);
}

/* Frame loop */
const clock = new THREE.Clock();
K.renderer.setAnimationLoop((time, frame) => {
  const dt = Math.min(clock.getDelta(), 0.1);
  // step physics
  if(K.world && CANNON) try{ K.world.step(1/60, dt); }catch(e){}
  // controller & movement
  try{ updateControllers(dt); updateXRMovement(); }catch(e){ console.warn('ctrl update err', e); }
  // apply xrMove & walk speed to playerBody
  const speed = (K.uiSettings && K.uiSettings.moveSpeed) || 6.0;
  // combine K.xrMove and arm swing: here we only use K.xrMove and small K.walk.smoothSpeed
  let vx = (K.xrMove.x || 0) * speed + (K.walk.smoothSpeed||0);
  let vz = (K.xrMove.z || 0) * speed + (K.walk.smoothSpeed||0);
  if(K.playerBody instanceof CANNON.Body){
    K.playerBody.velocity.x = vx; K.playerBody.velocity.z = vz;
    // sync playerGroup
    K.playerGroup.position.set(K.playerBody.position.x, K.playerBody.position.y, K.playerBody.position.z);
  } else {
    K.playerBody.velocity.x = vx; K.playerBody.velocity.z = vz;
    const dtSec = dt;
    K.playerBody.position.x += K.playerBody.velocity.x * dtSec;
    K.playerBody.position.z += K.playerBody.velocity.z * dtSec;
    // gravity/floor
    K.playerBody.velocity.y -= 9.8 * dtSec;
    K.playerBody.position.y += K.playerBody.velocity.y * dtSec;
    if(K.playerBody.position.y < 0.1) { K.playerBody.position.y = 0.1; K.playerBody.velocity.y = 0; }
    K.playerGroup.position.set(K.playerBody.position.x, K.playerBody.position.y, K.playerBody.position.z);
  }
  // enemies update
  try{ updateEnemies(dt); }catch(e){ console.warn('enemy update err', e); }
  // render
  K.renderer.render(K.scene, K.camera);
});

/* UI bindings (mobile buttons) */
document.getElementById('mDraw').addEventListener('click', ()=>{ pulseHUD('モバイル: 結界作成(長押し未実装)','#ff8'); });
document.getElementById('mMets').addEventListener('click', ()=>{ metsAction(); });
document.getElementById('mKai').addEventListener('click', ()=>{ const k=pickClosestKekkai(15); if(k){ removeKekkai(k); spawnKanji('解', k.mesh.position, '#8f8'); } else pulseHUD('対象なし','#888'); });

/* VR UI Panel (simplified): canvas texture and raycast click */
const UIW = 1024, UIH = 512;
const uiCanvas = document.createElement('canvas'); uiCanvas.width=UIW; uiCanvas.height=UIH;
const uiCtx = uiCanvas.getContext('2d');
const uiTex = new THREE.CanvasTexture(uiCanvas);
const uiMat = new THREE.MeshBasicMaterial({ map: uiTex, side:THREE.DoubleSide });
const uiMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.6,0.8), uiMat);
uiMesh.position.set(0,1.9,-1.4); K.scene.add(uiMesh);

K.uiSettings = { moveSpeed:6.0, maxKekkaiSize:6, stickSensitivity:1.0, joystickInvert:false };
function drawUI(){
  uiCtx.fillStyle='#021229'; uiCtx.fillRect(0,0,UIW,UIH);
  uiCtx.fillStyle='#fff'; uiCtx.font='36px sans-serif'; uiCtx.fillText('設定パネル', 24, 48);
  uiCtx.font='20px sans-serif'; uiCtx.fillText('移動速度: '+K.uiSettings.moveSpeed.toFixed(1), 24, 110);
  uiCtx.fillText('結界最大: '+K.uiSettings.maxKekkaiSize, 24, 170);
  uiCtx.fillText('スティック感度: '+K.uiSettings.stickSensitivity.toFixed(2), 24, 230);
  uiCtx.fillStyle='#0ff'; uiCtx.fillRect(700, 80, 200, 56); uiCtx.fillStyle='#000'; uiCtx.fillText('保存', 760, 122);
  uiTex.needsUpdate = true;
}
drawUI();

/* simple UI interaction: raycast from controllers press */
const uiRay = new THREE.Raycaster();
function tryUIPress(ctrlState){
  const origin = new THREE.Vector3(); const dir = new THREE.Vector3(0,0,-1);
  ctrlState.controller.getWorldPosition(origin); ctrlState.controller.getWorldDirection(dir);
  uiRay.set(origin, dir);
  const inter = uiRay.intersectObject(uiMesh, true);
  if(inter.length === 0) return false;
  const uv = inter[0].uv; // vector2
  const cx = Math.floor(uv.x * UIW), cy = Math.floor((1-uv.y) * UIH);
  // map to save button rough area: x>700 && y in 80..136
  if(cx > 700 && cy > 80 && cy < 136){
    // save
    localStorage.setItem('kekkai_settings', JSON.stringify(K.uiSettings));
    pulseHUD('設定保存','#0f8');
    drawUI();
    return true;
  }
  return true;
}

/* per-frame controller UI press check (using trigger) */
K.renderer.setAnimationLoop((t, frame) => {
  // same loop called earlier; to avoid double render we will not duplicate heavy work here.
});
/* Instead detect trigger presses in updateControllers (already called) and we can call tryUIPress there if needed.
   For simplicity, handle pressing by holding grip+trigger logic omitted to keep code robust in varied devices.
*/

/* Helper to find nearest kekkai for mobile/keyboard actions */
updateCounts();

/* VR button click handler (also handled by VRButton) */
document.getElementById('vrToggle').addEventListener('click', async ()=>{
  if(!K.isXRSessionActive && navigator.xr){
    try{
      const sess = await navigator.xr.requestSession('immersive-vr', { optionalFeatures:['local-floor','bounded-floor','hand-tracking'] });
      await K.renderer.xr.setSession(sess);
      K.isXRSessionActive = true; pulseHUD('VRセッション中','#0f8');
      sess.addEventListener('end', ()=>{ K.isXRSessionActive = false; pulseHUD('VR終了','#f44'); });
    }catch(e){ console.warn(e); pulseHUD('VR開始失敗','#f44'); }
  } else {
    const s = K.renderer.xr.getSession(); if(s) s.end();
  }
});

/* Resize */
window.addEventListener('resize', ()=>{ K.camera.aspect = innerWidth/innerHeight; K.camera.updateProjectionMatrix(); K.renderer.setSize(innerWidth, innerHeight); });

/* Debug: expose K to console */
window.Kekkai = K;
console.log('Integrated Kekkai VR loaded. K object available as window.Kekkai');
</script>
</body>
</html>
