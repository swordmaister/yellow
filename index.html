<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>真・結界師VR - Cross Platform Fix</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
<style>
/* --- 共通設定 --- */
body { margin: 0; padding: 0; background-color: #000; overflow: hidden; font-family: sans-serif; user-select: none; -webkit-user-select: none; }
canvas { display: block; width: 100%; height: 100%; outline: none; }

/* --- UIレイヤー --- */
#ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

/* --- スタート画面 --- */
#start-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,10,20,0.95); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; }
.title { font-size: 40px; color: #00ffff; text-shadow: 0 0 10px #00aaaa; font-weight: bold; margin-bottom: 10px; }
.desc { color: #88aaff; font-size: 14px; margin-bottom: 30px; text-align: center; line-height: 1.5; }
#btn-start { padding: 15px 40px; background: linear-gradient(45deg, #0088ff, #004488); border: 2px solid #fff; color: white; font-size: 20px; border-radius: 30px; cursor: pointer; }

/* --- スマホ用操作UI (VR時は非表示) --- */
#mobile-controls { display: none; width: 100%; height: 100%; pointer-events: none; }
.control-active #mobile-controls { display: block; }

/* ジョイスティック領域 */
#joystick-zone { position: absolute; bottom: 50px; left: 50px; width: 120px; height: 120px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3); pointer-events: auto; touch-action: none; }
#joystick-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: rgba(0,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 15px #00ffff; pointer-events: none; }

/* ボタン類 */
.action-btn { position: absolute; width: 80px; height: 80px; border-radius: 50%; color: white; font-weight: bold; display: flex; align-items: center; justify-content: center; font-size: 18px; border: 3px solid rgba(255,255,255,0.5); pointer-events: auto; touch-action: none; transition: transform 0.1s; }
.action-btn:active { transform: scale(0.9); }

#btn-draw { bottom: 150px; right: 40px; background: rgba(0, 100, 255, 0.6); }
#btn-draw.active { background: #fff; color: #00f; box-shadow: 0 0 20px #00f; }

#btn-metsu { bottom: 50px; right: 40px; background: rgba(255, 50, 50, 0.6); }

/* HUD */
#hud { position: absolute; top: 20px; left: 20px; color: #0ff; font-family: monospace; font-size: 16px; text-shadow: 1px 1px 0 #000; pointer-events: none; }
#status-msg { position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #f00; opacity: 0; pointer-events: none; transition: opacity 0.5s; text-align: center;}

</style>
</head>
<body>

<!-- UIレイヤー -->
<div id="ui-layer">
    <div id="hud">
        WAVE: <span id="val-wave">1</span><br>
        撃破: <span id="val-kill">0</span><br>
        結界: <span id="val-kekkai">0</span>/5
    </div>
    <div id="status-msg">滅！</div>

    <!-- スマホ用コントローラー -->
    <div id="mobile-controls">
        <div id="joystick-zone"><div id="joystick-knob"></div></div>
        <div id="btn-draw" class="action-btn">結界</div>
        <div id="btn-metsu" class="action-btn">滅</div>
    </div>
</div>

<!-- スタート画面 -->
<div id="start-screen">
    <div class="title">真・結界師VR</div>
    <div class="desc">
        Meta Quest 2 & スマホ 対応版<br>
        <br>
        【VR操作】<br>
        左スティック：移動<br>
        右手トリガー(長押し+移動)：結界生成<br>
        左手グリップ：滅(メツ)<br>
        <br>
        【スマホ操作】<br>
        左下パッド：移動<br>
        「結界」ボタン押下＋画面スワイプ：結界<br>
        「滅」ボタン：攻撃
    </div>
    <div id="btn-start">任務開始</div>
</div>

<script type="importmap">
{
    "imports":{
        "three":"https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
        "three/addons/":"https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
        "cannon-es":"https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { VRButton } from 'three/addons/webxr/VRButton.js';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
import * as CANNON from 'cannon-es';

// --- グローバル変数 ---
let scene, camera, renderer;
let world; // 物理演算
let clock;
let playerBody, playerMesh; // プレイヤー
const kekkaiList = [];
const enemyList = [];

// VR関連
let controller1, controller2;
let controllerGrip1, controllerGrip2;
let isVR = false;

// ゲーム状態
let wave = 1;
let killCount = 0;
let isDrawModeMobile = false;
let drawStartPos = new THREE.Vector3();
let drawingGhost = null; // 描画中の半透明結界

// 入力状態
const inputState = {
    moveX: 0,
    moveZ: 0,
    isDrawing: false,
    drawHandPos: new THREE.Vector3() // VR用
};

// --- 初期化 ---
document.getElementById('btn-start').addEventListener('click', initGame);

function initGame() {
    document.getElementById('start-screen').style.display = 'none';
    
    // シーンセットアップ
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000810);
    scene.fog = new THREE.FogExp2(0x000810, 0.02);

    // カメラ
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
    
    // レンダラー
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.xr.enabled = true; // VR有効化
    // VR入退室時のイベントハンドラ
    renderer.xr.addEventListener('sessionstart', () => {
        isVR = true;
        document.getElementById('mobile-controls').style.display = 'none';
        // プレイヤーの高さを調整
        playerMesh.position.set(0, 0, 0); 
    });
    renderer.xr.addEventListener('sessionend', () => {
        isVR = false;
        document.getElementById('mobile-controls').style.display = 'block';
        playerMesh.position.y = 1.6;
        camera.position.set(0, 1.6, 0);
    });
    
    document.body.appendChild(renderer.domElement);

    // VRボタンの追加 (Questではこれが重要)
    document.body.appendChild(VRButton.createButton(renderer));

    // 物理ワールド
    world = new CANNON.World();
    world.gravity.set(0, -9.82, 0);
    
    // マテリアル
    const matGround = new CANNON.Material();
    const matPlayer = new CANNON.Material();
    const matObject = new CANNON.Material();
    
    const contactMat = new CANNON.ContactMaterial(matGround, matPlayer, { friction: 0.0, restitution: 0.0 });
    world.addContactMaterial(contactMat);

    // 地面
    const groundBody = new CANNON.Body({ mass: 0, material: matGround });
    groundBody.addShape(new CANNON.Plane());
    groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
    world.addBody(groundBody);

    const gridHelper = new THREE.GridHelper(100, 100, 0x00ffff, 0x112233);
    scene.add(gridHelper);
    
    const floorMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(100, 100),
        new THREE.MeshStandardMaterial({ color: 0x111122, roughness: 0.8 })
    );
    floorMesh.rotation.x = -Math.PI / 2;
    floorMesh.receiveShadow = true;
    scene.add(floorMesh);

    // プレイヤー (物理 + カメラコンテナ)
    playerBody = new CANNON.Body({
        mass: 60,
        shape: new CANNON.Sphere(0.3),
        material: matPlayer,
        fixedRotation: true,
        linearDamping: 0.9
    });
    playerBody.position.set(0, 2, 5);
    world.addBody(playerBody);

    // VRではカメラを動かすコンテナとして機能
    playerMesh = new THREE.Group();
    playerMesh.add(camera);
    scene.add(playerMesh);

    // ライト
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    dirLight.shadow.camera.top = 20;
    dirLight.shadow.camera.bottom = -20;
    dirLight.shadow.camera.left = -20;
    dirLight.shadow.camera.right = 20;
    scene.add(dirLight);

    // 初期化関数呼び出し
    setupVRControllers();
    setupMobileControls();
    clock = new THREE.Clock();

    // 最初の敵スポーン
    spawnEnemy();
    spawnEnemy();

    // 描画開始
    renderer.setAnimationLoop(animate);
    
    // モバイルUIを表示 (VRじゃない場合)
    if(!navigator.xr) {
        document.getElementById('mobile-controls').style.display = 'block';
    } else {
        // XR対応デバイスでも、セッション開始まではモバイルUIを出す
        document.getElementById('mobile-controls').style.display = 'block';
    }
}

// --- VRコントローラー設定 ---
function setupVRControllers() {
    // 右手: 結界生成
    controller1 = renderer.xr.getController(0);
    controller1.addEventListener('selectstart', onVRDrawStart);
    controller1.addEventListener('selectend', onVRDrawEnd);
    playerMesh.add(controller1);

    // 左手: 滅
    controller2 = renderer.xr.getController(1);
    controller2.addEventListener('squeeze', onVRMetsu); // グリップボタンで滅
    playerMesh.add(controller2);

    // モデル表示
    const controllerModelFactory = new XRControllerModelFactory();
    
    controllerGrip1 = renderer.xr.getControllerGrip(0);
    controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
    playerMesh.add(controllerGrip1);

    controllerGrip2 = renderer.xr.getControllerGrip(1);
    controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
    playerMesh.add(controllerGrip2);

    // ガイドライン（右手のみ）
    const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-5)]);
    const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: 0.5, transparent: true }));
    controller1.add(line);
}

// --- スマホ操作設定 ---
function setupMobileControls() {
    // ジョイスティック
    const zone = document.getElementById('joystick-zone');
    const knob = document.getElementById('joystick-knob');
    let joyTouchId = null;
    let joyCenterX, joyCenterY;

    zone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        joyTouchId = touch.identifier;
        const rect = zone.getBoundingClientRect();
        joyCenterX = rect.left + rect.width / 2;
        joyCenterY = rect.top + rect.height / 2;
        updateJoystick(touch.clientX, touch.clientY);
    }, {passive: false});

    zone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        for(let i=0; i<e.changedTouches.length; i++) {
            if(e.changedTouches[i].identifier === joyTouchId) {
                updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                break;
            }
        }
    }, {passive: false});

    zone.addEventListener('touchend', (e) => {
        e.preventDefault();
        for(let i=0; i<e.changedTouches.length; i++) {
            if(e.changedTouches[i].identifier === joyTouchId) {
                joyTouchId = null;
                knob.style.transform = `translate(-50%, -50%)`;
                inputState.moveX = 0;
                inputState.moveZ = 0;
                break;
            }
        }
    }, {passive: false});

    function updateJoystick(x, y) {
        let dx = x - joyCenterX;
        let dy = y - joyCenterY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const maxDist = 40;
        
        if(dist > maxDist) {
            dx = (dx / dist) * maxDist;
            dy = (dy / dist) * maxDist;
        }
        
        knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        inputState.moveX = dx / maxDist;
        inputState.moveZ = dy / maxDist;
    }

    // 結界ボタン
    const btnDraw = document.getElementById('btn-draw');
    btnDraw.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if(kekkaiList.length >= 5) {
            showStatus("結界上限！", "#f00");
            return;
        }
        isDrawModeMobile = true;
        btnDraw.classList.add('active');
        
        // プレイヤーの前方5mに始点を作成
        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        forward.y = 0; forward.normalize();
        drawStartPos.copy(playerBody.position).add(new THREE.Vector3(0, 0, 0)).add(forward.multiplyScalar(3));
        drawStartPos.y = 1; // 高さ固定

        // ゴースト生成
        createGhost(drawStartPos);
    });

    // 画面スワイプで結界サイズ変更
    window.addEventListener('touchmove', (e) => {
        if(isDrawModeMobile && drawingGhost) {
            // スワイプ操作は簡易的に、最初のタッチからの移動量ではなく、
            // 視線方向の延長線上にある程度追従させる
            // （本来はもっと複雑だが、スマホVR風操作として簡略化）
            const touch = e.touches[0];
            const x = (touch.clientX / window.innerWidth) * 2 - 1;
            const y = -(touch.clientY / window.innerHeight) * 2 + 1;
            
            // レイキャストで地面との交点を求める
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
            const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -1); // y=1 plane
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(plane, target);
            
            if(target) {
                updateGhost(drawStartPos, target);
            }
        }
    });

    window.addEventListener('touchend', (e) => {
        if(isDrawModeMobile) {
            isDrawModeMobile = false;
            btnDraw.classList.remove('active');
            if(drawingGhost) {
                fixKekkaiFromGhost();
            }
        }
    });

    // 滅ボタン
    document.getElementById('btn-metsu').addEventListener('touchstart', (e) => {
        e.preventDefault();
        performMetsu();
        btnMetsu.style.transform = 'scale(0.9)';
        setTimeout(()=>btnMetsu.style.transform = 'scale(1)', 100);
    });
    const btnMetsu = document.getElementById('btn-metsu');
}

// --- ゲームロジック ---

function createGhost(pos) {
    if(drawingGhost) scene.remove(drawingGhost);
    const geo = new THREE.BoxGeometry(1, 1, 1);
    const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.5 });
    drawingGhost = new THREE.Mesh(geo, mat);
    drawingGhost.position.copy(pos);
    scene.add(drawingGhost);
}

function updateGhost(start, current) {
    if(!drawingGhost) return;
    
    const center = new THREE.Vector3().addVectors(start, current).multiplyScalar(0.5);
    const size = new THREE.Vector3().subVectors(current, start);
    
    // 最小サイズ保証
    size.x = Math.max(Math.abs(size.x), 1);
    size.y = Math.max(Math.abs(size.y), 1);
    size.z = Math.max(Math.abs(size.z), 1);

    drawingGhost.position.copy(center);
    drawingGhost.scale.copy(size);
}

function fixKekkaiFromGhost() {
    if(!drawingGhost) return;
    
    // 結界の実体化
    const pos = drawingGhost.position.clone();
    const size = drawingGhost.scale.clone();
    
    scene.remove(drawingGhost);
    drawingGhost = null;

    createKekkai(pos, size);
}

function createKekkai(pos, size) {
    // 視覚メッシュ
    const geo = new THREE.BoxGeometry(1, 1, 1);
    const mat = new THREE.MeshPhysicalMaterial({
        color: 0x0088ff,
        transparent: true, opacity: 0.3,
        metalness: 0.8, roughness: 0.2,
        emissive: 0x002244,
        side: THREE.DoubleSide
    });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(pos);
    mesh.scale.copy(size);
    scene.add(mesh);
    
    const edges = new THREE.LineSegments(
        new THREE.EdgesGeometry(geo),
        new THREE.LineBasicMaterial({ color: 0xaaffff })
    );
    mesh.add(edges);

    // 物理ボディ（敵を閉じ込めるための壁）
    // 簡易的に中央に一つ、KinematicなBoxを置くのではなく、
    // 4方の壁を作るのが理想だが、処理落ちを防ぐため
    // 「触れると敵を内側に押し返す」ロジックにするため、センサーとして定義
    const body = new CANNON.Body({
        mass: 0,
        shape: new CANNON.Box(new CANNON.Vec3(size.x/2, size.y/2, size.z/2)),
        isTrigger: true // 物理的な衝突はせず、検知のみに使う
    });
    body.position.copy(pos);
    world.addBody(body);

    const kekkai = { mesh, body, size, id: Date.now() };
    kekkaiList.push(kekkai);
    
    showStatus("結界 展開", "#0af");
    updateHUD();
    
    // 触覚フィードバック
    vibrate(20);
}

function performMetsu() {
    // プレイヤーに一番近い結界を探す
    let closest = null;
    let minDist = 30; // 射程距離
    const pPos = playerBody.position;

    kekkaiList.forEach(k => {
        const d = pPos.distanceTo(k.body.position);
        if(d < minDist) {
            minDist = d;
            closest = k;
        }
    });

    if(!closest) {
        showStatus("対象なし", "#888");
        return;
    }

    // 滅エフェクト
    showStatus("滅！！", "#f00");
    vibrate(100);

    // 縮小アニメーション開始
    const startScale = closest.mesh.scale.clone();
    let progress = 0;
    
    const timer = setInterval(() => {
        progress += 0.05;
        const s = 1.0 - progress;
        
        if(s <= 0.1) {
            clearInterval(timer);
            // 範囲内の敵を消滅
            const box = new THREE.Box3().setFromObject(closest.mesh);
            checkKill(box);
            
            // 削除
            removeKekkai(closest);
        } else {
            closest.mesh.scale.set(startScale.x*s, startScale.y*s, startScale.z*s);
        }
    }, 20);
}

function checkKill(box) {
    for(let i = enemyList.length - 1; i >= 0; i--) {
        const en = enemyList[i];
        if(box.containsPoint(en.mesh.position)) {
            // 撃破
            scene.remove(en.mesh);
            world.removeBody(en.body);
            enemyList.splice(i, 1);
            killCount++;
            
            // パーティクル
            spawnParticles(en.mesh.position);
            vibrate(50);
        }
    }
    updateHUD();
}

function removeKekkai(k) {
    const idx = kekkaiList.indexOf(k);
    if(idx > -1) {
        scene.remove(k.mesh);
        world.removeBody(k.body);
        kekkaiList.splice(idx, 1);
        updateHUD();
    }
}

// --- VR Input Handlers ---
function onVRDrawStart() {
    if(kekkaiList.length >= 5) return;
    
    inputState.isDrawing = true;
    
    // コントローラーの先端位置
    const pos = getControllerPosition(controller1);
    drawStartPos.copy(pos);
    createGhost(pos);
}

function onVRDrawEnd() {
    if(inputState.isDrawing) {
        inputState.isDrawing = false;
        fixKekkaiFromGhost();
    }
}

function onVRMetsu() {
    performMetsu();
}

function getControllerPosition(ctrl) {
    const p = new THREE.Vector3();
    const r = new THREE.Quaternion();
    ctrl.getWorldPosition(p);
    return p;
}

// --- メインループ ---
function animate() {
    const dt = clock.getDelta();
    
    // 物理更新
    world.step(1/60, dt, 3);
    
    // VR入力による移動 (左スティック)
    if(isVR) {
        handleVRMovement();
        
        // 結界描画中の更新
        if(inputState.isDrawing && drawingGhost) {
            const currentPos = getControllerPosition(controller1);
            // 手を動かしてボックスを作る感覚
            // 始点と現在位置を対角線とするボックス
            updateGhost(drawStartPos, currentPos);
        }
    } else {
        // スマホ入力による移動
        handleMobileMovement();
    }
    
    // 敵の挙動
    updateEnemies();
    
    // プレイヤーメッシュ(カメラ)と物理ボディの同期
    if(!isVR) {
        playerMesh.position.copy(playerBody.position);
        playerMesh.position.y -= 1.0; // カメラの目の高さ調整
    } else {
        // VRの場合、物理ボディをHeadsetの位置に追従させる（簡易的）
        const headsetPos = new THREE.Vector3();
        camera.getWorldPosition(headsetPos);
        playerBody.position.x = headsetPos.x;
        playerBody.position.z = headsetPos.z;
        // Yは固定しないと飛んでしまう、または身長に合わせる
    }

    renderer.render(scene, camera);
}

function handleVRMovement() {
    const session = renderer.xr.getSession();
    if(!session || !session.inputSources) return;

    let ax = 0, ay = 0; // x, z movement
    
    for(const source of session.inputSources) {
        if(source.handedness === 'left' && source.gamepad) {
            if(source.gamepad.axes.length >= 4) {
                ax = source.gamepad.axes[2];
                ay = source.gamepad.axes[3];
            }
        }
    }
    
    applyMovement(ax, ay);
}

function handleMobileMovement() {
    // 視点操作（タッチスワイプ）は別途実装が必要だが、今回はジャイロ風にカメラが向いている方向に進む前提
    // あるいは単純にカメラのY軸回転に進む
    applyMovement(inputState.moveX, inputState.moveZ);
}

function applyMovement(x, z) {
    if(Math.abs(x) < 0.1 && Math.abs(z) < 0.1) {
        playerBody.velocity.x *= 0.9;
        playerBody.velocity.z *= 0.9;
        return;
    }
    
    const speed = 5;
    // カメラの向きに合わせて移動ベクトルを回転
    const direction = new THREE.Vector3(x, 0, z);
    
    // カメラのY軸回転のみ取得
    const camEuler = new THREE.Euler(0, 0, 0, 'YXZ');
    camEuler.setFromQuaternion(camera.quaternion);
    direction.applyAxisAngle(new THREE.Vector3(0,1,0), camEuler.y);
    
    playerBody.velocity.x = direction.x * speed;
    playerBody.velocity.z = direction.z * speed;
}

// --- 敵システム ---
function spawnEnemy() {
    if(enemyList.length > 10) return;
    
    const angle = Math.random() * Math.PI * 2;
    const dist = 10 + Math.random() * 10;
    const x = Math.sin(angle) * dist;
    const z = Math.cos(angle) * dist;
    
    const geo = new THREE.OctahedronGeometry(0.5);
    const mat = new THREE.MeshStandardMaterial({ color: 0xff3333, roughness: 0.5 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, 5, z);
    mesh.castShadow = true;
    scene.add(mesh);
    
    const body = new CANNON.Body({
        mass: 5,
        shape: new CANNON.Sphere(0.5),
        linearDamping: 0.5
    });
    body.position.copy(mesh.position);
    world.addBody(body);
    
    enemyList.push({ mesh, body });
}

function updateEnemies() {
    const pPos = playerBody.position;
    
    if(Math.random() < 0.01) spawnEnemy();
    
    enemyList.forEach(en => {
        en.mesh.position.copy(en.body.position);
        en.mesh.quaternion.copy(en.body.quaternion);
        
        // プレイヤーに向かう
        const dir = new THREE.Vector3().subVectors(pPos, en.body.position);
        dir.y = 0; dir.normalize();
        
        // 結界内なら動けない、などの処理を入れると面白い
        // ここでは単純な追尾
        en.body.applyForce(new CANNON.Vec3(dir.x*10, 0, dir.z*10), en.body.position);
        
        // 落下死
        if(en.body.position.y < -10) {
             // reset
             en.body.position.set(0, 10, 0);
             en.body.velocity.set(0,0,0);
        }
    });
}

// --- エフェクト & ユーティリティ ---
function spawnParticles(pos) {
    const count = 10;
    const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
    const mat = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
    
    for(let i=0; i<count; i++) {
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.copy(pos);
        mesh.position.x += (Math.random()-0.5);
        mesh.position.y += (Math.random()-0.5);
        mesh.position.z += (Math.random()-0.5);
        scene.add(mesh);
        
        // 簡易アニメーションで消滅させる
        const dest = mesh.position.clone().add(new THREE.Vector3((Math.random()-0.5)*2, 1, (Math.random()-0.5)*2));
        
        let frames = 0;
        const anim = () => {
            mesh.position.lerp(dest, 0.1);
            mesh.scale.multiplyScalar(0.9);
            frames++;
            if(frames < 30) requestAnimationFrame(anim);
            else scene.remove(mesh);
        };
        anim();
    }
}

function updateHUD() {
    document.getElementById('val-wave').textContent = wave;
    document.getElementById('val-kill').textContent = killCount;
    document.getElementById('val-kekkai').textContent = kekkaiList.length;
}

function showStatus(text, color) {
    const el = document.getElementById('status-msg');
    el.textContent = text;
    el.style.color = color;
    el.style.textShadow = `0 0 10px ${color}`;
    el.style.opacity = 1;
    setTimeout(() => el.style.opacity = 0, 1500);
}

function vibrate(ms) {
    // モバイル
    if(navigator.vibrate) navigator.vibrate(ms);
    // VRコントローラー
    if(isVR && controller1 && controller1.gamepad && controller1.gamepad.hapticActuators) {
        controller1.gamepad.hapticActuators[0].pulse(1.0, ms);
    }
}

// リサイズ対応
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
