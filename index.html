<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>真・結界師VR — 百鬼夜行・メタクエスト対応フル版</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover, user-scalable=no">
<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:"Sawarabi Mincho", serif; overflow:hidden; touch-action: none;}
  canvas{display:block}
  #hud { position: fixed; left: 16px; top: 16px; background: rgba(0,10,30,0.6); border: 1px solid #4af; padding:10px; border-radius:6px; font-size:14px; width:260px; pointer-events:none; z-index:10; text-shadow: 0 0 5px #0ff; box-shadow: 0 0 10px rgba(0,100,255,0.3); }
  .val { font-weight:bold; color:#fff; }
  .wave-info { font-size: 16px; color: #fe0; font-weight:bold; margin-bottom:4px; }

  #mobileUI { position: fixed; top:0; left:0; width:100%; height:100%; pointer-events: none; z-index: 20; display: flex; justify-content: space-between; align-items: flex-end; padding-bottom: 20px; box-sizing: border-box; }

  #dpadArea { pointer-events: auto; width: 150px; height: 150px; margin-left: 20px; margin-bottom: 20px; display: grid; grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; gap: 4px; }
  .d-btn { background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.3); border-radius: 6px; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(4px); font-size: 20px; pointer-events: auto; color:#fff; }
  .d-btn:active, .d-btn.active { background: rgba(0,255,255,0.4); border-color: #0ff; }

  #actionArea { pointer-events: auto; width: 170px; height: 300px; margin-right: 20px; margin-bottom: 10px; display: flex; flex-direction: column; gap: 10px; }
  .btn { width: 100%; flex: 1; border-radius: 10px; border: 2px solid rgba(255,255,255,0.6); color: #fff; font-weight: bold; font-size: 16px; display: flex; align-items: center; justify-content: center; flex-direction: column; box-shadow: 0 4px 10px rgba(0,0,0,0.5); background: rgba(0,0,0,0.4); backdrop-filter: blur(4px); transition: transform 0.08s; pointer-events: auto; }
  .btn:active { transform: scale(0.95); background: rgba(255,255,255,0.2); }

  #rowUpper { display: flex; gap: 8px; flex: 2; }
  #btnDraw { background: linear-gradient(135deg, #0af, #06a); flex: 1.5; font-size: 18px; border-color: #0af; }
  #btnDraw.drawing { background: linear-gradient(135deg, #fff, #0af); color: #000; box-shadow: 0 0 15px #0af; }
  #btnRange { background: linear-gradient(135deg, #666, #444); flex: 1; font-size: 14px; border-color: #888; }

  #subActions { display: flex; gap: 8px; flex: 1.2; }
  #btnMets { background: linear-gradient(135deg, #f24, #a12); flex:1; font-size: 20px; }
  #btnKai { background: linear-gradient(135deg, #4f8, #284); flex:1; font-size: 20px; }
  #btnJump { background: linear-gradient(135deg, #f0b, #80f); flex:0.8; height: 45px; }

  #vrToggle { position: fixed; top: 10px; right: 10px; z-index: 101; padding: 8px 16px; background: #333; color: #fff; border: 1px solid #fff; pointer-events: auto; border-radius:6px; }
  #reticle { position: fixed; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.6); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 5; box-shadow: 0 0 4px #000; }

  /* small hint */
  #hint { position: fixed; left: 50%; bottom: 12px; transform: translateX(-50%); padding: 6px 12px; background: rgba(0,0,0,0.6); border-radius: 8px; border:1px solid rgba(255,255,255,0.06); color:#ddd; font-size:13px; pointer-events:none; z-index:102; }
</style>

<!-- importmap: three + examples + cannon -->
<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
    "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
  }
}
</script>
</head>
<body>
<button id="vrToggle">VRモード</button>
<div id="reticle"></div>
<div id="hint">コントローラ：トリガーで結界作成・スティックで移動（Quest）</div>

<div id="hud">
  <div class="wave-info">WAVE <span id="waveVal">1</span>: <span id="waveName">静寂</span></div>
  <div>撃破数: <span id="killCount" class="val">0</span> (次へ: <span id="nextWave" class="val">3</span>)</div>
  <div style="margin-top:4px; font-size:12px; color:#aaa;">結界: <span id="kCount">0</span>/5 | 敵: <span id="eCount">0</span></div>
  <div id="statusText" style="color:#f0a; margin-top:6px; font-weight:bold;">索敵中…</div>
</div>

<div id="mobileUI">
  <div id="dpadArea">
    <div id="d-up" class="d-btn">▲</div>
    <div id="d-left" class="d-btn">◀</div>
    <div id="d-right" class="d-btn">▶</div>
    <div id="d-down" class="d-btn">▼</div>
  </div>
  <div id="actionArea">
    <div class="btn" id="btnJump">JUMP</div>
    <div id="rowUpper">
      <div class="btn" id="btnRange">距離<br><span id="rangeVal" style="color:#ff8">近</span></div>
      <div class="btn" id="btnDraw">方位<br><small style="font-size:10px">長押し変形</small></div>
    </div>
    <div id="subActions">
      <div class="btn" id="btnMets">滅</div>
      <div class="btn" id="btnKai">解</div>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from 'three';
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
import { XRHandMeshModel } from 'three/addons/webxr/XRHandMeshModel.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import * as CANNON from 'cannon-es';

/* ===========================
   基本ゲーム/物理/シーン設定
   =========================== */
let currentWave = 1, killCount = 0, killsToNextWave = 3;
const WAVE_INFO = {
  1: { name: "静寂 (練習)", type: "static", desc: "敵は動きません" },
  2: { name: "這い寄る影", type: "walker", desc: "地面を這ってきます" },
  3: { name: "跳梁跋扈", type: "jumper", desc: "跳ね回ります" },
  4: { name: "低空の脅威", type: "low_flyer", desc: "少し浮いています" },
  5: { name: "百鬼夜行", type: "high_flyer", desc: "空を自在に飛びます" }
};

let isVRMode = false;
const MAX_ENEMIES = 6;
const RESPAWN_SECONDS = 8;
const KEKKAI_LIMIT = 6;
const KEKKAI_DURATION = 40000;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x051133);
scene.fog = new THREE.FogExp2(0x051133, 0.012);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 200);
const playerGroup = new THREE.Group();
scene.add(playerGroup);
playerGroup.add(camera);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.xr.enabled = true;
renderer.xr.setFoveation ? renderer.xr.setFoveation(0.7) : null;
renderer.shadowMap.enabled = true;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
document.body.appendChild(renderer.domElement);

/* 物理 */
const world = new CANNON.World();
world.gravity.set(0, -15, 0);
world.broadphase = new CANNON.NaiveBroadphase();
world.solver.iterations = 20;

const matDefault = new CANNON.Material('default');
const matPlayer = new CANNON.Material('player');
const matEnemy = new CANNON.Material('enemy');
const matKekkai = new CANNON.Material('kekkai');

world.addContactMaterial(new CANNON.ContactMaterial(matDefault, matDefault, { friction: 0.3, restitution: 0.3 }));
world.addContactMaterial(new CANNON.ContactMaterial(matPlayer, matDefault, { friction: 0.0, restitution: 0.0 }));
world.addContactMaterial(new CANNON.ContactMaterial(matEnemy, matDefault, { friction: 0.3, restitution: 0.5 }));
world.addContactMaterial(new CANNON.ContactMaterial(matKekkai, matEnemy, { friction: 0.0, restitution: 0.2 }));
world.addContactMaterial(new CANNON.ContactMaterial(matKekkai, matPlayer, { friction: 0.0, restitution: 0.0 }));

/* プレイヤー */
const playerBody = new CANNON.Body({
  mass: 80,
  shape: new CANNON.Sphere(0.45),
  material: matPlayer,
  fixedRotation: true,
  angularDamping: 1.0
});
playerBody.position.set(0, 5.0, 15);
world.addBody(playerBody);

/* 環境ライト等 */
const hemi = new THREE.HemisphereLight(0x8888ff, 0x444455, 0.8); scene.add(hemi);
const moonLight = new THREE.DirectionalLight(0xddeeff, 1.5);
moonLight.position.set(30, 80, -50);
moonLight.castShadow = true;
moonLight.shadow.mapSize.width = 2048;
moonLight.shadow.mapSize.height = 2048;
scene.add(moonLight);

const moon = new THREE.Mesh(new THREE.SphereGeometry(6, 32, 32),
  new THREE.MeshBasicMaterial({color: 0xffffee, toneMapped:false}));
moon.position.copy(moonLight.position).multiplyScalar(1.2);
scene.add(moon);

const floorBody = new CANNON.Body({ type: CANNON.Body.STATIC, material: matDefault });
floorBody.addShape(new CANNON.Plane());
floorBody.quaternion.setFromEuler(-Math.PI/2,0,0);
world.addBody(floorBody);
const floorMesh = new THREE.Mesh(new THREE.PlaneGeometry(150,150), new THREE.MeshStandardMaterial({color:0x6d5047, roughness: 0.8}));
floorMesh.rotation.x = -Math.PI/2; floorMesh.receiveShadow = true;
scene.add(floorMesh);

/* 建物（省略せずにいくつか） */
function createStaticBox(x,y,z,w,h,d,color,texture=null){
  const mat = texture ? new THREE.MeshStandardMaterial({map:texture, color:0xffffff}) : new THREE.MeshStandardMaterial({color});
  const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat);
  m.position.set(x,y,z); m.castShadow=true; m.receiveShadow=true; scene.add(m);
  const b = new CANNON.Body({ type: CANNON.Body.STATIC, material: matDefault });
  b.addShape(new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)));
  b.position.set(x,y,z); world.addBody(b);
}
function createWindowTexture(){
  const cvs = document.createElement('canvas'); cvs.width=128; cvs.height=128;
  const ctx = cvs.getContext('2d');
  ctx.fillStyle = '#754'; ctx.fillRect(0,0,128,128);
  ctx.fillStyle = '#012'; ctx.fillRect(10,10,48,64); ctx.fillRect(70,10,48,64);
  ctx.fillStyle = '#fe9'; ctx.globalAlpha=0.6; ctx.fillRect(10,10,48,64); ctx.globalAlpha=1.0;
  const tex = new THREE.CanvasTexture(cvs); tex.wrapS=THREE.RepeatWrapping; tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(4,2); tex.colorSpace = THREE.SRGBColorSpace;
  return tex;
}
(function initEnvironment(){
  const winTex = createWindowTexture();
  createStaticBox(0,10,-45,70,20,15,0xdddddd, winTex);
  const sideTex = winTex.clone(); sideTex.repeat.set(2,2);
  createStaticBox(-40,10,-30,15,20,40,0xdddddd, sideTex);
  createStaticBox(40,4,0,2,8,90,0x9999aa);
  createStaticBox(-40,4,30,2,8,60,0x9999aa);
  createStaticBox(-12,5,40,4,10,4,0x555566);
  createStaticBox(12,5,40,4,10,4,0x555566);
})();

/* ===========================
   結界（VRでの操作を追加）
   =========================== */
let kekkaiList = [];
let isDrawing = false;
let ghost = null;
let drawDistanceMode = "NEAR";
const DIST_NEAR = 4.0, DIST_FAR = 15.0;

const ghostGeo = new THREE.BoxGeometry(1,1,1);
const ghostMat = new THREE.MeshBasicMaterial({color:0x00ffff, wireframe:true, transparent:true, opacity:0.45});

/* UI elements */
const btnRange = document.getElementById('btnRange');
const elRangeVal = document.getElementById('rangeVal');
btnRange.addEventListener('touchstart',(e)=>{ e.preventDefault(); toggleRange(); });
function toggleRange(){ if(drawDistanceMode==="NEAR"){ drawDistanceMode="FAR"; elRangeVal.textContent="遠"; elRangeVal.style.color="#0ff"; pulseHUD("射程：遠 (15m)", "#0ff"); } else { drawDistanceMode="NEAR"; elRangeVal.textContent="近"; elRangeVal.style.color="#ff8"; pulseHUD("射程：近 (4m)", "#ff8"); } }

/* ghost の生成（VR用・手元から伸ばす） */
function startDrawingAt(posWorld){
  if(kekkaiList.length >= KEKKAI_LIMIT){ pulseHUD("結界数が上限です", "#f44"); return; }
  isDrawing = true;
  document.getElementById('btnDraw').classList.add('drawing');
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  const dist = (drawDistanceMode==="NEAR") ? DIST_NEAR : DIST_FAR;
  const startPos = posWorld.clone().add(dir.multiplyScalar(dist*0.3));
  ghost = new THREE.Mesh(ghostGeo, ghostMat);
  ghost.position.copy(startPos);
  ghost.scale.set(1,1,1);
  scene.add(ghost);
}
function updateGhostByVector(scaleVec){
  if(!ghost) return;
  // scaleVec is THREE.Vector3 indicating intended scaling multipliers
  const sX = Math.max(0.5, Math.min(10, scaleVec.x));
  const sY = Math.max(0.5, Math.min(10, scaleVec.y));
  const sZ = Math.max(0.5, Math.min(10, scaleVec.z));
  ghost.scale.set(sX, sY, sZ);
}
function finalizeDrawingAt(){
  if(!ghost) return;
  const pos = ghost.position.clone();
  const size = ghost.scale.clone();
  scene.remove(ghost); ghost = null; isDrawing=false;
  document.getElementById('btnDraw').classList.remove('drawing');
  createKekkai(pos, size);
}

function createKekkai(pos, size){
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(size.x, size.y, size.z), new THREE.MeshPhongMaterial({color:0x00aaff, transparent:true, opacity:0.28, emissive:0x004488, side:THREE.DoubleSide, depthWrite:false}));
  mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(mesh.geometry), new THREE.LineBasicMaterial({color:0x88ffff})));
  mesh.position.copy(pos); scene.add(mesh);

  const body = new CANNON.Body({ mass: 0, material: matKekkai });
  const hx = size.x/2, hy = size.y/2, hz = size.z/2, hth = 0.25;
  // 6面の薄い箱で囲う（簡易的な当たり）
  body.addShape(new CANNON.Box(new CANNON.Vec3(hth, hy, hz)), new CANNON.Vec3(hx, 0, 0));
  body.addShape(new CANNON.Box(new CANNON.Vec3(hth, hy, hz)), new CANNON.Vec3(-hx, 0, 0));
  body.addShape(new CANNON.Box(new CANNON.Vec3(hx, hth, hz)), new CANNON.Vec3(0, hy, 0));
  body.addShape(new CANNON.Box(new CANNON.Vec3(hx, hth, hz)), new CANNON.Vec3(0, -hy, 0));
  body.addShape(new CANNON.Box(new CANNON.Vec3(hx, hy, hth)), new CANNON.Vec3(0, 0, hz));
  body.addShape(new CANNON.Box(new CANNON.Vec3(hx, hy, hth)), new CANNON.Vec3(0, 0, -hz));
  body.position.set(pos.x, pos.y, pos.z);
  world.addBody(body);

  const k = { mesh, body, initialSize: size.clone(), createdAt: performance.now(), isShrinking:false };
  kekkaiList.push(k);
  spawnKanji("結", pos, "#0af");
  updateCounts();
  setTimeout(()=>{ if(kekkaiList.includes(k) && !k.isShrinking) removeKekkai(k); }, KEKKAI_DURATION);
}

function removeKekkai(k){
  try{ scene.remove(k.mesh); world.removeBody(k.body); }catch(e){}
  kekkaiList = kekkaiList.filter(x=>x!==k);
  updateCounts();
}

/* ===========================
   敵AI（既存ロジック統合）
   =========================== */
let enemies = [];
let lastSpawnAttempt = performance.now();

function spawnEnemyByWave(){
  if(enemies.length >= MAX_ENEMIES) return;
  let wInfo = WAVE_INFO[currentWave] || WAVE_INFO[5];
  const type = wInfo.type;
  const size = 0.5 + Math.random()*0.5;
  const hue = Math.random();
  const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
  const emCol = new THREE.Color().setHSL(hue, 1.0, 0.3);
  let geo = (Math.random()<0.33) ? new THREE.SphereGeometry(size, 16, 16) : ((Math.random()<0.5) ? new THREE.BoxGeometry(size*1.5,size*1.5,size*1.5) : new THREE.IcosahedronGeometry(size*1.2,0));
  const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color, roughness:0.2, metalness:0.4, emissive:emCol, emissiveIntensity:0.5}));
  const mass = 5;
  const body = new CANNON.Body({ mass, shape: new CANNON.Sphere(size), material: matEnemy, linearDamping: 0.3, angularDamping: 0.3 });
  const angle = Math.random()*Math.PI*2;
  const dist = 15 + Math.random()*20;
  const spawnY = (type === 'high_flyer' || type === 'low_flyer') ? (5 + Math.random()*10) : (1 + Math.random()*3);
  body.position.set(Math.sin(angle)*dist, spawnY, Math.cos(angle)*dist);
  world.addBody(body); scene.add(mesh);
  const en = { mesh, body, size, type, trapped:false, nextMoveTime:0, moveDir:new THREE.Vector3(), hp:1 };
  enemies.push(en); updateCounts();
}
function updateEnemies(dt){
  if(enemies.length < MAX_ENEMIES && (performance.now() - lastSpawnAttempt) > RESPAWN_SECONDS*1000){ spawnEnemyByWave(); lastSpawnAttempt = performance.now(); }
  const ppos = playerBody.position;
  const now = performance.now();
  enemies.forEach(en=>{
    en.mesh.position.copy(en.body.position);
    en.mesh.quaternion.copy(en.body.quaternion);
    if(en.trapped) return;
    if(en.body.position.y < -30){ destroyEnemy(en); return; }
    if(en.type === 'static') return;
    const dx = ppos.x - en.body.position.x, dz = ppos.z - en.body.position.z;
    const dist = Math.sqrt(dx*dx+dz*dz);
    const isChasing = (now > en.nextMoveTime);
    let force = 0; let dir = new THREE.Vector3(dx,0,dz).normalize();
    if(en.type === 'walker'){
      if(isChasing){ if(Math.random()<0.7) en.moveDir.copy(dir); else en.moveDir.set(Math.random()-0.5,0,Math.random()-0.5).normalize(); en.nextMoveTime = now + 2000; }
      force = 8; en.body.applyForce(new CANNON.Vec3(en.moveDir.x*force, 0, en.moveDir.z*force), en.body.position);
    } else if(en.type === 'jumper'){
      if(isChasing){ if(Math.random()<0.8) en.moveDir.copy(dir); else en.moveDir.set(Math.random()-0.5,0,Math.random()-0.5).normalize(); if(en.body.position.y < 2.0){ en.body.velocity.y = 8 + Math.random()*4; } en.nextMoveTime = now + 1500; }
      force = 6; if(en.body.position.y < 2.0) en.body.applyForce(new CANNON.Vec3(en.moveDir.x*force, 0, en.moveDir.z*force), en.body.position);
    } else if(en.type === 'low_flyer'){
      const hoverY = 3.0 + Math.sin(now*0.002);
      const diffY = hoverY - en.body.position.y;
      const lift = 15 * en.body.mass + diffY * 10;
      en.body.applyForce(new CANNON.Vec3(0, lift, 0), en.body.position);
      force = 4; en.body.applyForce(new CANNON.Vec3(dir.x*force, 0, dir.z*force), en.body.position);
    } else if(en.type === 'high_flyer'){
      const dy = (ppos.y + 1.0) - en.body.position.y;
      dir.set(dx, dy, dz).normalize();
      en.body.applyForce(new CANNON.Vec3(0, 15*en.body.mass, 0), en.body.position);
      if(isChasing){ force = (Math.random()<0.3) ? 20 : 6; en.nextMoveTime = now + 1000; } else force = 6;
      en.body.applyForce(new CANNON.Vec3(dir.x*force, dir.y*force, dir.z*force), en.body.position);
    }
  });
}
function destroyEnemy(en){
  spawnParticles(en.mesh.position, en.mesh.material.emissive.getHex(), 20);
  try{ scene.remove(en.mesh); world.removeBody(en.body); }catch(e){}
  enemies = enemies.filter(x=>x!==en);
  killCount++; killsToNextWave--; if(killsToNextWave <= 0) levelUpWave();
  updateCounts();
}
function levelUpWave(){ currentWave++; killsToNextWave = (currentWave < 5) ? 4 : 8; pulseHUD("WAVE UP!", "#fe0"); spawnKanji("危", new THREE.Vector3(0,5,10), "#f40"); updateCounts(); }

/* ===========================
   滅/解/ユーティリティ
   =========================== */
function metsAction(){
  const target = pickClosestKekkai(30.0);
  if(!target){ pulseHUD("対象なし", "#888"); return; }
  if(target.isShrinking) return;
  pulseHUD("滅！", "#f24");
  spawnKanji("滅", target.mesh.position, "#f24");
  target.isShrinking = true;
  let currentScale = 1.0; const shrinkSpeed = 0.02;
  (function shrinkStep(){
    if(!kekkaiList.includes(target)) return;
    currentScale -= shrinkSpeed;
    const currentSize = Math.min(target.initialSize.x, target.initialSize.y, target.initialSize.z) * currentScale;
    const boxBox = new THREE.Box3().setFromObject(target.mesh);
    const center = target.body.position;
    enemies.forEach(en=>{
      if(boxBox.containsPoint(en.mesh.position)){
        en.trapped = true;
        const dirToCenter = center.vsub(en.body.position);
        dirToCenter.scale(25, dirToCenter);
        en.body.applyForce(dirToCenter, en.body.position);
        en.body.velocity.scale(0.8, en.body.velocity);
        if(currentSize < en.size * 1.8){
          destroyEnemy(en);
          spawnParticles(en.mesh.position, 0xffaa00, 30);
          spawnKanji("潰", en.mesh.position, "#fa0");
        }
      }
    });
    if(currentScale <= 0.05){ removeKekkai(target); spawnParticles(target.mesh.position, 0xffaa00, 10); return; }
    target.mesh.scale.setScalar(currentScale);
    // Update collision shapes (approx)
    const th = 0.5; const hx = (target.initialSize.x * currentScale)/2; const hy=(target.initialSize.y*currentScale)/2; const hz=(target.initialSize.z*currentScale)/2; const hth = th/2;
    updateBoxShape(target.body, 0, new CANNON.Vec3(hth, hy, hz), new CANNON.Vec3(hx,0,0));
    updateBoxShape(target.body, 1, new CANNON.Vec3(hth, hy, hz), new CANNON.Vec3(-hx,0,0));
    updateBoxShape(target.body, 2, new CANNON.Vec3(hx, hth, hz), new CANNON.Vec3(0,hy,0));
    updateBoxShape(target.body, 3, new CANNON.Vec3(hx, hth, hz), new CANNON.Vec3(0,-hy,0));
    updateBoxShape(target.body, 4, new CANNON.Vec3(hx, hy, hth), new CANNON.Vec3(0,0,hz));
    updateBoxShape(target.body, 5, new CANNON.Vec3(hx, hy, hth), new CANNON.Vec3(0,0,-hz));
    target.body.updateBoundingRadius();
    target.body.aabbNeedsUpdate = true;
    target.mesh.material.opacity = 0.3 + (1.0-currentScale)*0.7;
    requestAnimationFrame(shrinkStep);
  })();
}
function updateBoxShape(body, index, halfExtents, offset){
  if(!body.shapes[index]) return;
  body.shapes[index].halfExtents.copy(halfExtents);
  body.shapes[index].updateConvexPolyhedronRepresentation();
  body.shapeOffsets[index].copy(offset);
}
function spawnKanji(text, pos, color="#4af"){
  const cvs=document.createElement('canvas'); cvs.width=128; cvs.height=128;
  const ctx=cvs.getContext('2d'); ctx.font="bold 96px serif"; ctx.fillStyle=color; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(text,64,64);
  const tex=new THREE.CanvasTexture(cvs);
  const mat = new THREE.SpriteMaterial({map:tex, transparent:true, depthTest:false});
  const sp = new THREE.Sprite(mat); sp.position.copy(pos); sp.scale.set(0.001,0.001,0.001); scene.add(sp);
  let f=0; (function a(){ f+=0.04; const s = Math.min(1, f*2); sp.scale.setScalar(s*0.6); sp.position.y+=0.02; sp.material.opacity = 1-f; if(f<1) requestAnimationFrame(a); else { try{ scene.remove(sp); tex.dispose(); mat.dispose(); } catch(e){} } })();
}
function spawnParticles(pos, colorInt, count=14){
  for(let i=0;i<count;i++){
    const box = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.12,0.12), new THREE.MeshBasicMaterial({color: colorInt}));
    box.position.copy(pos); scene.add(box);
    const v = new THREE.Vector3((Math.random()-0.5),(Math.random()-0.5),(Math.random()-0.5)).multiplyScalar(0.6);
    (function pAnim(m, vel){ m.position.add(vel); m.scale.multiplyScalar(0.9); m.rotation.x+=0.2; if(m.scale.x>0.02) requestAnimationFrame(()=>pAnim(m, vel)); else { try{ scene.remove(m); m.geometry.dispose(); m.material.dispose(); }catch(e){} } })(box, v);
  }
}
function pulseHUD(text, col="#fff"){ const el=document.getElementById('statusText'); el.textContent=text; el.style.color = col || "#fff"; setTimeout(()=>el.style.color="#f0a", 1500); }

/* ===========================
   UI / Controls（スマホとVR両対応）
   =========================== */
let moveState = { fwd:0, back:0, left:0, right:0 };
let wantsJump = false;
['d-up','d-down','d-left','d-right'].forEach(id=>{
  const el=document.getElementById(id);
  el.addEventListener('touchstart',(e)=>{ e.preventDefault(); el.classList.add('active'); if(id==='d-up') moveState.fwd=1; if(id==='d-down') moveState.back=1; if(id==='d-left') moveState.left=1; if(id==='d-right') moveState.right=1; });
  el.addEventListener('touchend',(e)=>{ e.preventDefault(); el.classList.remove('active'); if(id==='d-up') moveState.fwd=0; if(id==='d-down') moveState.back=0; if(id==='d-left') moveState.left=0; if(id==='d-right') moveState.right=0; });
});

document.getElementById('btnJump').addEventListener('touchstart',(e)=>{ e.preventDefault(); wantsJump=true; });
document.getElementById('btnMets').addEventListener('touchstart',(e)=>{ e.preventDefault(); metsAction(); });
document.getElementById('btnKai').addEventListener('touchstart',(e)=>{ e.preventDefault(); const k = pickClosestKekkai(15.0); if(k){ spawnKanji("解", k.mesh.position, "#8f8"); removeKekkai(k); } else pulseHUD("対象なし", "#888"); });

const btnDraw = document.getElementById('btnDraw');
btnDraw.addEventListener('touchstart',(e)=>{ e.preventDefault(); const t=e.touches[0]; drawStartTouch = {x:t.clientX, y:t.clientY}; startDrawing(); });
btnDraw.addEventListener('touchmove',(e)=>{ e.preventDefault(); const t=e.touches[0]; updateGhostShape(t.clientX, t.clientY); });
btnDraw.addEventListener('touchend',(e)=>{ e.preventDefault(); finalizeDrawing(); });

/* カメラ・視点の簡易操作（タッチ） */
let lastX=0, lastY=0, camYaw=0, camPitch=0;
renderer.domElement.addEventListener('touchstart', e=>{ if(e.touches.length===1 && !isDrawing){ const t=e.touches[0]; lastX=t.clientX; lastY=t.clientY; } }, {passive:false});
renderer.domElement.addEventListener('touchmove', e=>{ e.preventDefault(); if(e.touches.length===1 && !isDrawing){ const t=e.touches[0]; const dx=t.clientX-lastX, dy=t.clientY-lastY; camYaw -= dx*0.004; camPitch -= dy*0.004; camPitch = Math.max(-1.4, Math.min(1.4, camPitch)); playerGroup.rotation.y = camYaw; camera.rotation.x = camPitch; lastX=t.clientX; lastY=t.clientY; } }, {passive:false});

/* pickClosest etc. */
function pickClosestKekkai(range){
  let best=null, bestD2 = range*range;
  const px = playerBody.position.x, py=playerBody.position.y, pz=playerBody.position.z;
  kekkaiList.forEach(k=>{
    const dx = px - k.body.position.x, dy=py - k.body.position.y, dz=pz - k.body.position.z;
    const d2 = dx*dx+dy*dy+dz*dz;
    if(d2 < bestD2){ bestD2 = d2; best = k; }
  });
  return best;
}
function updateCounts(){
  document.getElementById('kCount').textContent = kekkaiList.length;
  document.getElementById('eCount').textContent = enemies.length;
  document.getElementById('killCount').textContent = killCount;
  document.getElementById('nextWave').textContent = killsToNextWave;
  const w = WAVE_INFO[currentWave] || WAVE_INFO[5];
  document.getElementById('waveVal').textContent = currentWave;
  document.getElementById('waveName').textContent = w.name;
}

/* ===========================
   XR (WebXR) & Controller handling
   =========================== */
const controllerModelFactory = new XRControllerModelFactory();
const controllers = []; // { grip, controller, hand, prevPos, vel, drawingState, ghostRef }
function buildController(index){
  const controller = renderer.xr.getController(index);
  controller.userData.index = index;
  controller.addEventListener('connected', (ev)=>{
    controller.userData.inputSource = ev.data;
  });
  controller.addEventListener('disconnected', ()=>{ controller.userData.inputSource = null; });
  scene.add(controller);
  const grip = renderer.xr.getControllerGrip(index);
  grip.add(controllerModelFactory.createControllerModel(grip));
  scene.add(grip);
  controllers.push({controller, grip, prevPos: new THREE.Vector3(), vel: new THREE.Vector3(), drawing:false, ghost:null});
  return controllers[controllers.length-1];
}
// build two controllers
buildController(0); buildController(1);

/* XR UI: 設定パネル（シーン内キャンバス） */
const settingsCanvas = document.createElement('canvas');
settingsCanvas.width = 512; settingsCanvas.height = 256;
const settingsCtx = settingsCanvas.getContext('2d');
function redrawSettings(){
  settingsCtx.fillStyle = "#001022"; settingsCtx.fillRect(0,0,512,256);
  settingsCtx.fillStyle = "#fff"; settingsCtx.font = "20px sans-serif"; settingsCtx.fillText("設定パネル", 18, 32);
  settingsCtx.font = "14px sans-serif";
  settingsCtx.fillText("移動速度: " + (uiSettings.moveSpeed.toFixed(1)), 18, 70);
  settingsCtx.fillText("結界最大サイズ: " + uiSettings.maxKekkaiSize, 18, 100);
  settingsCtx.fillText("スティック感度: " + (uiSettings.stickSensitivity.toFixed(2)), 18, 130);
  settingsCtx.fillStyle = "#0ff"; settingsCtx.fillText("[クリックで変更] (VRコントローラのトリガーで選択)", 18, 170);
}
redrawSettings();
const settingsTex = new THREE.CanvasTexture(settingsCanvas);
const settingsMat = new THREE.MeshBasicMaterial({map: settingsTex, side: THREE.DoubleSide});
const settingsMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 0.8), settingsMat);
settingsMesh.position.set(0, 2.2, -1.8);
scene.add(settingsMesh);

/* Raycaster for XR UI */
const xrRay = new THREE.Raycaster();
function handleXRUIPress(point){
  // simple mapping: Y coordinate on canvas changes setting
  // convert world point to local uv on settingsMesh
  const local = settingsMesh.worldToLocal(point.clone());
  const u = (local.x / 1.6 + 0.5) * settingsCanvas.width;
  const v = ( - local.y / 0.8 + 0.5) * settingsCanvas.height;
  // toggle values by vertical zones
  if(v < 90){ uiSettings.moveSpeed = Math.min(12, uiSettings.moveSpeed + 0.5); }
  else if(v < 140){ uiSettings.maxKekkaiSize = Math.min(12, uiSettings.maxKekkaiSize + 1); }
  else { uiSettings.stickSensitivity = Math.min(2.0, uiSettings.stickSensitivity + 0.05); }
  saveSettings(); redrawSettings(); settingsTex.needsUpdate = true;
}

/* 簡易 UI 設定保存 */
const uiSettings = { moveSpeed: 6.0, maxKekkaiSize: 6, stickSensitivity: 1.0 };
function saveSettings(){ try{ localStorage.setItem('kekkai_uiSettings', JSON.stringify(uiSettings)); }catch(e){} }
function loadSettings(){ try{ const s = localStorage.getItem('kekkai_uiSettings'); if(s){ Object.assign(uiSettings, JSON.parse(s)); } }catch(e){} }
loadSettings(); redrawSettings(); settingsTex.needsUpdate = true;

/* Motion-based drawing logic:
   - When controller gamepad.buttons[0] (trigger) is pressed -> start drawing
   - While pressed, track controller velocity (world) -> map to (x,y,z) scale factors
   - When released, finalize
*/
function updateControllerState(dt){
  const session = renderer.xr.getSession();
  if(!session) return;
  const xrCamera = renderer.xr.getCamera(camera);
  controllers.forEach(cinfo=>{
    const inputSource = cinfo.controller.userData.inputSource;
    if(!inputSource) return;
    // get grip world position
    const grip = cinfo.grip;
    const worldPos = new THREE.Vector3();
    grip.getWorldPosition(worldPos);
    // velocity approx
    cinfo.vel.copy(worldPos).sub(cinfo.prevPos).divideScalar(Math.max(dt, 1e-6));
    cinfo.prevPos.copy(worldPos);
    // handle gamepad if present
    const gp = inputSource.gamepad;
    if(gp){
      const btnPressed = gp.buttons[0] && gp.buttons[0].pressed;
      // start drawing
      if(btnPressed && !cinfo.drawing){
        cinfo.drawing = true;
        // start ghost at forward of controller
        startDrawingAt(worldPos);
        cinfo.ghost = ghost;
      }
      // while pressed -> update ghost scale based on velocity and controller orientation
      if(btnPressed && cinfo.drawing){
        // compute intention vector: use absolute velocities in local controller axes
        // transform world velocity into controller local space
        const invMat = new THREE.Matrix4().copy(cinfo.grip.matrixWorld).invert();
        const localVel = cinfo.vel.clone().applyMatrix4(invMat); // approximate
        // map localVel.x (right) -> width, localVel.y (up) -> height, localVel.z (forward) -> depth
        // use sign and magnitude to produce scale multipliers
        const scaleBase = 1.0;
        // magnitude influence with sensitivity and clamp
        const sX = 1 + Math.abs(localVel.x) * 0.12 * uiSettings.stickSensitivity;
        const sY = 1 + Math.abs(localVel.y) * 0.12 * uiSettings.stickSensitivity;
        const sZ = 1 + Math.abs(localVel.z) * 0.12 * uiSettings.stickSensitivity;
        // combine for diagonal when multiple axes large
        const combined = new THREE.Vector3(sX, sY, sZ);
        // limit by maxKekkaiSize
        combined.x = Math.min(uiSettings.maxKekkaiSize, combined.x);
        combined.y = Math.min(uiSettings.maxKekkaiSize, combined.y);
        combined.z = Math.min(uiSettings.maxKekkaiSize, combined.z);
        updateGhostByVector(combined);
      }
      // release -> finalize
      if(!btnPressed && cinfo.drawing){
        cinfo.drawing = false;
        finalizeDrawingAt();
        cinfo.ghost = null;
      }

      // thumbstick -> movement (assume axes[2]/[3] or axes[0]/[1] depending on controller)
      // try axes [0,1] as primary stick
      const axes = gp.axes || [];
      if(axes.length >= 2){
        // left controller typically index 0, right 1 but we don't assume — handle both: combine
        // we use left stick (controller index 0) as movement; get from controllers[0] typically
      }
    }
  });
}

/* 移動：Gamepadスティック対応（VR） */
function handleXRMovement(){
  const session = renderer.xr.getSession();
  if(!session) return;
  // prefer left-handed controller for movement (controller index 0)
  const left = controllers[0];
  if(!left) return;
  const src = left.controller.userData.inputSource;
  if(!src || !src.gamepad) return;
  const gp = src.gamepad;
  const ax0 = gp.axes[2] !== undefined ? gp.axes[2] : gp.axes[0]; // axis mapping varies
  const ax1 = gp.axes[3] !== undefined ? gp.axes[3] : gp.axes[1];
  const lx = ax0 || 0; const ly = ax1 || 0;
  // deadzone
  const dz = 0.18;
  let moveX = Math.abs(lx) > dz ? lx : 0;
  let moveY = Math.abs(ly) > dz ? ly : 0;
  // convert to world movement relative to camera forward but preserve facing (do not rotate playerGroup)
  if(moveX !== 0 || moveY !== 0){
    const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
    const theta = Math.atan2(dir.x, dir.z);
    // forward/back along theta, left/right perpendicular
    let vx = 0, vz = 0;
    // forward uses -moveY (thumbstick up is negative on many controllers)
    vx += -moveY * Math.sin(theta) * uiSettings.moveSpeed;
    vz += -moveY * Math.cos(theta) * uiSettings.moveSpeed;
    vx += moveX * Math.sin(theta + Math.PI/2) * uiSettings.moveSpeed;
    vz += moveX * Math.cos(theta + Math.PI/2) * uiSettings.moveSpeed;
    // apply to playerBody velocity but do not rotate view
    playerBody.velocity.x = vx;
    playerBody.velocity.z = vz;
  } else {
    // slight damping
    playerBody.velocity.x *= 0.88; playerBody.velocity.z *= 0.88;
  }
}

/* XR UI Raycast & Trigger click detection */
function xrUIPointerTest(){
  const session = renderer.xr.getSession();
  if(!session) return;
  controllers.forEach(cinfo=>{
    const src = cinfo.controller.userData.inputSource;
    if(!src) return;
    const gp = src.gamepad;
    if(!gp) return;
    // Ray from controller forward
    const origin = new THREE.Vector3(), dir = new THREE.Vector3(0,0,-1);
    cinfo.controller.getWorldPosition(origin);
    cinfo.controller.getWorldDirection(dir);
    xrRay.set(origin, dir);
    const intersects = xrRay.intersectObject(settingsMesh);
    if(intersects.length > 0){
      // if trigger pressed this frame -> click
      if(gp.buttons[0] && gp.buttons[0].pressed && !cinfo._uiPressed){
        cinfo._uiPressed = true;
        handleXRUIPress(intersects[0].point);
      } else if(!(gp.buttons[0] && gp.buttons[0].pressed)){
        cinfo._uiPressed = false;
      }
    }
  });
}

/* ===========================
   メインループ
   =========================== */
const clock = new THREE.Clock();
renderer.setAnimationLoop(()=>{
  const dt = Math.min(clock.getDelta(), 0.1);
  world.step(1/60, dt, 5);

  // XR controller updates (movement + drawing)
  updateControllerState(dt);
  handleXRMovement();
  xrUIPointerTest();

  // traditional mobile moveState (if any)
  const speed = uiSettings.moveSpeed;
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  const theta = Math.atan2(dir.x, dir.z);
  let vx=0, vz=0;
  if(moveState.fwd){ vx += Math.sin(theta); vz += Math.cos(theta); }
  if(moveState.back){ vx -= Math.sin(theta); vz -= Math.cos(theta); }
  if(moveState.left){ vx += Math.sin(theta + Math.PI/2); vz += Math.cos(theta + Math.PI/2); }
  if(moveState.right){ vx += Math.sin(theta - Math.PI/2); vz += Math.cos(theta - Math.PI/2); }
  if((vx!==0 || vz!==0) && !renderer.xr.isPresenting){
    playerBody.velocity.x = vx * speed;
    playerBody.velocity.z = vz * speed;
  } else if(!renderer.xr.isPresenting){
    playerBody.velocity.x *= 0.88; playerBody.velocity.z *= 0.88;
  }

  // jump
  if(wantsJump){ if(Math.abs(playerBody.velocity.y) < 0.2) playerBody.velocity.y = 8; wantsJump=false; }

  // sync playerGroup to physics body
  playerGroup.position.set(playerBody.position.x, playerBody.position.y, playerBody.position.z);
  camera.position.set(0, 0.6, 0);

  // sync kekkai visuals
  kekkaiList.forEach(k => { k.mesh.position.copy(k.body.position); k.mesh.quaternion.copy(k.body.quaternion); });

  updateEnemies(dt);
  renderer.render(scene, camera);
});

/* ===========================
   VR セッション開始/終了ハンドラ
   =========================== */
const vrBtn = document.getElementById('vrToggle');
vrBtn.addEventListener('click', async ()=>{
  if(!isVRMode && navigator.xr){
    try{
      const s = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor','bounded-floor','hand-tracking'] });
      renderer.xr.setSession(s);
      isVRMode = true; document.getElementById('mobileUI').style.display = 'none'; document.getElementById('hint').textContent = 'VR: トリガーで結界作成、スティックで移動、設定は目の前のパネルで調整';
      s.addEventListener('end', ()=>{ isVRMode = false; document.getElementById('mobileUI').style.display='flex'; document.getElementById('hint').textContent = 'コントローラ：トリガーで結界作成・スティックで移動（Quest）'; });
    } catch(e){ console.warn(e); pulseHUD('VR開始に失敗しました', '#f44'); }
  } else {
    try{ const sess = renderer.xr.getSession(); if(sess) await sess.end(); }catch(e){}
  }
});

/* ===========================
   初期スポーン等
   =========================== */
for(let i=0;i<3;i++) spawnEnemyByWave();
updateCounts();

/* ウィンドウリサイズ */
window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

/* ===========================
   補助（スマホドラッグで ghost shape 変更）
   =========================== */
let drawStartTouch = null;
function startDrawing(){
  if(kekkaiList.length >= KEKKAI_LIMIT){ pulseHUD("結界数が上限です", "#f44"); return; }
  isDrawing = true; document.getElementById('btnDraw').classList.add('drawing');
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  const dist = (drawDistanceMode==="NEAR") ? DIST_NEAR : DIST_FAR;
  const pos = new THREE.Vector3(playerBody.position.x, playerBody.position.y, playerBody.position.z).add(dir.multiplyScalar(dist));
  if(pos.y < 1.0) pos.y = 1.0;
  ghost = new THREE.Mesh(ghostGeo, ghostMat);
  ghost.position.copy(pos);
  scene.add(ghost);
}
function updateGhostShape(touchX, touchY){
  if(!ghost || !drawStartTouch) return;
  const S = 18;
  const dx = (touchX - drawStartTouch.x)/S;
  const dy = (drawStartTouch.y - touchY)/S;
  const sX = Math.max(0.8, 1 + dx);
  const sY = Math.max(0.8, 1 + dy);
  ghost.scale.set(sX, sY, sX);
}
function finalizeDrawing(){ if(!ghost) return; const pos = ghost.position.clone(); const size = ghost.scale.clone(); scene.remove(ghost); ghost = null; isDrawing=false; document.getElementById('btnDraw').classList.remove('drawing'); createKekkai(pos, size); }

/* ===========================
   設定の永続化 / その他
   =========================== */
function saveSettingsAndNotify(){ saveSettings(); pulseHUD("設定を保存しました", "#0f8"); }
window.addEventListener('keydown', (e)=>{ if(e.key === 's') saveSettingsAndNotify(); });

/* ===========================
   最後の補助関数
   =========================== */
function spawnKanjiAndLog(text, pos, color){ spawnKanji(text, pos, color); console.log('kanji',text,pos); }

/* ===========================
   小さなヘルプ：ボタンでの設定変更（モバイル用）
   =========================== */
document.getElementById('btnRange').addEventListener('click', toggleRange);

/* ===========================
   保存したらリロードして即反映
   =========================== */
saveSettings();
</script>
</body>
</html>
