<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>VR Kekkai Sim - Final Fix</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';
    import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

    // ==========================================
    // グローバル変数
    // ==========================================
    let camera, scene, renderer;
    let controller1, controller2;
    let controllerGrip1, controllerGrip2;
    
    // プレイヤー設定
    const playerState = {
        moveSpeed: 3.0,          // 移動速度
        rotationSpeed: 2.0,      // 回転速度
        distanceMode: 'far',     // ターゲット距離モード
        userGroup: null          // カメラの親グループ（移動用）
    };

    // オブジェクト管理
    const barriers = [];    // 作成済み結界
    const enemies = [];     // 敵
    const effects = [];     // エフェクト
    
    // 生成中の結界データ
    let activeBarrier = null; 

    // ★修正③: 感度を30倍に設定（ベース値150 * 30）
    const BARRIER_SENSITIVITY = 150.0 * 30.0; 

    // ターゲットポイント（赤い点）
    let targetPointMesh;
    const targetDistanceFar = 10.0;
    const targetDistanceNear = 2.0;

    // フォント用キャンバス
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    // ==========================================
    // 初期化
    // ==========================================
    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x111111, 0, 80);

        // カメラ設定（VR時はHMDの位置に上書きされるが、初期位置として）
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        
        // プレイヤー移動用グループ
        const userGroup = new THREE.Group();
        userGroup.position.set(0, 0, 0); 
        userGroup.add(camera);
        scene.add(userGroup);
        playerState.userGroup = userGroup;

        // ライティング
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(0, 10, 0);
        scene.add(directionalLight);

        // 床（地面）
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x333333, 
            roughness: 0.8,
            side: THREE.DoubleSide
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // ターゲットポインター（赤い点）
        const pointGeo = new THREE.SphereGeometry(0.05, 16, 16);
        const pointMat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.8 });
        targetPointMesh = new THREE.Mesh(pointGeo, pointMat);
        scene.add(targetPointMesh);

        // ★修正④: 敵（テスト用）の配置
        // ConeGeometry(半径0.5, 高さ1.5) の中心は高さの半分(0.75)にあるため
        // y=0.75 に置くことで底面が y=0（地面）に接します。
        createTestEnemy(0, 0.75, -5);
        createTestEnemy(3, 0.75, -8);
        createTestEnemy(-3, 0.75, -8);

        // レンダラー設定
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        document.body.appendChild(VRButton.createButton(renderer));

        // コントローラーセットアップ
        setupControllers();

        window.addEventListener('resize', onWindowResize);
    }

    function setupControllers() {
        // 右手・左手の判定は接続順やブラウザによるが、inputSource.handednessで判定して処理する
        controller1 = renderer.xr.getController(0);
        controller1.addEventListener('selectstart', onSelectStart); // トリガー
        controller1.addEventListener('squeeze', onSqueezeStart);    // グリップ開始
        controller1.addEventListener('squeezeend', onSqueezeEnd);   // グリップ終了
        scene.add(controller1);

        controller2 = renderer.xr.getController(1);
        controller2.addEventListener('selectstart', onSelectStart);
        controller2.addEventListener('squeeze', onSqueezeStart);
        controller2.addEventListener('squeezeend', onSqueezeEnd);
        scene.add(controller2);

        // コントローラーの見た目（3Dモデル）
        const controllerModelFactory = new XRControllerModelFactory();
        controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        scene.add(controllerGrip1);

        controllerGrip2 = renderer.xr.getControllerGrip(1);
        controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
        scene.add(controllerGrip2);
    }

    // ==========================================
    // 入力イベント
    // ==========================================
    
    // トリガー: アクション実行 (解/滅)
    function onSelectStart(event) {
        const controller = event.target;
        const inputSource = controller.inputSource;
        if (!inputSource) return;

        const handedness = inputSource.handedness;

        if (handedness === 'left') {
            // 左トリガー: 解
            removeNearestBarrier();
            showTextEffect("解", targetPointMesh.position, 0x00ffff);
        } else if (handedness === 'right') {
            // 右トリガー: 滅
            destroyBarrierAction();
            showTextEffect("滅", targetPointMesh.position, 0xff0000);
        }
    }

    // グリップ: 結界生成開始
    function onSqueezeStart(event) {
        const controller = event.target;
        const inputSource = controller.inputSource;
        if (!inputSource) return;

        // 既に生成中なら無視
        if (activeBarrier) return;

        const type = (inputSource.handedness === 'left') ? 'solid' : 'ghost'; // 左=青, 右=緑
        
        // 結界初期化
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshStandardMaterial({
            color: type === 'solid' ? 0x0088ff : 0x00ff88,
            transparent: true,
            opacity: 0.5,
            roughness: 0.1,
            metalness: 0.1,
            side: THREE.DoubleSide
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.copy(targetPointMesh.position);
        mesh.scale.set(0.1, 0.1, 0.1); // 極小からスタート
        scene.add(mesh);

        activeBarrier = {
            mesh: mesh,
            controller: controller,
            startControllerPos: controller.position.clone(), // 開始位置記録
        };
    }

    // グリップ離す: 生成完了
    function onSqueezeEnd(event) {
        if (activeBarrier && activeBarrier.controller === event.target) {
            barriers.push(activeBarrier.mesh);
            activeBarrier = null;
        }
    }

    // ==========================================
    // メインループ
    // ==========================================
    function animate() {
        renderer.setAnimationLoop(render);
    }

    function render() {
        const dt = 0.016; // 固定デルタタイム
        
        handleInput(dt);
        updateActiveBarrier();
        updateEffects(dt);
        updateTargetPoint();

        renderer.render(scene, camera);
    }

    // ==========================================
    // 各種更新ロジック
    // ==========================================

    function handleInput(dt) {
        const session = renderer.xr.getSession();
        if (!session) return;

        let inputSources = session.inputSources;
        const moveVector = new THREE.Vector3(0, 0, 0);

        // カメラ方向（Y軸回転のみ）
        const cameraDirection = new THREE.Vector3();
        camera.getWorldDirection(cameraDirection);
        cameraDirection.y = 0;
        cameraDirection.normalize();

        const cameraRight = new THREE.Vector3();
        cameraRight.crossVectors(cameraDirection, new THREE.Vector3(0, 1, 0));

        for (const source of inputSources) {
            if (!source.gamepad) continue;
            const gp = source.gamepad;
            const handedness = source.handedness;

            // --- 左手: 移動 ---
            if (handedness === 'left' && gp.axes.length >= 4) {
                // Quest等: axes[2]=X, axes[3]=Y
                
                // ★修正①: 左右移動の反転
                // 元の値が左(-1)～右(+1)なので、マイナスを付けて反転させる
                const inputX = -gp.axes[2]; 
                const inputY = gp.axes[3]; 

                // 前後
                if (Math.abs(inputY) > 0.1) {
                    moveVector.addScaledVector(cameraDirection, inputY * playerState.moveSpeed * dt);
                }
                // 左右
                if (Math.abs(inputX) > 0.1) {
                    moveVector.addScaledVector(cameraRight, inputX * playerState.moveSpeed * dt);
                }
            }

            // --- 右手: 回転・その他 ---
            if (handedness === 'right' && gp.axes.length >= 4) {
                const rotX = gp.axes[2];
                // 視点回転
                if (Math.abs(rotX) > 0.2) {
                    playerState.userGroup.rotation.y -= rotX * playerState.rotationSpeed * dt;
                }
                
                // Bボタン(通常[5])で距離切り替え
                if (gp.buttons[5] && gp.buttons[5].pressed) {
                    if (!playerState.bButtonWasPressed) {
                        playerState.distanceMode = (playerState.distanceMode === 'near') ? 'far' : 'near';
                        playerState.bButtonWasPressed = true;
                    }
                } else {
                    playerState.bButtonWasPressed = false;
                }
            }
        }

        playerState.userGroup.position.add(moveVector);
    }

    function updateTargetPoint() {
        const dist = (playerState.distanceMode === 'near') ? targetDistanceNear : targetDistanceFar;
        
        const dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        dir.normalize();

        const targetPos = new THREE.Vector3();
        targetPos.copy(camera.position).addScaledVector(dir, dist);
        
        // 地面より下にめり込まないように補正
        if (targetPos.y < 0.05) targetPos.y = 0.05;

        targetPointMesh.position.copy(targetPos);
    }

    function updateActiveBarrier() {
        if (!activeBarrier) return;

        const controller = activeBarrier.controller;
        const currentPos = controller.position.clone();
        
        // 手の移動量
        const diff = new THREE.Vector3().subVectors(currentPos, activeBarrier.startControllerPos);

        // ★修正③: 感度30倍 (BARRIER_SENSITIVITY使用)
        // 手の移動量(diff)に応じてスケールを加算
        const scaleX = 1.0 + Math.abs(diff.x) * BARRIER_SENSITIVITY;
        const scaleY = 1.0 + Math.abs(diff.y) * BARRIER_SENSITIVITY;
        const scaleZ = 1.0 + Math.abs(diff.z) * BARRIER_SENSITIVITY;

        activeBarrier.mesh.scale.set(scaleX, scaleY, scaleZ);
    }

    function updateEffects(dt) {
        for (let i = effects.length - 1; i >= 0; i--) {
            const fx = effects[i];
            fx.life -= dt;
            
            if (fx.type === 'text') {
                fx.mesh.position.y += dt * 1.0; // 上昇速度少しアップ
                fx.mesh.lookAt(camera.position);
            } else if (fx.type === 'shard') {
                fx.mesh.position.addScaledVector(fx.velocity, dt);
                fx.mesh.rotation.x += fx.rotationSpeed.x;
                fx.mesh.rotation.y += fx.rotationSpeed.y;
            }

            // フェードアウト
            if (fx.life < 0.2) {
                fx.mesh.material.opacity = fx.life / 0.2;
            }

            if (fx.life <= 0) {
                scene.remove(fx.mesh);
                if (fx.mesh.geometry) fx.mesh.geometry.dispose();
                if (fx.mesh.material) fx.mesh.material.dispose();
                effects.splice(i, 1);
            }
        }
    }

    // ==========================================
    // アクション・エフェクト
    // ==========================================

    function createTestEnemy(x, y, z) {
        // 高さ1.5, 半径0.5のコーン
        const geo = new THREE.ConeGeometry(0.5, 1.5, 16);
        const mat = new THREE.MeshStandardMaterial({ color: 0xff00ff }); // 紫
        const enemy = new THREE.Mesh(geo, mat);
        enemy.position.set(x, y, z);
        scene.add(enemy);
        enemies.push(enemy);
    }

    function removeNearestBarrier() {
        if (barriers.length === 0) return;
        let nearest = null;
        let minDist = Infinity;
        const pos = targetPointMesh.position;

        barriers.forEach(b => {
            const d = b.position.distanceTo(pos);
            if (d < minDist) {
                minDist = d;
                nearest = b;
            }
        });

        // 判定距離を少し甘めに設定
        if (nearest && minDist < 8.0) {
            createDebris(nearest.position, nearest.scale, nearest.material.color);
            scene.remove(nearest);
            barriers.splice(barriers.indexOf(nearest), 1);
        }
    }

    function destroyBarrierAction() {
        if (barriers.length === 0) return;
        let targetBarrier = null;
        let minDist = Infinity;
        const targetPos = targetPointMesh.position;

        for (const b of barriers) {
            const d = b.position.distanceTo(targetPos);
            if (d < minDist) {
                minDist = d;
                targetBarrier = b;
            }
        }

        if (targetBarrier && minDist < 8.0) {
            const box = new THREE.Box3().setFromObject(targetBarrier);
            
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                if (box.containsPoint(enemy.position)) {
                    createDebris(enemy.position, new THREE.Vector3(1,1,1), 0xff00ff, 15);
                    scene.remove(enemy);
                    enemies.splice(i, 1);
                }
            }
            
            createDebris(targetBarrier.position, targetBarrier.scale, 0xff0000, 20);
            scene.remove(targetBarrier);
            barriers.splice(barriers.indexOf(targetBarrier), 1);
        }
    }

    function showTextEffect(text, position, colorHex) {
        const size = 256;
        canvas.width = size;
        canvas.height = size;
        context.clearRect(0, 0, size, size);
        context.fillStyle = '#' + new THREE.Color(colorHex).getHexString();
        context.font = 'bold 200px Arial';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillText(text, size/2, size/2);

        const texture = new THREE.CanvasTexture(canvas);
        const mat = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(mat);
        
        sprite.position.copy(position);
        sprite.scale.set(2, 2, 2);
        scene.add(sprite);

        effects.push({
            type: 'text',
            mesh: sprite,
            // ★修正②: 寿命を短縮(0.4秒)
            life: 0.4
        });
    }

    function createDebris(pos, scale, color, count = 10) {
        const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true });

        for(let i=0; i<count; i++) {
            const mesh = new THREE.Mesh(geo, mat);
            // 結界サイズ内に分散
            mesh.position.set(
                pos.x + (Math.random() - 0.5) * scale.x,
                pos.y + (Math.random() - 0.5) * scale.y,
                pos.z + (Math.random() - 0.5) * scale.z
            );
            
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 15,
                (Math.random() - 0.5) * 15,
                (Math.random() - 0.5) * 15
            );

            scene.add(mesh);
            effects.push({
                type: 'shard',
                mesh: mesh,
                velocity: velocity,
                rotationSpeed: { x: Math.random(), y: Math.random() },
                // ★修正②: 寿命を短縮(0.4秒)
                life: 0.4
            });
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>
