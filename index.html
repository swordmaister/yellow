<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>真・結界師VR — v7.0 Head-Aim & Physics</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover, user-scalable=no">
<meta name="theme-color" content="#87CEEB">
<style>
  html, body { height: 100%; margin: 0; background: #87CEEB; color: #fff; font-family: sans-serif; overflow: hidden; touch-action: none; user-select: none; -webkit-user-select: none; }
  canvas { display: block; width: 100%; height: 100%; outline: none; }
  #error-log { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); color:#ff5555; padding:20px; z-index:9999; white-space:pre-wrap; font-weight:bold; overflow:auto; }
  #damage-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, transparent 60%, red 100%); opacity: 0; pointer-events: none; z-index: 50; transition: opacity 0.1s; }
  .novr-only { transition: opacity 0.5s; }
  #hud { position: fixed; top: 16px; left: 16px; pointer-events: none; z-index: 10; }
  @supports (padding-top: env(safe-area-inset-top)) { #hud { top: calc(env(safe-area-inset-top) + 10px); left: calc(env(safe-area-inset-left) + 16px); } }
  .hud-box { background: rgba(0, 30, 60, 0.6); padding: 8px 16px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.4); margin-bottom: 8px; backdrop-filter: blur(4px); min-width: 140px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
  .big-text { font-size: 18px; font-weight: bold; color: #ffeb3b; text-shadow: 1px 1px 2px #000; }
  .sub-text { font-size: 14px; color: #fff; text-shadow: 1px 1px 1px #000; }
  .hp-bar-bg { width: 100%; height: 8px; background: #555; margin-top: 4px; border-radius: 4px; overflow: hidden; }
  .hp-bar-val { width: 100%; height: 100%; background: #0f0; transition: width 0.2s; }
  #msgArea { position: fixed; top: 35%; left: 0; width: 100%; text-align: center; pointer-events: none; z-index: 20; }
  .flash-msg { font-size: 60px; font-weight: 900; color: #fff; text-shadow: 0 0 20px #f0a, 3px 3px 0 #000; opacity: 0; transition: opacity 0.1s; transform: scale(0.8); }
  #uiLayer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
  #stickZone { position: absolute; bottom: 30px; left: 30px; width: 140px; height: 140px; pointer-events: auto; margin-bottom: env(safe-area-inset-bottom); margin-left: env(safe-area-inset-left); }
  .stick-base { width: 100%; height: 100%; background: rgba(255,255,255,0.2); border: 2px solid rgba(255,255,255,0.5); border-radius: 50%; position: relative; }
  .stick-knob { width: 60px; height: 60px; background: #fff; border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 4px 10px rgba(0,0,0,0.3); pointer-events: none; }
  #padArea { position: absolute; bottom: 30px; right: 30px; width: 180px; height: 180px; pointer-events: none; margin-bottom: env(safe-area-inset-bottom); margin-right: env(safe-area-inset-right); }
  .btn { position: absolute; width: 65px; height: 65px; z-index: 10; border-radius: 50%; border: 2px solid rgba(255,255,255,0.6); background: rgba(40,50,80,0.8); color: #fff; display: flex; flex-direction: column; align-items: center; justify-content: center; font-weight: bold; font-size: 12px; pointer-events: auto; touch-action: manipulation; transition: transform 0.1s; }
  .btn:active { transform: scale(0.9); background: rgba(60,70,100,0.9); }
  #btnUp { top: 0; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #607d8b, #455a64); }
  #btnDown { bottom: 0; left: 50%; transform: translateX(-50%); background: linear-gradient(135deg, #9c27b0, #7b1fa2); width: 75px; height: 75px; font-size: 16px; }
  #btnLeft { top: 50%; left: 0; transform: translateY(-50%); background: linear-gradient(135deg, #f44336, #c62828); }
  #btnRight { top: 50%; right: 0; transform: translateY(-50%); background: linear-gradient(135deg, #03a9f4, #0288d1); width: 75px; height: 75px; font-size: 18px; }
  #btnRight.drawing { background: #fff; color: #0288d1; transform: translateY(-50%) scale(1.1); }
  #modeSwitch { position: absolute; top: -60px; right: 0; width: 140px; height: 40px; background: rgba(0,0,0,0.6); border: 2px solid #fff; border-radius: 20px; display:flex; align-items:center; justify-content:center; font-size:12px; font-weight:bold; pointer-events:auto; transition: background 0.3s; }
  #modeSwitch.phys { background: linear-gradient(90deg, #FFD700, #FF8C00); color:#000; border-color:#fff; }
  #modeSwitch.ghost { background: linear-gradient(90deg, #00bfff, #0000ff); color:#fff; border-color:#00ffff; }
  @media (orientation: portrait) {
    #stickZone { width: 110px; height: 110px; bottom: 20px; left: 10px; } .stick-knob { width: 45px; height: 45px; }
    #padArea { width: 150px; height: 150px; bottom: 20px; right: 10px; } .btn { width: 50px; height: 50px; font-size: 10px; }
    #btnDown, #btnRight { width: 55px; height: 55px; }
  }
  #centerReticle { position: fixed; top: 50%; left: 50%; width: 6px; height: 6px; background: rgba(255,255,255,0.8); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; border: 1px solid rgba(0,0,0,0.5); }
  #vrBtn { position: fixed; top: 10px; right: 10px; padding: 12px 24px; background: rgba(0,0,0,0.8); border: 2px solid #0f0; color: #0f0; border-radius: 8px; z-index: 200; pointer-events: auto; font-weight: bold; cursor: pointer; font-size: 16px; box-shadow: 0 0 10px #0f0; }
</style>
<script>
  window.onerror = function(msg, url, line) {
    const box = document.getElementById('error-log'); box.style.display = 'block';
    box.textContent += "Error: " + msg + "\nLine: " + line + "\n"; return false;
  };
</script>
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
</head>
<body>

<div id="error-log"></div>
<div id="damage-overlay"></div>
<div id="hud" class="novr-only">
  <div class="hud-box"><span class="big-text" id="waveVal">WAVE 1</span><br><span class="sub-text">撃破: <span id="killVal">0</span> / 残: <span id="targetVal" style="color:#f88;">3</span></span></div>
  <div class="hud-box"><span class="sub-text">HP: <span id="hpText">100</span></span><div class="hp-bar-bg"><div id="hpBar" class="hp-bar-val"></div></div></div>
  <div class="hud-box" id="vipBox" style="display:none; border-color:#0f0;"><span class="sub-text" style="color:#0f0;">護衛対象 (脱出中)</span><div class="hp-bar-bg"><div id="vipHpBar" class="hp-bar-val" style="background:#0ff;"></div></div></div>
</div>
<div id="msgArea"><div id="flashMsg" class="flash-msg"></div></div>
<div id="centerReticle" class="novr-only"></div>
<button id="vrBtn">VR START</button>
<div id="uiLayer" class="novr-only">
  <div id="stickZone"><div class="stick-base"><div id="stickKnob" class="stick-knob"></div></div></div>
  <div id="padArea">
    <div id="modeSwitch" class="ghost">モード: 幽体</div>
    <div id="btnUp" class="btn">距離<br><span id="distLabel" style="color:#fe0">近</span></div>
    <div id="btnLeft" class="btn">滅<br><span style="font-size:10px">⇔解</span></div>
    <div id="btnRight" class="btn">結<br><span style="font-size:10px">Hold</span></div>
    <div id="btnDown" class="btn">跳</div>
  </div>
</div>

<script type="module">
import * as THREE from 'three'; 
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js'; 
import * as CANNON from 'cannon-es';

// --- CONFIGURATION ---
const CFG = {
  colors: {
    sky: 0x87CEEB, ground: 0xC2B280, 
    kekkai: 0xffff00, ghost: 0x00ffff, 
    drawPhys: 0xffff00, drawGhost: 0x00ffff,
    marker: 0xff0000,
    wall: 0xa0a0a0, building: 0xf0f0f0, pool: 0x88cccc,
    enemy: 0xff4444, giant: 0x880000, item: 0x00ff00, vip: 0x0000ff,
    wood: 0x8B4513, leaf: 0x228B22, iron: 0x333333, concrete: 0xaaaaaa
  },
  player: { speed: 12.0, jump: 22.0, height: 1.7, maxHp: 100 },
  kekkai: { max: 5, sensitivity: 80.0 }, 
  dist: { near: 8.0, far: 20.0 },
  field: { width: 120, depth: 160 }
};

// --- COLLISION GROUPS ---
const G_GROUND = 1;
const G_PLAYER = 2;
const G_ENEMY = 4;
const G_PHYS_KEKKAI = 8;
const G_GHOST_KEKKAI = 16;
const G_VIP = 32;

// --- GLOBAL VARIABLES ---
let scene, camera, renderer, world;
let playerBody, playerGroup;
let enemies = [], kekkaiList = [], items = [], vip = null;
let gameState = { wave: 1, kills: 0, req: 3, nextSpawn: 0, playerHp: 100, isVipMode: false };
let currentDist = CFG.dist.near, aimMarker, isPhysMode = false;
let controllers = [], controllerGrips = [], vrHudMesh, vrHudCtx, vipGoalMesh = null;
let lastT = 0;
let currentSession = null;

let vrState = { 
  left: { drawing: false, startHandPos: new THREE.Vector3(), mesh: null, triggerHeld: false, physBody: null }, 
  right: { drawing: false, startHandPos: new THREE.Vector3(), mesh: null, triggerHeld: false, metsuLock: false, bLock: false, physBody: null }, 
  snapTurn: false, barrierOrigin: new THREE.Vector3() 
};

let input = { x: 0, y: 0 }, camAngle = { yaw: 0, pitch: 0 };
let drawId = null, drawState = { active: false, startX: 0, startY: 0, ghost: null }, activePhysKekkai = null; 
let stickId = null, stickStart = { x: 0, y: 0 }, tapTime = 0, tapPos = { x: 0, y: 0 };
let actId = null, actStartPos = { x: 0, y: 0 }, lookId = null, lastLook = { x: 0, y: 0 };

const els = { 
  stick: document.getElementById('stickZone'), knob: document.getElementById('stickKnob'), 
  msg: document.getElementById('flashMsg'), btnDist: document.getElementById('btnUp'), 
  btnJump: document.getElementById('btnDown'), btnAct: document.getElementById('btnLeft'), 
  btnDraw: document.getElementById('btnRight'), modeBtn: document.getElementById('modeSwitch'), 
  distLabel: document.getElementById('distLabel'), wVal: document.getElementById('waveVal'), 
  kVal: document.getElementById('killVal'), tVal: document.getElementById('targetVal'), 
  hpText: document.getElementById('hpText'), hpBar: document.getElementById('hpBar'), 
  dmgOverlay: document.getElementById('damage-overlay'), vipBox: document.getElementById('vipBox'), 
  vipHpBar: document.getElementById('vipHpBar'), novr: document.querySelectorAll('.novr-only') 
};

// --- UTILITY FUNCTIONS ---
function showMsg(t, c) { 
  els.msg.textContent = t; els.msg.style.color = c; els.msg.style.opacity = 1; 
  setTimeout(() => els.msg.style.opacity = 0, 300); 
}

function spawnText(s, p, c) { 
  const cvs = document.createElement('canvas'); cvs.width = 128; cvs.height = 64; 
  const ctx = cvs.getContext('2d'); ctx.font = "bold 48px sans-serif"; ctx.fillStyle = c; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(s, 64, 32); 
  const sp = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(cvs), transparent: true })); 
  sp.position.copy(p); sp.scale.set(3, 1.5, 3); scene.add(sp); 
  let f = 0; 
  const a = () => { f += 0.15; sp.position.y += 0.05; sp.material.opacity = 1 - f; if (f < 1) requestAnimationFrame(a); else { scene.remove(sp); sp.material.map.dispose(); } }; 
  a(); 
}

function spawnParticle(p, n, c) { 
  const g = new THREE.BoxGeometry(0.25, 0.25, 0.25), m = new THREE.MeshBasicMaterial({ color: c }); 
  for (let i = 0; i < n; i++) { 
    const me = new THREE.Mesh(g, m); me.position.copy(p).add(new THREE.Vector3((Math.random() - .5) * 2, (Math.random() - .5) * 2, (Math.random() - .5) * 2)); scene.add(me); 
    const v = new THREE.Vector3(Math.random() - .5, Math.random() - .5, Math.random() - .5).multiplyScalar(1.5); 
    const a = () => { me.position.add(v); me.scale.multiplyScalar(0.85); if (me.scale.x > 0.05) requestAnimationFrame(a); else scene.remove(me); }; 
    a(); 
  } 
}

function safeRemoveMesh(mesh) { 
  if(!mesh) return; scene.remove(mesh); 
  if(mesh.geometry) mesh.geometry.dispose(); 
  if(mesh.material) { if(Array.isArray(mesh.material)) mesh.material.forEach(m => m.dispose()); else mesh.material.dispose(); } 
  if(mesh.children) { mesh.children.forEach(c => { if(c.geometry) c.geometry.dispose(); if(c.material) c.material.dispose(); }); } 
}

function updateHUD() { 
  if (renderer.xr.isPresenting && vrHudCtx) { 
    const ctx = vrHudCtx; ctx.clearRect(0, 0, 512, 128); 
    ctx.fillStyle = "rgba(0, 20, 40, 0.4)"; ctx.fillRect(100,50,312,50); 
    ctx.font = "bold 24px sans-serif"; ctx.fillStyle = "#fff"; ctx.textAlign="center"; 
    ctx.fillText(`W: ${gameState.wave}  K: ${gameState.kills}/${gameState.req}  HP: ${gameState.playerHp}`, 256, 82); 
    if (gameState.isVipMode && vip) { ctx.fillStyle = "#0ff"; ctx.fillText(`VIP: ${vip.hp}%`, 256, 30); } 
    vrHudMesh.material.map.needsUpdate = true; 
  } else { 
    els.wVal.textContent = gameState.wave; els.kVal.textContent = gameState.kills; els.tVal.textContent = gameState.req; 
  } 
}

function takeDamage(val) { 
  gameState.playerHp = Math.max(0, gameState.playerHp - val); els.hpText.textContent = gameState.playerHp; 
  els.hpBar.style.width = (gameState.playerHp / CFG.player.maxHp * 100) + "%"; els.hpBar.style.backgroundColor = gameState.playerHp < 30 ? "#f00" : "#0f0"; 
  els.dmgOverlay.style.opacity = 0.5; setTimeout(() => els.dmgOverlay.style.opacity = 0, 150); 
  if (gameState.playerHp <= 0) showMsg("GAME OVER", "#f00"); 
}

function healPlayer(val) { gameState.playerHp = Math.min(CFG.player.maxHp, gameState.playerHp + val); els.hpText.textContent = gameState.playerHp; els.hpBar.style.width = (gameState.playerHp / CFG.player.maxHp * 100) + "%"; showMsg("RECOVER!", "#0f0"); }

function removeKekkai(k) { safeRemoveMesh(k.mesh); if(k.body) world.removeBody(k.body); kekkaiList = kekkaiList.filter(o => o !== k); updateHUD(); }

function createKekkai(p, s, r, isGhost=false) { 
  const group = isGhost ? G_GHOST_KEKKAI : G_PHYS_KEKKAI;
  const mask = G_GROUND | G_PLAYER | G_ENEMY | G_VIP | G_PHYS_KEKKAI | G_GHOST_KEKKAI;

  const b = new CANNON.Body({ mass: 0, material: new CANNON.Material('kek'), collisionFilterGroup: group, collisionFilterMask: mask }); 
  b.position.copy(p); b.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), r); 
  
  if (!isGhost) { 
    // Solid Box (Physical)
    b.addShape(new CANNON.Box(new CANNON.Vec3(s.x/2, s.y/2, s.z/2))); 
  } else { 
    // Hollow Box (Ghost) - Correctly Spaced for Player Entry
    const t = 0.2; // Thin walls
    const x = s.x/2, y = s.y/2, z = s.z/2; 
    // Left/Right
    b.addShape(new CANNON.Box(new CANNON.Vec3(t, y, z)), new CANNON.Vec3(-(x - t), 0, 0)); 
    b.addShape(new CANNON.Box(new CANNON.Vec3(t, y, z)), new CANNON.Vec3((x - t), 0, 0)); 
    // Top/Bottom
    b.addShape(new CANNON.Box(new CANNON.Vec3(x, t, z)), new CANNON.Vec3(0, -(y - t), 0)); 
    b.addShape(new CANNON.Box(new CANNON.Vec3(x, t, z)), new CANNON.Vec3(0, (y - t), 0)); 
    // Front/Back
    b.addShape(new CANNON.Box(new CANNON.Vec3(x, y, t)), new CANNON.Vec3(0, 0, -(z - t))); 
    b.addShape(new CANNON.Box(new CANNON.Vec3(x, y, t)), new CANNON.Vec3(0, 0, (z - t))); 
  } 
  world.addBody(b); 
  
  const color = isGhost ? CFG.colors.ghost : CFG.colors.kekkai; const g = new THREE.BoxGeometry(s.x, s.y, s.z); 
  const m = new THREE.MeshPhongMaterial({ color: color, transparent: true, opacity: isGhost ? 0.3 : 0.5, side: THREE.DoubleSide }); 
  const mesh = new THREE.Mesh(g, m); 
  mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }))); 
  mesh.position.copy(p); mesh.rotation.y = r; scene.add(mesh); 
  
  kekkaiList.push({ body: b, mesh: mesh, isShrinking: false, shrinkProgress: 1.0, isGhost: isGhost }); 
  spawnText("結", p, isGhost ? "#0ff" : "#ff0"); updateHUD(); 
}

function spawnItem(pos) { 
  const b = new CANNON.Body({ mass: 1, shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)), material: new CANNON.Material('item') }); b.position.copy(pos); world.addBody(b); 
  const m = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: CFG.colors.item, wireframe: true })); m.position.copy(pos); scene.add(m); 
  m.add(new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshBasicMaterial({ color: CFG.colors.item }))); 
  items.push({ body: b, mesh: m }); 
}

function removeEnemy(e) { if (!enemies.includes(e)) return; enemies = enemies.filter(o => o !== e); scene.remove(e.mesh); world.removeBody(e.body); updateHUD(); }

function killEnemy(e) { 
  if (!enemies.includes(e)) return; 
  if (e.isGiant && e.hp > 0) { e.hp--; spawnParticle(e.mesh.position, 10, 0xffaa00); const push = playerBody.position.vsub(e.body.position); push.normalize(); e.body.applyImpulse(push.scale(-500), e.body.position); if (e.hp > 0) return; } 
  removeEnemy(e); spawnParticle(e.mesh.position, 25, 0xff0000); if (Math.random() < 0.3) spawnItem(e.body.position); 
  gameState.kills++; gameState.req--; if (gameState.req <= 0) { gameState.wave++; gameState.req = gameState.wave * 2 + 4; showMsg(`WAVE ${gameState.wave}`, "#fe0"); if (gameState.wave % 3 === 0) startVipMission(); } updateHUD(); 
}

function spawnGiant(x, y, z) { 
  const b = new CANNON.Body({ mass: 100, material: new CANNON.Material('ene'), linearDamping: 0.5, collisionFilterGroup: G_ENEMY, collisionFilterMask: G_GROUND|G_PLAYER|G_PHYS_KEKKAI|G_GHOST_KEKKAI|G_VIP }); 
  b.addShape(new CANNON.Sphere(1.5), new CANNON.Vec3(0, 0, 0)); b.addShape(new CANNON.Sphere(0.8), new CANNON.Vec3(0, 2, 0)); b.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 1.5)), new CANNON.Vec3(0, 0.5, 0)); 
  b.position.set(x, y, z); world.addBody(b); b.outsideTimer = 0; 
  const g = new THREE.Group(); const bm = new THREE.Mesh(new THREE.SphereGeometry(1.5), new THREE.MeshStandardMaterial({ color: CFG.colors.giant })); g.add(bm); 
  const hm = new THREE.Mesh(new THREE.SphereGeometry(0.8), new THREE.MeshStandardMaterial({ color: 0x550000 })); hm.position.y = 2; g.add(hm); 
  const am = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 3), new THREE.MeshStandardMaterial({ color: 0x330000 })); am.position.y = 0.5; g.add(am); 
  scene.add(g); enemies.push({ body: b, mesh: g, isGiant: true, hp: 5 }); 
}

function spawnEnemy() { 
  if (enemies.length >= 6 + gameState.wave) return; 
  const r = Math.random(); let x, y, z; const fW = CFG.field.width, fD = CFG.field.depth; 
  if (r < 0.6) { x = (Math.random() - .5) * fW; z = (Math.random() - .5) * fD; y = 20; } 
  else if (r < 0.8) { x = (Math.random() - .5) * (fW - 5); z = (-fD / 2 - 20) + (Math.random() - .5) * 30; y = 35; } 
  else { x = (fW / 2 - 25) + (Math.random() - .5) * 20; z = (Math.random() - .5) * 50; y = 10; } 
  if (Math.random() < 0.2) spawnGiant(x, y, z); 
  else { 
    const sz = 0.6 + Math.random() * 0.8, cl = new THREE.Color().setHSL(Math.random(), 0.8, 0.5), ms = 15 * sz; 
    const b = new CANNON.Body({ mass: ms, shape: new CANNON.Sphere(sz), material: new CANNON.Material('ene'), linearDamping: 0.4, collisionFilterGroup: G_ENEMY, collisionFilterMask: G_GROUND|G_PLAYER|G_PHYS_KEKKAI|G_GHOST_KEKKAI|G_VIP }); 
    b.position.set(x, y, z); world.addBody(b); b.outsideTimer = 0; 
    const m = new THREE.Mesh(new THREE.IcosahedronGeometry(sz, 0), new THREE.MeshStandardMaterial({ color: cl, roughness: 0.3 })); 
    scene.add(m); enemies.push({ body: b, mesh: m, isGiant: false }); 
  } 
  updateHUD(); 
}

function actionMetsu() { 
  let t = null, minD = 999; 
  const aimPos = aimMarker.position;
  kekkaiList.forEach(k => { 
    if(k.isShrinking) return;
    const d = aimPos.distanceTo(k.mesh.position); 
    if (d < minD) { minD = d; t = k; } 
  }); 
  if (!t || minD > 10.0) { showMsg("対象なし", "#888"); return; } 
  showMsg("滅！", "#f24"); spawnText("滅", t.mesh.position, "#f24"); 
  t.isShrinking = true; t.mesh.material.color.setHex(0xff0044);
  if (t.body) { world.removeBody(t.body); t.body = null; }
}

function actionKai() { 
  if (kekkaiList.length > 0) { 
    const active = kekkaiList.filter(k => !k.isShrinking);
    if(active.length > 0) {
      const t = active[active.length - 1]; 
      showMsg("解", "#4f8"); spawnText("解", t.mesh.position, "#4f8"); removeKekkai(t); 
    } else { showMsg("対象なし", "#888"); }
  } else { showMsg("結界なし", "#888"); } 
}

// Fixed: Always use Head (Camera) direction for Aiming
function updateAimMarker() { 
  if(!aimMarker) return; 
  let origin = new THREE.Vector3();
  let direction = new THREE.Vector3();
  const cam = renderer.xr.isPresenting ? renderer.xr.getCamera() : camera;
  origin.copy(cam.position);
  cam.getWorldDirection(direction);
  // If Non-VR, offset origin to emulate head height if group is at feet
  if (!renderer.xr.isPresenting) origin.copy(playerGroup.position).add(new THREE.Vector3(0, CFG.player.height*0.8, 0));
  aimMarker.position.copy(origin).add(direction.multiplyScalar(currentDist));
  aimMarker.visible = true;
}

function startVipMission() { 
  if (vip) return; 
  gameState.isVipMode = true; showMsg("護衛任務開始!", "#0ff"); els.vipBox.style.display = "block"; 
  const b = new CANNON.Body({ mass: 50, shape: new CANNON.Cylinder(0.5, 0.5, 1.8, 8), material: new CANNON.Material('ply'), fixedRotation: true, linearDamping: 0.5, collisionFilterGroup: G_VIP, collisionFilterMask: G_GROUND|G_ENEMY }); 
  b.position.set(0, 5, -CFG.field.depth / 2 + 30); 
  world.addBody(b); 
  const g = new THREE.Group(); g.add(new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 1.8, 16), new THREE.MeshStandardMaterial({ color: CFG.colors.vip }))); 
  const h = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshStandardMaterial({ color: 0xffcccc })); h.position.y = 1.0; g.add(h); scene.add(g); 
  const goalPos = new CANNON.Vec3(0, 5, CFG.field.depth / 2); 
  vip = { body: b, mesh: g, hp: 100, goal: goalPos }; 
  const geo = new THREE.ConeGeometry(1, 40, 32, 1, true); const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.3, side: THREE.DoubleSide, blending: THREE.AdditiveBlending }); 
  vipGoalMesh = new THREE.Mesh(geo, mat); vipGoalMesh.position.set(goalPos.x, 20, goalPos.z); scene.add(vipGoalMesh); 
}

// --------------------------------------------------
// 4. ENVIRONMENT SETUP
// --------------------------------------------------
function setupEnvironment(mat){
  const sun=new THREE.DirectionalLight(0xffffee,1.2); sun.position.set(-50,100,50); sun.castShadow=true; sun.shadow.mapSize.set(2048,2048); sun.shadow.camera.left=-100; sun.shadow.camera.right=100; sun.shadow.camera.top=100; sun.shadow.camera.bottom=-100; scene.add(sun); scene.add(new THREE.AmbientLight(0x666677,0.7));
  const gGeo=new THREE.PlaneGeometry(CFG.field.width+40,CFG.field.depth+40); const gMat=new THREE.MeshStandardMaterial({color:CFG.colors.ground,roughness:0.9}); const ground=new THREE.Mesh(gGeo,gMat); ground.rotation.x=-Math.PI/2; ground.receiveShadow=true; scene.add(ground); const gBody=new CANNON.Body({mass:0,material:mat, collisionFilterGroup: G_GROUND, collisionFilterMask: -1}); gBody.addShape(new CANNON.Plane()); gBody.quaternion.setFromEuler(-Math.PI/2,0,0); world.addBody(gBody);

  const createBox=(x,y,z,w,h,d,col,tr=false,op=1,rotY=0)=>{ const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),new THREE.MeshStandardMaterial({color:col,transparent:tr,opacity:op})); m.position.set(x,y,z); m.rotation.y=rotY; m.castShadow=!tr; m.receiveShadow=true; scene.add(m); const b=new CANNON.Body({mass:0,material:mat, collisionFilterGroup: G_GROUND, collisionFilterMask: -1}); b.addShape(new CANNON.Box(new CANNON.Vec3(w/2,h/2,d/2))); b.position.copy(m.position); b.quaternion.copy(m.quaternion); world.addBody(b); return m; };
  const createVisualBox=(x,y,z,w,h,d,col,rotY=0)=>{ const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),new THREE.MeshStandardMaterial({color:col})); m.position.set(x,y,z); m.rotation.y=rotY; m.castShadow=true; m.receiveShadow=true; scene.add(m); return m; };

  const FW=CFG.field.width,FD=CFG.field.depth,WH=8;
  const gateW = 24; const wallW = (FW - gateW) / 2;
  createBox(-FW/2 + wallW/2, WH/2, FD/2+1, wallW, WH, 2, CFG.colors.wall); createBox(FW/2 - wallW/2, WH/2, FD/2+1, wallW, WH, 2, CFG.colors.wall); createBox(-FW/2-1,WH/2,0,2,WH,FD+2,CFG.colors.wall); createBox(FW/2+1,WH/2,0,2,WH,FD+2,CFG.colors.wall); 
  const bH=30,bZ=-FD/2-20; createBox(0,bH/2,bZ,FW,bH,40,CFG.colors.building);
  for(let i=-FW/2+5;i<FW/2;i+=10)for(let j=5;j<28;j+=7){const w=new THREE.Mesh(new THREE.PlaneGeometry(4,4),new THREE.MeshBasicMaterial({color:0x87CEFA})); w.position.set(i,j,bZ+20+0.1); scene.add(w);}
  createBox(0, bH+1, bZ, FW, 2, 40, CFG.colors.concrete);

  const rampH = 0.6, rampW = 1.2; 
  const createRampFence = (x, z, length, rotY) => {
      const shape = new THREE.Shape(); shape.moveTo(0,0); shape.lineTo(0, rampH); shape.lineTo(rampW, 0); shape.lineTo(0,0);
      const geo = new THREE.ExtrudeGeometry(shape, { steps: 1, depth: length, bevelEnabled: false }); const m = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color: CFG.colors.concrete}));
      m.position.set(0, 0, -length/2); const wrapper = new THREE.Object3D(); wrapper.add(m); wrapper.position.set(x, bH+1, z); wrapper.rotation.y = rotY; scene.add(wrapper);
      const ang = Math.atan2(rampH, rampW); const hyp = Math.sqrt(rampH**2 + rampW**2);
      const b = new CANNON.Body({mass:0, material:mat, collisionFilterGroup: G_GROUND, collisionFilterMask: -1}); b.addShape(new CANNON.Box(new CANNON.Vec3(hyp/2, 0.1, length/2)), new CANNON.Vec3(rampW/2, rampH/2, 0), new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,0,1), -ang)); b.addShape(new CANNON.Box(new CANNON.Vec3(0.1, rampH/2, length/2)), new CANNON.Vec3(0, rampH/2, 0));
      b.position.set(x, bH+1, z); b.quaternion.setFromAxisAngle(new CANNON.Vec3(0,1,0), rotY); world.addBody(b);
  };
  createRampFence(0, bZ-20, FW, -Math.PI/2); createRampFence(-FW/2, bZ, 40, 0); createRampFence(FW/2, bZ, 40, Math.PI);
  const landW=8; const gapW = landW + 2; const landX = FW/2 - landW/2 - 2; const gapStart = landX - gapW/2; const gapEnd = landX + gapW/2;
  createRampFence((-FW/2 + gapStart)/2, bZ+20, gapStart - (-FW/2), Math.PI/2); createRampFence((gapEnd + FW/2)/2, bZ+20, FW/2 - gapEnd, Math.PI/2); 

  const wtX = FW/2 - 8, wtZ = bZ - 8, wtBaseH = bH+2; const wtTank = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 6, 16), new THREE.MeshStandardMaterial({color: CFG.colors.concrete})); wtTank.position.set(wtX, wtBaseH + 8, wtZ); wtTank.castShadow=true; scene.add(wtTank); const wtTankBody = new CANNON.Body({mass:0, material:mat, collisionFilterGroup: G_GROUND, collisionFilterMask: -1}); wtTankBody.addShape(new CANNON.Cylinder(4,4,6,16)); wtTankBody.position.copy(wtTank.position); world.addBody(wtTankBody);
  for(let i=0; i<4; i++){ const ang = i * Math.PI/2; const m=new THREE.Mesh(new THREE.BoxGeometry(0.5,5,0.5), new THREE.MeshStandardMaterial({color:CFG.colors.iron})); m.position.set(wtX + Math.cos(ang)*3, wtBaseH + 2.5, wtZ + Math.sin(ang)*3); scene.add(m); }

  const stW=6, stRise=bH, stRun=60; const landD=stW+2; const landY = bH; const landZ = bZ + 20 + landD/2;
  createBox(landX, landY, landZ, landW, 1, landD, CFG.colors.concrete); 
  const slLen=Math.sqrt(stRun**2+stRise**2), slAng=Math.atan2(stRise, stRun); const slMidX = landX - landW/2 - stRun/2; const slMidY = stRise/2; const slZ = bZ + 20 + stW/2 + 0.05; 
  const slB=new CANNON.Body({mass:0,material:mat, collisionFilterGroup: G_GROUND, collisionFilterMask: -1}); slB.addShape(new CANNON.Box(new CANNON.Vec3(slLen/2,0.5,stW/2))); slB.position.set(slMidX, slMidY, slZ); const slQ = new THREE.Quaternion(); slQ.setFromEuler(new THREE.Euler(0,0,slAng)); slB.quaternion.copy(slQ); world.addBody(slB);
  const slM=new THREE.Mesh(new THREE.BoxGeometry(slLen,1,stW), new THREE.MeshStandardMaterial({color:CFG.colors.concrete})); slM.position.copy(slB.position); slM.quaternion.copy(slB.quaternion); scene.add(slM);
  
  const brRun=3.0, brRise=1.5; const brLen=Math.sqrt(brRun**2+brRise**2)+0.5; const brAng=Math.atan2(brRise, brRun); 
  const brB = new CANNON.Body({mass:0, material:mat, collisionFilterGroup: G_GROUND, collisionFilterMask: -1}); brB.addShape(new CANNON.Box(new CANNON.Vec3(landW/2, 0.2, brLen/2))); brB.position.set(landX, bH + 0.5 + brRise/2, bZ + 21.5); brB.quaternion.setFromEuler(brAng, 0, 0); world.addBody(brB);
  const brM = new THREE.Mesh(new THREE.BoxGeometry(landW, 0.4, brLen), new THREE.MeshStandardMaterial({color:CFG.colors.concrete})); brM.position.copy(brB.position); brM.quaternion.copy(brB.quaternion); scene.add(brM);
  
  const hrH=1.2, hrT=0.1; const cRail = (x,y,z,w,h,d,rx=0,ry=0,rz=0) => { const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({color:CFG.colors.iron})); m.position.set(x,y,z); m.rotation.set(rx,ry,rz); scene.add(m); const b=new CANNON.Body({mass:0,material:mat, collisionFilterGroup: G_GROUND, collisionFilterMask: -1}); b.addShape(new CANNON.Box(new CANNON.Vec3(w/2,h/2,d/2))); b.position.copy(m.position); b.quaternion.copy(m.quaternion); world.addBody(b); };
  cRail(slMidX, slMidY+hrH/2, slZ-stW/2+hrT/2+0.05, slLen, hrH, hrT, 0,0,slAng); cRail(slMidX, slMidY+hrH/2, slZ+stW/2-hrT/2-0.05, slLen, hrH, hrT, 0,0,slAng);
  cRail(landX, landY+hrH/2, landZ+landD/2-hrT/2, landW, hrH, hrT); cRail(landX+landW/2-hrT/2, landY+hrH/2, landZ, hrT, hrH, landD);
  cRail(landX-landW/2+hrT/2, bH+0.5+brRise/2+hrH/2, bZ+21.5, hrT, hrH, brLen, brAng,0,0); cRail(landX+landW/2-hrT/2, bH+0.5+brRise/2+hrH/2, bZ+21.5, hrT, hrH, brLen, brAng,0,0);

  const pX = 35, pZ = 10, pW = 20, pD = 40, pBaseH = 4;
  createBox(pX, pBaseH/2, pZ, pW+4, pBaseH, pD+4, CFG.colors.concrete);
  createBox(pX, pBaseH+1, pZ - pD/2 - 1, pW+2, 2, 2, CFG.colors.concrete); createBox(pX, pBaseH+1, pZ + pD/2 + 1, pW+2, 2, 2, CFG.colors.concrete); createBox(pX - pW/2 - 1, pBaseH+1, pZ, 2, 2, pD, CFG.colors.concrete); createBox(pX + pW/2 + 1, pBaseH+1, pZ, 2, 2, pD, CFG.colors.concrete);
  const water = new THREE.Mesh(new THREE.PlaneGeometry(pW, pD), new THREE.MeshBasicMaterial({color:0x00aaff, transparent:true, opacity:0.6, side:THREE.DoubleSide})); water.rotation.x = -Math.PI/2; water.position.set(pX, pBaseH+1.5, pZ); scene.add(water);
  // Pool Ramps
  const prRun=25, prRise=pBaseH, prW=4; const prLen=Math.sqrt(prRun**2+prRise**2), prAng=Math.atan2(prRise, prRun); const prMidY = prRise/2; const prMidZ = pZ; 
  const prMidX_L = pX - pW/2 - prW/2 - 2; 
  const prB_L=new CANNON.Body({mass:0,material:mat, collisionFilterGroup: G_GROUND, collisionFilterMask: -1}); prB_L.addShape(new CANNON.Box(new CANNON.Vec3(prW/2, 0.5, prLen/2))); prB_L.position.set(prMidX_L, prMidY, prMidZ);
  const prQ_L = new THREE.Quaternion(); prQ_L.setFromEuler(new THREE.Euler(prAng, 0, 0)); prB_L.quaternion.copy(prQ_L); world.addBody(prB_L);
  const prM_L=new THREE.Mesh(new THREE.BoxGeometry(prW, 1, prLen), new THREE.MeshStandardMaterial({color:CFG.colors.concrete})); prM_L.position.copy(prB_L.position); prM_L.quaternion.copy(prB_L.quaternion); scene.add(prM_L);
  const prMidX_R = pX + pW/2 + prW/2 + 2;
  const prB_R=new CANNON.Body({mass:0,material:mat, collisionFilterGroup: G_GROUND, collisionFilterMask: -1}); prB_R.addShape(new CANNON.Box(new CANNON.Vec3(prW/2, 0.5, prLen/2))); prB_R.position.set(prMidX_R, prMidY, prMidZ);
  const prQ_R = new THREE.Quaternion(); prQ_R.setFromEuler(new THREE.Euler(prAng, 0, 0)); prB_R.quaternion.copy(prQ_R); world.addBody(prB_R);
  const prM_R=new THREE.Mesh(new THREE.BoxGeometry(prW, 1, prLen), new THREE.MeshStandardMaterial({color:CFG.colors.concrete})); prM_R.position.copy(prB_R.position); prM_R.quaternion.copy(prB_R.quaternion); scene.add(prM_R);

  const gZ = FD/2; createBox(-gateW/2-1, 4, gZ, 2, 8, 2, CFG.colors.wall); createBox(gateW/2+1, 4, gZ, 2, 8, 2, CFG.colors.wall);
  for(let i=-gateW/2; i<=gateW/2; i+=1.0) createVisualBox(i, 3, gZ, 0.2, 6, 0.2, CFG.colors.iron); 
  createVisualBox(0, 5.5, gZ, gateW, 0.3, 0.3, CFG.colors.iron); createVisualBox(0, 0.5, gZ, gateW, 0.3, 0.3, CFG.colors.iron);
  const gateB = new CANNON.Body({mass:0, material:mat, collisionFilterGroup: G_GROUND, collisionFilterMask: -1}); gateB.addShape(new CANNON.Box(new CANNON.Vec3(gateW/2, 3, 0.1))); gateB.position.set(0, 3, gZ); world.addBody(gateB);

  const createTree = (x, z) => { const trunkH = 4 + Math.random()*2; createBox(x, trunkH/2, z, 1, trunkH, 1, CFG.colors.wood); const leaves = new THREE.Mesh(new THREE.IcosahedronGeometry(2.5 + Math.random(), 1), new THREE.MeshStandardMaterial({color:CFG.colors.leaf, roughness:0.8})); leaves.position.set(x, trunkH+2, z); leaves.castShadow=true; scene.add(leaves); };
  for(let i=0; i<5; i++) createTree(-FW/2+3, -FD/2 + 10 + i*20); for(let i=0; i<5; i++) createTree(FW/2-3, -FD/2 + 10 + i*20);
}

// --------------------------------------------------
// 5. MOBILE INPUTS (Phys: Collision during draw / Ghost: Visual only)
// --------------------------------------------------
function createActiveMobile() { 
  const p = aimMarker.position.clone(), r = camAngle.yaw; 
  
  // Create Physics Body immediately for Interaction
  const group = G_PHYS_KEKKAI;
  const mask = G_GROUND | G_PLAYER | G_ENEMY | G_VIP | G_PHYS_KEKKAI | G_GHOST_KEKKAI;
  const b = new CANNON.Body({ mass: 0, material: new CANNON.Material('kek'), collisionFilterGroup: group, collisionFilterMask: mask });
  b.position.copy(p); b.quaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), r);
  b.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5))); // Start size
  world.addBody(b);

  const g = new THREE.BoxGeometry(1, 1, 1); 
  const m = new THREE.MeshPhongMaterial({ color: CFG.colors.drawPhys, transparent: true, opacity: 0.5, side: THREE.DoubleSide }); 
  const mesh = new THREE.Mesh(g, m); 
  mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }))); 
  mesh.position.copy(p); mesh.rotation.y = r; scene.add(mesh); 
  
  return { mesh: mesh, body: b, startP: p, startR: r, currentS: { x: 1, y: 1, z: 1 } }; 
}

function updateActiveMobile(k, dx, dy) { 
  const sx = 1.0 + Math.max(0, dx), sy = 1.0 + Math.max(0, dy), sz = sx; 
  k.currentS = { x: sx, y: sy, z: sz }; 
  k.mesh.scale.set(sx, sy, sz); 
  const newY = k.startP.y + (sy - 1.0) / 2; 
  k.mesh.position.y = newY; 
  
  // Update Physics Body real-time for interaction
  k.body.position.y = newY;
  k.body.shapes[0].halfExtents.set(sx/2, sy/2, sz/2);
  k.body.shapes[0].updateConvexPolyhedronRepresentation();
  k.body.updateBoundingRadius();
}

function finalizeMobile(k) { 
  // Finalize: Just change visual color, body persists
  k.mesh.material.color.setHex(CFG.colors.kekkai);
  kekkaiList.push({ body: k.body, mesh: k.mesh, isShrinking: false, shrinkProgress: 1.0, isGhost: false });
  spawnText("結", k.mesh.position, "#ff0"); updateHUD();
}

function setupMobileInputs(){
  els.stick.addEventListener('touchstart',e=>{e.preventDefault();if(stickId!==null)return;const t=e.changedTouches[0];stickId=t.identifier;const r=els.stick.getBoundingClientRect();stickStart={x:r.left+r.width/2,y:r.top+r.height/2};tapTime=Date.now();tapPos={x:t.clientX,y:t.clientY};moveStick(t.clientX,t.clientY);},{passive:false});
  els.stick.addEventListener('touchmove',e=>{e.preventDefault();for(let i=0;i<e.changedTouches.length;i++)if(e.changedTouches[i].identifier===stickId)moveStick(e.changedTouches[i].clientX,e.changedTouches[i].clientY);},{passive:false});
  const endStick=e=>{for(let i=0;i<e.changedTouches.length;i++){const t=e.changedTouches[i];if(t.identifier===stickId){if(Date.now()-tapTime<200&&Math.hypot(t.clientX-tapPos.x,t.clientY-tapPos.y)<15){if(playerBody&&Math.abs(playerBody.velocity.y)<1)playerBody.velocity.y=CFG.player.jump;}stickId=null;input.x=0;input.y=0;els.knob.style.transform='translate(-50%,-50%)';}}};
  els.stick.addEventListener('touchend',endStick);els.stick.addEventListener('touchcancel',endStick);
  function moveStick(cx,cy){let dx=cx-stickStart.x,dy=cy-stickStart.y;const d=Math.hypot(dx,dy),max=(els.stick.offsetWidth/2)*0.8;if(d>max){dx*=max/d;dy*=max/d;}input.x=dx/max;input.y=dy/max;els.knob.style.transform=`translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;}
  renderer.domElement.addEventListener('touchstart',e=>{e.preventDefault();for(let i=0;i<e.changedTouches.length;i++){if(lookId===null&&e.changedTouches[i].target===renderer.domElement){lookId=e.changedTouches[i].identifier;lastLook={x:e.changedTouches[i].clientX,y:e.changedTouches[i].clientY};}}},{passive:false});
  renderer.domElement.addEventListener('touchmove',e=>{e.preventDefault();if(lookId===null)return;for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===lookId){const t=e.changedTouches[i];camAngle.yaw-=(t.clientX-lastLook.x)*0.004;camAngle.pitch-=(t.clientY-lastLook.y)*0.004;camAngle.pitch=Math.max(-1.5,Math.min(1.5,camAngle.pitch));lastLook={x:t.clientX,y:t.clientY};}}},{passive:false});
  renderer.domElement.addEventListener('touchend',e=>{for(let i=0;i<e.changedTouches.length;i++)if(e.changedTouches[i].identifier===lookId)lookId=null;});
  els.btnJump.addEventListener('touchstart',e=>{e.preventDefault();if(playerBody&&Math.abs(playerBody.velocity.y)<1)playerBody.velocity.y=CFG.player.jump;});
  els.btnDist.addEventListener('touchstart',e=>{e.preventDefault();currentDist=(currentDist===CFG.dist.near)?CFG.dist.far:CFG.dist.near;els.distLabel.textContent=(currentDist===CFG.dist.near)?"近":"遠";showMsg(`射程: ${els.distLabel.textContent}`,"#fff");});
  els.btnAct.addEventListener('touchstart',e=>{e.preventDefault();if(actId!==null)return;const t=e.changedTouches[0];actId=t.identifier;actStartPos={x:t.clientX,y:t.clientY};});
  els.btnAct.addEventListener('touchend',e=>{e.preventDefault();for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===actId){const t=e.changedTouches[i];if(Math.hypot(t.clientX-actStartPos.x,t.clientY-actStartPos.y)>20)actionKai();else actionMetsu();actId=null;}}});
  els.modeBtn.addEventListener('touchstart',e=>{e.preventDefault(); e.stopPropagation(); isPhysMode = !isPhysMode; els.modeBtn.textContent = isPhysMode ? "モード: 顕現" : "モード: 幽体"; els.modeBtn.className = isPhysMode ? "phys" : "ghost"; els.btnDraw.style.background = isPhysMode ? "linear-gradient(135deg, #FFD700, #FF8C00)" : "linear-gradient(135deg, #03a9f4, #0288d1)"; els.btnDraw.innerHTML = isPhysMode ? "顕<br><span style='font-size:10px'>Hold</span>" : "結<br><span style='font-size:10px'>Hold</span>"; showMsg(isPhysMode ? "物理顕現モード" : "幽体結界モード", "#fff");});
  
  els.btnDraw.addEventListener('touchstart',e=>{ e.preventDefault(); if(drawId!==null)return; if(kekkaiList.length>=CFG.kekkai.max){showMsg("上限到達","#f44");return;} const t=e.changedTouches[0]; drawId=t.identifier; els.btnDraw.classList.add('drawing'); 
    if(isPhysMode) { 
      // Phys: Create real body immediately
      activePhysKekkai = createActiveMobile(); 
      activePhysKekkai.startX=t.clientX; activePhysKekkai.startY=t.clientY; 
    } else { 
      // Ghost: Visual only during draw
      drawState.active=true; drawState.startX=t.clientX; drawState.startY=t.clientY; 
      const gg=new THREE.BoxGeometry(1,1,1),gm=new THREE.MeshPhongMaterial({color:CFG.colors.drawGhost,transparent:true,opacity:0.5, side: THREE.DoubleSide}); 
      drawState.ghost=new THREE.Mesh(gg,gm); 
      drawState.ghost.add(new THREE.LineSegments(new THREE.EdgesGeometry(gg), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }))); 
      drawState.ghost.position.copy(aimMarker.position); drawState.ghost.rotation.y=camAngle.yaw; 
      scene.add(drawState.ghost); 
    } 
  });
  
  els.btnDraw.addEventListener('touchmove',e=>{ e.preventDefault(); if(drawId===null)return; for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===drawId){ const t=e.changedTouches[i]; 
    if(isPhysMode && activePhysKekkai) { 
      const dx=Math.abs(t.clientX-activePhysKekkai.startX)*0.06, dy=(activePhysKekkai.startY-t.clientY)*0.06; 
      updateActiveMobile(activePhysKekkai, dx, dy); 
    } else if(drawState.active && drawState.ghost) { 
      const dx=Math.abs(t.clientX-drawState.startX)*0.06, dy=(drawState.startY-t.clientY)*0.06; 
      const sxz=1.0+Math.max(0,dx), sy=1.0+Math.max(0,dy); 
      drawState.ghost.scale.set(sxz,sy,sxz); 
      drawState.ghost.position.y=aimMarker.position.y+(sy/2-0.5); 
    } }} 
  });
  
  els.btnDraw.addEventListener('touchend',e=>{ e.preventDefault(); for(let i=0;i<e.changedTouches.length;i++){if(e.changedTouches[i].identifier===drawId){ 
    if(isPhysMode && activePhysKekkai) { 
      finalizeMobile(activePhysKekkai); 
      activePhysKekkai=null; 
    } else if(drawState.ghost) { 
      createKekkai(drawState.ghost.position,drawState.ghost.scale,drawState.ghost.rotation.y, true); 
      safeRemoveMesh(drawState.ghost); 
      drawState.ghost=null; drawState.active=false; 
    } 
    drawId=null; els.btnDraw.classList.remove('drawing'); }} 
  });
}

// --------------------------------------------------
// 7. VR SETUP
// --------------------------------------------------
function setupVRControllers() { const modelFactory = new XRControllerModelFactory(); for (let i = 0; i < 2; i++) { const controller = renderer.xr.getController(i); playerGroup.add(controller); controllers.push(controller); const grip = renderer.xr.getControllerGrip(i); grip.add(modelFactory.createControllerModel(grip)); playerGroup.add(grip); controllerGrips.push(grip); } }
function setupVRHud() { const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 128; vrHudCtx = canvas.getContext('2d'); const tex = new THREE.CanvasTexture(canvas); vrHudMesh = new THREE.Mesh(new THREE.PlaneGeometry(1.0, 0.25), new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0.9, depthTest: false })); vrHudMesh.position.set(0, -0.4, -1.5); vrHudMesh.renderOrder = 9999; camera.add(vrHudMesh); }
function handleVRInput() { if (!renderer.xr.isPresenting) return; const session = renderer.xr.getSession(); if (!session) return; for (const src of session.inputSources) { if (!src.gamepad) continue; const gp = src.gamepad; const hand = src.handedness; const idx = (hand === 'left') ? 0 : 1; if(!controllers[idx]) continue; const ctrlPos = controllers[idx].position;
    if (hand === 'left') { 
      if (gp.axes.length >= 4) { input.x = gp.axes[2]; input.y = gp.axes[3]; } 
      if (gp.buttons[3]?.pressed && Math.abs(playerBody.velocity.y) < 1) playerBody.velocity.y = CFG.player.jump; 
      if (gp.buttons[0]?.pressed && !vrState.left.triggerHeld) { actionKai(); vrState.left.triggerHeld = true; } 
      if (!gp.buttons[0]?.pressed) vrState.left.triggerHeld = false; 
      
      const grip = gp.buttons[1]?.pressed; 
      if (grip) { 
        if (!vrState.left.drawing) { 
          if (kekkaiList.length >= CFG.kekkai.max) { showMsg("上限", "#f44"); } 
          else { 
            vrState.left.drawing = true; vrState.left.startHandPos.copy(ctrlPos); vrState.barrierOrigin.copy(aimMarker.position); 
            const g = new THREE.BoxGeometry(1,1,1); const m = new THREE.MeshPhongMaterial({color: CFG.colors.drawPhys, transparent: true, opacity: 0.5, side: THREE.DoubleSide}); 
            vrState.left.mesh = new THREE.Mesh(g, m); 
            vrState.left.mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }))); 
            vrState.left.mesh.position.copy(vrState.barrierOrigin); scene.add(vrState.left.mesh);
            // Phys Body creation
            const b = new CANNON.Body({ mass: 0, material: new CANNON.Material('kek'), collisionFilterGroup: G_PHYS_KEKKAI, collisionFilterMask: G_GROUND|G_PLAYER|G_ENEMY|G_VIP|G_PHYS_KEKKAI|G_GHOST_KEKKAI });
            b.position.copy(vrState.barrierOrigin); b.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5))); world.addBody(b);
            vrState.left.physBody = b;
          } 
        } else { 
          const diff = ctrlPos.clone().sub(vrState.left.startHandPos); 
          const sx = 1.0 + Math.abs(diff.x) * CFG.kekkai.sensitivity; const sy = 1.0 + Math.abs(diff.y) * CFG.kekkai.sensitivity; const sz = 1.0 + Math.abs(diff.z) * CFG.kekkai.sensitivity; 
          vrState.left.mesh.scale.set(sx, sy, sz); 
          vrState.left.physBody.shapes[0].halfExtents.set(sx/2, sy/2, sz/2);
          vrState.left.physBody.shapes[0].updateConvexPolyhedronRepresentation();
          vrState.left.physBody.updateBoundingRadius();
        } 
      } else { 
        if (vrState.left.drawing) { 
          if (vrState.left.mesh) { 
             vrState.left.mesh.material.color.setHex(CFG.colors.kekkai);
             kekkaiList.push({ body: vrState.left.physBody, mesh: vrState.left.mesh, isShrinking: false, shrinkProgress: 1.0, isGhost: false });
             spawnText("結", vrState.left.mesh.position, "#ff0"); updateHUD();
             vrState.left.mesh = null; vrState.left.physBody = null;
          } 
          vrState.left.drawing = false; 
        } 
      } 
    }
    if (hand === 'right') { 
      const turnVal = gp.axes[2]; if (Math.abs(turnVal) > 0.5) { if (!vrState.snapTurn) { camAngle.yaw -= Math.sign(turnVal) * Math.PI / 4; vrState.snapTurn = true; } } else { vrState.snapTurn = false; } 
      if (gp.buttons[4]?.pressed && Math.abs(playerBody.velocity.y) < 1) playerBody.velocity.y = CFG.player.jump; 
      if (gp.buttons[0]?.pressed && !vrState.right.metsuLock) { actionMetsu(); vrState.right.metsuLock = true; } 
      if (!gp.buttons[0]?.pressed) vrState.right.metsuLock = false; 
      if (gp.buttons[5]?.pressed && !vrState.right.bLock) { currentDist = (currentDist === CFG.dist.near) ? CFG.dist.far : CFG.dist.near; showMsg(currentDist === CFG.dist.near ? "近" : "遠", "#fff"); vrState.right.bLock = true; } 
      if (!gp.buttons[5]?.pressed) vrState.right.bLock = false; 
      
      const grip = gp.buttons[1]?.pressed; 
      if (grip) { 
        if (!vrState.right.drawing) { 
          vrState.right.drawing = true; vrState.right.startHandPos.copy(ctrlPos); vrState.barrierOrigin.copy(aimMarker.position); 
          const g = new THREE.BoxGeometry(1,1,1); const m = new THREE.MeshPhongMaterial({color: CFG.colors.drawGhost, transparent: true, opacity: 0.5, side: THREE.DoubleSide}); 
          vrState.right.mesh = new THREE.Mesh(g, m); vrState.right.mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(g), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 }))); 
          vrState.right.mesh.position.copy(vrState.barrierOrigin); scene.add(vrState.right.mesh); 
        } else { 
          const diff = ctrlPos.clone().sub(vrState.right.startHandPos); const sx = 1.0 + Math.abs(diff.x) * CFG.kekkai.sensitivity; const sy = 1.0 + Math.abs(diff.y) * CFG.kekkai.sensitivity; const sz = 1.0 + Math.abs(diff.z) * CFG.kekkai.sensitivity; 
          vrState.right.mesh.scale.set(sx, sy, sz); 
        } 
      } else { 
        if (vrState.right.drawing) { 
          if (vrState.right.mesh) { 
            createKekkai(vrState.right.mesh.position, vrState.right.mesh.scale, 0, true); 
            safeRemoveMesh(vrState.right.mesh); vrState.right.mesh = null; 
          } 
          vrState.right.drawing = false; 
        } 
      } 
    } 
  } 
}

// --------------------------------------------------
// 8. LOOP & INIT
// --------------------------------------------------
function loop(t) {
  const dt = Math.min((t - lastT) / 1000, 0.1); lastT = t; world.step(1 / 60, dt, 3);
  
  if (renderer.xr.isPresenting) handleVRInput();

  const camDir = new THREE.Vector3();
  const cam = renderer.xr.isPresenting ? renderer.xr.getCamera() : camera;
  cam.getWorldDirection(camDir);
  camDir.y = 0; camDir.normalize();
  const camRight = new THREE.Vector3(-camDir.z, 0, camDir.x);
  
  const moveVec = camDir.clone().multiplyScalar(-input.y).add(camRight.clone().multiplyScalar(input.x));
  
  playerBody.velocity.x = moveVec.x * CFG.player.speed;
  playerBody.velocity.z = moveVec.z * CFG.player.speed;
  
  playerGroup.position.copy(playerBody.position).add(new THREE.Vector3(0, CFG.player.height, 0));
  if(!renderer.xr.isPresenting) camera.rotation.x = camAngle.pitch;
  playerGroup.rotation.y = camAngle.yaw;

  updateAimMarker(); 
  if (t > gameState.nextSpawn) { spawnEnemy(); gameState.nextSpawn = t + 3000 - gameState.wave * 100; }
  
  kekkaiList.forEach(k => {
      if(k.isShrinking) {
          k.shrinkProgress -= dt * 2.0; 
          if(k.shrinkProgress <= 0) {
              removeKekkai(k);
              spawnParticle(k.mesh.position, 20, 0xff00ff);
          } else {
              k.mesh.scale.setScalar(k.shrinkProgress);
              const center = k.mesh.position;
              enemies.forEach(e => {
                  const dist = center.distanceTo(e.body.position);
                  if(dist < 5.0) { 
                      const pull = center.clone().sub(e.body.position).normalize();
                      e.body.applyForce(pull.multiplyScalar(200), e.body.position); 
                      if(dist < 1.5 && Math.random() < 0.1) killEnemy(e); 
                  }
              });
          }
      }
  });

  items.forEach(it => { it.mesh.position.copy(it.body.position); it.mesh.rotation.y += 0.05; if (playerBody.position.distanceTo(it.body.position) < 2.0) { healPlayer(20); scene.remove(it.mesh); world.removeBody(it.body); items = items.filter(i => i !== it); } });
  if (vip) { vip.mesh.position.copy(vip.body.position); const tg = vip.goal.vsub(vip.body.position); if(vipGoalMesh) vipGoalMesh.rotation.y += 0.02; if (tg.length() < 6.0) { showMsg("護衛成功!", "#0f0"); world.removeBody(vip.body); scene.remove(vip.mesh); vip = null; els.vipBox.style.display = "none"; gameState.isVipMode = false; if(vipGoalMesh) { scene.remove(vipGoalMesh); vipGoalMesh = null; }} else { tg.normalize(); vip.body.velocity.x = tg.x * 7; vip.body.velocity.z = tg.z * 7; els.vipHpBar.style.width = vip.hp + "%"; if (vip.hp <= 0) { showMsg("護衛失敗...", "#f00"); world.removeBody(vip.body); scene.remove(vip.mesh); vip = null; els.vipBox.style.display = "none"; gameState.isVipMode = false; if(vipGoalMesh) { scene.remove(vipGoalMesh); vipGoalMesh = null; }} } }
  const fW = CFG.field.width, fD = CFG.field.depth; enemies.forEach(e => { e.mesh.position.copy(e.body.position); e.mesh.quaternion.copy(e.body.quaternion); if (e.body.position.y < -10) killEnemy(e); const isOut = Math.abs(e.body.position.x) > fW / 2 + 2 || Math.abs(e.body.position.z) > fD / 2 + 2; if (isOut) { if (!e.body.outsideTimer) e.body.outsideTimer = 0; e.body.outsideTimer += dt; if (e.body.outsideTimer > 20.0) { showMsg("敵逃亡!", "#aaa"); removeEnemy(e); return; } const cu = new CANNON.Vec3(0, 25, 0), dr = cu.vsub(e.body.position); dr.normalize(); e.body.applyForce(dr.scale(e.isGiant ? 200 : 40), e.body.position); } else { e.body.outsideTimer = 0; const target = (vip && vip.hp > 0) ? vip.body.position : playerBody.position; const d = target.vsub(e.body.position); d.normalize(); e.body.applyForce(d.scale(e.isGiant ? 100 : 20), e.body.position); if (vip && e.body.position.distanceTo(vip.body.position) < 2.0 && Math.random() < 0.05) { vip.hp -= 5; spawnParticle(vip.body.position, 5, 0xff0000); } } });
  renderer.render(scene, camera);
}

function init() {
  try {
    scene = new THREE.Scene(); scene.background = new THREE.Color(CFG.colors.sky); scene.fog = new THREE.FogExp2(CFG.colors.sky, 0.005); 
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200); 
    playerGroup = new THREE.Group(); playerGroup.add(camera); 
    camera.position.set(0, CFG.player.height, 0); scene.add(playerGroup); 
    renderer = new THREE.WebGLRenderer({ antialias: true }); 
    renderer.setSize(window.innerWidth, window.innerHeight); 
    renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
    renderer.xr.enabled = true; 
    document.body.appendChild(renderer.domElement);

    world = new CANNON.World(); world.gravity.set(0, -30, 0);
    const mDef=new CANNON.Material('def'), mPly=new CANNON.Material('ply'), mEne=new CANNON.Material('ene'), mKek=new CANNON.Material('kek');
    
    world.addContactMaterial(new CANNON.ContactMaterial(mPly, mDef, { friction: 0.0, restitution: 0.0 }));
    world.addContactMaterial(new CANNON.ContactMaterial(mEne, mDef, { friction: 0.5, restitution: 0.3 }));
    world.addContactMaterial(new CANNON.ContactMaterial(mKek, mEne, { friction: 0.1, restitution: 0.8 }));
    world.addContactMaterial(new CANNON.ContactMaterial(mKek, mPly, { friction: 0.8, restitution: 0.0 }));
    world.addContactMaterial(new CANNON.ContactMaterial(mPly, mEne, { friction: 0.5, restitution: 0.5 }));

    playerBody = new CANNON.Body({ mass: 70, shape: new CANNON.Sphere(0.6), material: mPly, fixedRotation: true, linearDamping: 0.9, collisionFilterGroup: G_PLAYER, collisionFilterMask: G_GROUND|G_ENEMY|G_PHYS_KEKKAI|G_GHOST_KEKKAI });
    playerBody.position.set(0, 5, 30); world.addBody(playerBody);
    playerBody.addEventListener('collide', (e) => { if (e.body && e.body.material && e.body.material.name === 'ene') { const relVel = e.contact.getImpactVelocityAlongNormal(); if (Math.abs(relVel) > 2.0) { takeDamage(Math.floor(Math.abs(relVel) * 2)); const normal = new CANNON.Vec3(); e.contact.ni.negate(normal); playerBody.applyImpulse(normal.scale(50 * Math.abs(relVel)), playerBody.position); } } });

    setupEnvironment(mDef);
    setupVRControllers();
    setupVRHud();
    setupMobileInputs();
    
    const aimGeo = new THREE.SphereGeometry(0.3, 16, 16); const aimMat = new THREE.MeshBasicMaterial({ color: CFG.colors.marker, transparent: true, opacity: 0.7, depthTest: false }); 
    aimMarker = new THREE.Mesh(aimGeo, aimMat); aimMarker.renderOrder = 999; scene.add(aimMarker);
    
    controllers.forEach((controller, index) => {
        controller.addEventListener('connected', (event) => {
            controller.userData.handedness = event.data.handedness;
        });
    });
    
    updateAimMarker(); 

    for (let i = 0; i < 3; i++) spawnEnemy(); 
    renderer.setAnimationLoop(loop);

    let currentSession = null;
    document.getElementById('vrBtn').addEventListener('click', async () => { 
      if (currentSession) return; 
      if (!navigator.xr) return; 
      try { 
        const session = await navigator.xr.requestSession('immersive-vr', { optionalFeatures: ['local-floor', 'bounded-floor', 'hand-tracking'] }); 
        renderer.xr.setSession(session); 
        currentSession = session; 
        els.novr.forEach(e => e.style.opacity = 0); 
        session.addEventListener('end', () => { currentSession = null; els.novr.forEach(e => e.style.opacity = 1); }); 
      } catch (e) { 
        console.error("VR Init Error:", e); 
        alert("VRモードの起動に失敗しました: " + e.message); 
      } 
    });

  } catch (e) { console.error(e); alert("初期化エラー: " + e.message); }
}

window.onload = init;
</script>
</body>
</html>
