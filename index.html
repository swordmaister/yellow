<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>çœŸãƒ»çµç•Œå¸«VR â€” ç™¾é¬¼å¤œè¡Œãƒ»æœˆå¤œã®æ¿€é—˜</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover, user-scalable=no">
<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:"Sawarabi Mincho", serif; overflow:hidden; touch-action: none;}
  canvas{display:block}
  
  /* HUD */
  #hud { position: fixed; left: 16px; top: 16px; background: rgba(0,10,30,0.6); border: 1px solid #4af; padding:10px; border-radius:6px; font-size:14px; width:260px; pointer-events:none; z-index:10; text-shadow: 0 0 5px #0ff; box-shadow: 0 0 10px rgba(0,100,255,0.3); }
  .val { font-weight:bold; color:#fff; }
  .wave-info { font-size: 16px; color: #fe0; font-weight:bold; margin-bottom:4px; }
  
  /* --- 8. ã‚¹ãƒãƒ›UIæ”¹å–„ --- */
  #mobileUI { 
    position: fixed; top:0; left:0; width:100%; height:100%; pointer-events: none; z-index: 20; 
    display: flex; justify-content: space-between; align-items: flex-end; padding-bottom: 20px; box-sizing: border-box; 
  }

  /* ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚¨ãƒªã‚¢ */
  #joystickArea { 
    pointer-events: auto; width: 150px; height: 150px; margin-left: 20px; margin-bottom: 20px; 
    border-radius: 50%; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3);
    position: relative; 
  }
  #joystickHandle {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    width: 60px; height: 60px; border-radius: 50%;
    background: rgba(0,255,255,0.5); border: 2px solid #0ff;
    box-shadow: 0 0 8px #0ff;
    transition: width 0.1s, height 0.1s;
    pointer-events: none;
    display: flex; align-items: center; justify-content: center;
    font-size: 14px; color: #000; font-weight: bold;
  }
  #joystickArea.active #joystickHandle { width: 70px; height: 70px; }

  /* ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ */
  #actionArea { 
    pointer-events: auto; width: 170px; height: 300px; margin-right: 20px; margin-bottom: 10px; 
    display: flex; flex-direction: column; gap: 10px; 
  }
  .btn { width: 100%; border-radius: 10px; border: 2px solid rgba(255,255,255,0.6); color: #fff; font-weight: bold; font-size: 16px; display: flex; align-items: center; justify-content: center; flex-direction: column; box-shadow: 0 4px 10px rgba(0,0,0,0.5); background: rgba(0,0,0,0.4); backdrop-filter: blur(4px); transition: transform 0.08s; pointer-events: auto; }
  .btn:active { transform: scale(0.95); background: rgba(255,255,255,0.2); }
  
  #rowUpper { display: flex; gap: 8px; flex: 2; }
  /* çµãƒœã‚¿ãƒ³ã‚’å·¦ã«é…ç½®ã—ã€ã‚µã‚¤ã‚ºã‚’å¤§ããã—ã¦æ“ä½œæ€§å‘ä¸Š */
  #btnDraw { background: linear-gradient(135deg, #0af, #06a); flex: 2.5; font-size: 18px; border-color: #0af; }
  #btnDraw.drawing { background: linear-gradient(135deg, #fff, #0af); color: #000; box-shadow: 0 0 15px #0af; }
  #btnRange { background: linear-gradient(135deg, #666, #444); flex: 1; font-size: 14px; border-color: #888; }
  
  #subActions { display: flex; gap: 8px; flex: 1.2; }
  #btnMets { background: linear-gradient(135deg, #f24, #a12); flex:1; font-size: 20px; }
  #btnKai { background: linear-gradient(135deg, #4f8, #284); flex:1; font-size: 20px; }
  #btnJump { background: linear-gradient(135deg, #f0b, #80f); flex:0.8; height: 45px; }

  /* VR/ãƒ¬ãƒ†ã‚£ã‚¯ãƒ« */
  #vrToggle { position: fixed; top: 10px; right: 10px; z-index: 101; padding: 8px 16px; background: #333; color: #fff; border: 1px solid #fff; pointer-events: auto; border-radius:6px; }
  #reticle { position: fixed; top: 50%; left: 50%; width: 20px; height: 20px; border: 2px solid rgba(255,255,255,0.6); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 5; box-shadow: 0 0 4px #000; }

</style>
</head>
<body>
<button id="vrToggle">VRãƒ¢ãƒ¼ãƒ‰</button>
<div id="reticle"></div>

<div id="hud">
  <div class="wave-info">WAVE <span id="waveVal">1</span>: <span id="waveName">é™å¯‚</span></div>
  <div>æ’ƒç ´æ•°: <span id="killCount" class="val">0</span> (æ¬¡ã¸: <span id="nextWave" class="val">3</span>)</div>
  <div style="margin-top:4px; font-size:12px; color:#aaa;">çµç•Œ: <span id="kCount">0</span>/5 | æ•µ: <span id="eCount">0</span></div>
  <div id="statusText" style="color:#f0a; margin-top:6px; font-weight:bold;">ç´¢æ•µä¸­â€¦</div>
</div>

<div id="mobileUI">
  <div id="joystickArea">
    <div id="joystickHandle">ç§»å‹•</div>
  </div>
  
  <div id="actionArea">
    <div class="btn" id="btnJump">JUMP</div>
    <div id="rowUpper">
      <div class="btn" id="btnRange">è·é›¢<br><span id="rangeVal" style="color:#ff8">è¿‘</span></div>
      <div class="btn" id="btnDraw">æ–¹ä½<br><small style="font-size:10px">é•·æŠ¼ã—å¤‰å½¢</small></div>
    </div>
    <div id="subActions">
      <div class="btn" id="btnMets">æ»…</div>
      <div class="btn" id="btnKai">è§£</div>
    </div>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
    "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
// import { VRButton } from 'three/addons/webxr/VRButton.js'; // å‰Šé™¤
import * as CANNON from 'cannon-es';

/* --------------------
  ã‚²ãƒ¼ãƒ é€²è¡Œè¨­å®š (Waveåˆ¶)
-------------------- */
let currentWave = 1;
let killCount = 0;
let killsToNextWave = 3;

const WAVE_INFO = {
  1: { name: "é™å¯‚ (ç·´ç¿’)", type: "static", desc: "æ•µã¯å‹•ãã¾ã›ã‚“" },
  2: { name: "é€™ã„å¯„ã‚‹å½±", type: "walker", desc: "åœ°é¢ã‚’é€™ã£ã¦ãã¾ã™" },
  3: { name: "è·³æ¢è·‹æ‰ˆ", type: "jumper", desc: "è·³ã­å›ã‚Šã¾ã™" },
  4: { name: "ä½ç©ºã®è„…å¨", type: "low_flyer", desc: "å°‘ã—æµ®ã„ã¦ã„ã¾ã™" },
  5: { name: "ç™¾é¬¼å¤œè¡Œ", type: "high_flyer", desc: "ç©ºã‚’è‡ªåœ¨ã«é£›ã³ã¾ã™" }
};

let isVRMode = false;
const MAX_ENEMIES = 8; // æ•µä¸Šé™å¢—åŠ 
const RESPAWN_SECONDS = 5; // æ¹§ãé€Ÿåº¦å‘ä¸Š
const KEKKAI_LIMIT = 5;
const KEKKAI_DURATION = 40000;

/* --------------------
  ç’°å¢ƒãƒ»è¦–èªæ€§è¨­å®š
-------------------- */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x051133); 
scene.fog = new THREE.FogExp2(0x051133, 0.012); 

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.01, 200);
const playerGroup = new THREE.Group();
scene.add(playerGroup);
playerGroup.add(camera);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.xr.enabled = true;
renderer.toneMapping = THREE.ACESFilmicToneMapping; 
renderer.toneMappingExposure = 1.2;
document.body.appendChild(renderer.domElement);

/* --------------------
  ç‰©ç†ä¸–ç•Œ
-------------------- */
const world = new CANNON.World();
world.gravity.set(0, -15, 0);
world.broadphase = new CANNON.NaiveBroadphase();
world.solver.iterations = 20;

const matDefault = new CANNON.Material('default');
const matPlayer = new CANNON.Material('player');
const matEnemy = new CANNON.Material('enemy');
const matKekkai = new CANNON.Material('kekkai');

world.addContactMaterial(new CANNON.ContactMaterial(matDefault, matDefault, { friction: 0.8, restitution: 0.3 })); // æ‘©æ“¦ã‚’ä¸Šã’ã¦éšœå®³ç‰©ã«ä¹—ã‚Šã‚„ã™ã
world.addContactMaterial(new CANNON.ContactMaterial(matPlayer, matDefault, { friction: 0.0, restitution: 0.0 }));
// 5. æ•µæ¥è§¦æ™‚ã®åç™ºã‚’å¢—ã‚„ã—ã€æ•µã®é€Ÿåº¦ã«å¿œã˜ã¦é£›ã°ã•ã‚Œã‚‹ã‚ˆã†ã«
world.addContactMaterial(new CANNON.ContactMaterial(matEnemy, matPlayer, { friction: 0.0, restitution: 1.0 }));
world.addContactMaterial(new CANNON.ContactMaterial(matEnemy, matDefault, { friction: 0.3, restitution: 0.5 }));
world.addContactMaterial(new CANNON.ContactMaterial(matKekkai, matEnemy, { friction: 0.0, restitution: 0.0 })); // çµç•Œå†…ã§ã®å¼¾ãå‡ºã—é˜²æ­¢
world.addContactMaterial(new CANNON.ContactMaterial(matKekkai, matPlayer, { friction: 0.0, restitution: 0.0 }));

/* ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ */
const playerBody = new CANNON.Body({
  mass: 60,
  shape: new CANNON.Sphere(0.45),
  material: matPlayer,
  fixedRotation: true,
  angularDamping: 1.0
});
playerBody.position.set(0, 5.0, 15);
world.addBody(playerBody);

/* --------------------
  ç’°å¢ƒæ§‹ç¯‰ (6. æ ¡èˆã‚„éšœå®³ç‰©ã«ã®ã‚Œã‚‹ã‚ˆã†ã«)
-------------------- */
const hemi = new THREE.HemisphereLight(0x8888ff, 0x444455, 0.8); scene.add(hemi);
const moonLight = new THREE.DirectionalLight(0xddeeff, 1.5); 
moonLight.position.set(30, 80, -50);
moonLight.castShadow = true;
moonLight.shadow.mapSize.width = 2048;
moonLight.shadow.mapSize.height = 2048;
moonLight.shadow.camera.near = 1;
moonLight.shadow.camera.far = 150;
scene.add(moonLight);

const moon = new THREE.Mesh(new THREE.SphereGeometry(6, 32, 32), new THREE.MeshBasicMaterial({color: 0xffffee, toneMapped: false}));
moon.position.copy(moonLight.position).multiplyScalar(1.2);
scene.add(moon);

const floorBody = new CANNON.Body({ type: CANNON.Body.STATIC, material: matDefault });
floorBody.addShape(new CANNON.Plane());
floorBody.quaternion.setFromEuler(-Math.PI/2,0,0);
world.addBody(floorBody);
const floorMesh = new THREE.Mesh(new THREE.PlaneGeometry(150,150), new THREE.MeshStandardMaterial({color:0x6d5047, roughness: 0.8}));
floorMesh.rotation.x = -Math.PI/2; 
floorMesh.receiveShadow = true;
scene.add(floorMesh);

function createStaticBox(x, y, z, w, h, d, color, texture=null, isRubble=false){
  const meshMat = texture 
    ? new THREE.MeshStandardMaterial({map: texture, color:0xffffff}) 
    : new THREE.MeshStandardMaterial({color: color});
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), meshMat);
  mesh.position.set(x, y, z);
  if(isRubble){
    mesh.rotation.x = (Math.random()-0.5) * 0.4;
    mesh.rotation.z = (Math.random()-0.5) * 0.4;
  }
  mesh.castShadow = true; mesh.receiveShadow = true;
  scene.add(mesh);
  const body = new CANNON.Body({ type: CANNON.Body.STATIC, material: matDefault });
  body.addShape(new CANNON.Box(new CANNON.Vec3(w/2, h/2, d/2)));
  body.position.set(x,y,z);
  if(isRubble){
    const q = new CANNON.Quaternion();
    q.setFromEuler(mesh.rotation.x, mesh.rotation.y, mesh.rotation.z, 'XYZ');
    body.quaternion.copy(q);
  }
  world.addBody(body);
}

function createWindowTexture(){
  const cvs = document.createElement('canvas'); cvs.width = 128; cvs.height = 128;
  const ctx = cvs.getContext('2d');
  ctx.fillStyle = '#754'; ctx.fillRect(0,0,128,128);
  ctx.fillStyle = '#012'; ctx.fillRect(10,10,48,64); ctx.fillRect(70,10,48,64);
  ctx.fillStyle = '#fe9'; ctx.globalAlpha=0.7; ctx.fillRect(10,10,48,64); 
  ctx.globalAlpha=1.0;
  const tex = new THREE.CanvasTexture(cvs);
  tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(4, 2);
  tex.colorSpace = THREE.SRGBColorSpace;
  return tex;
}

function initEnvironment(){
  const winTex = createWindowTexture();
  // åŠå£Šã—ãŸæ ¡èˆ (ä¹—ã‚Œã‚‹ã‚ˆã†ã«)
  createStaticBox(0, 10, -45, 70, 20, 15, 0xdddddd, winTex);
  createStaticBox(-40, 10, -30, 15, 20, 40, 0xdddddd, winTex.clone().repeat.set(2,2));
  // ç“¦ç¤« (é«˜ä½å·®)
  createStaticBox(15, 1, -30, 6, 2, 8, 0x666666, null, true);
  createStaticBox(10, 2, -25, 4, 4, 5, 0x888888, null, true);
  createStaticBox(-10, 3, -15, 8, 6, 10, 0x555555, null, true);
  createStaticBox(25, 4, -40, 10, 8, 12, 0x777777, null, true);
  createStaticBox(-25, 2, 10, 5, 4, 5, 0x666666, null, true);
}
initEnvironment();

/* --------------------
  çµç•Œ (Kekkai)
-------------------- */
let kekkaiList = [];
let ghost = null;
let isDrawing = false;
let drawStartTouch = null;
let drawDistanceMode = "NEAR"; 
const DIST_NEAR = 4.0;
const DIST_FAR = 15.0;

const ghostGeo = new THREE.BoxGeometry(1,1,1);
const ghostMat = new THREE.MeshBasicMaterial({color:0x00ffff, wireframe:true, transparent:true, opacity:0.45});

// 7. ãƒ¬ãƒ¼ã‚¶ãƒ¼ã‚¬ã‚¤ãƒ‰
const laserGeometry = new THREE.CylinderGeometry(0.02, 0.02, 1, 8);
const laserMaterial = new THREE.MeshBasicMaterial({color: 0x00ffff, transparent: true, opacity: 0.6});
const laser = new THREE.Mesh(laserGeometry, laserMaterial);
laser.rotation.x = Math.PI / 2; // Zè»¸ã‚’å‘ãã‚ˆã†ã«å›è»¢
playerGroup.add(laser); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãã£ã¤ã‘ã‚‹
laser.visible = false; // éè¡¨ç¤ºã§åˆæœŸåŒ–

const btnRange = document.getElementById('btnRange');
const elRangeVal = document.getElementById('rangeVal');
btnRange.addEventListener('touchstart', (e)=>{
  e.preventDefault();
  if(drawDistanceMode === "NEAR"){
    drawDistanceMode = "FAR";
    elRangeVal.textContent = "é ";
    elRangeVal.style.color = "#0ff";
    pulseHUD("å°„ç¨‹ï¼šé  (15m)", "#0ff");
    laser.scale.set(1, 15, 1);
  } else {
    drawDistanceMode = "NEAR";
    elRangeVal.textContent = "è¿‘";
    elRangeVal.style.color = "#ff8";
    pulseHUD("å°„ç¨‹ï¼šè¿‘ (4m)", "#ff8");
    laser.scale.set(1, 4, 1);
  }
});

function startDrawing(){
  if(kekkaiList.length >= KEKKAI_LIMIT){ pulseHUD("çµç•Œæ•°ãŒä¸Šé™ã§ã™", "#f44"); return; }
  isDrawing = true; document.getElementById('btnDraw').classList.add('drawing');
  
  // 7. ãƒ¬ãƒ¼ã‚¶ãƒ¼ã‚¬ã‚¤ãƒ‰ã®è¡¨ç¤ºã¨è¨­å®š
  const dist = (drawDistanceMode==="NEAR") ? DIST_NEAR : DIST_FAR;
  laser.scale.set(1, dist, 1);
  laser.position.set(0, 0, -dist/2); // ã‚«ãƒ¡ãƒ©ã®æ­£é¢ã€è·é›¢ã®åŠåˆ†å¥¥ã«é…ç½®
  laser.visible = true;

  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  const pos = new THREE.Vector3(playerBody.position.x, playerBody.position.y+0.6, playerBody.position.z).add(dir.multiplyScalar(dist));
  if(pos.y < 1.0) pos.y = 1.0;
  ghost = new THREE.Mesh(ghostGeo, ghostMat);
  ghost.position.copy(pos);
  scene.add(ghost);
}
function finalizeDrawing(){
  if(!ghost) return;
  const pos = ghost.position.clone();
  const size = ghost.scale.clone();
  scene.remove(ghost); ghost = null; isDrawing=false;
  document.getElementById('btnDraw').classList.remove('drawing');
  laser.visible = false; // ãƒ¬ãƒ¼ã‚¶ãƒ¼éè¡¨ç¤º
  createKekkai(pos, size);
}
function createKekkai(pos, size){
  const mesh = new THREE.Mesh(new THREE.BoxGeometry(size.x, size.y, size.z),
    new THREE.MeshPhongMaterial({color:0x00aaff, transparent:true, opacity:0.3, emissive:0x004488, side:THREE.DoubleSide, depthWrite: false}));
  mesh.add(new THREE.LineSegments(new THREE.EdgesGeometry(mesh.geometry), new THREE.LineBasicMaterial({color:0x88ffff})));
  mesh.position.copy(pos); scene.add(mesh);

  const body = new CANNON.Body({ mass: 0, material: matKekkai });
  const hx = size.x/2; const hy = size.y/2; const hz = size.z/2; const hth = 0.25;
  body.addShape(new CANNON.Box(new CANNON.Vec3(hth, hy, hz)), new CANNON.Vec3(hx, 0, 0));
  body.addShape(new CANNON.Box(new CANNON.Vec3(hth, hy, hz)), new CANNON.Vec3(-hx, 0, 0));
  body.addShape(new CANNON.Box(new CANNON.Vec3(hx, hth, hz)), new CANNON.Vec3(0, hy, 0));
  body.addShape(new CANNON.Box(new CANNON.Vec3(hx, hth, hz)), new CANNON.Vec3(0, -hy, 0));
  body.addShape(new CANNON.Box(new CANNON.Vec3(hx, hy, hth)), new CANNON.Vec3(0, 0, hz));
  body.addShape(new CANNON.Box(new CANNON.Vec3(hx, hy, hth)), new CANNON.Vec3(0, 0, -hz));

  body.position.set(pos.x, pos.y, pos.z);
  world.addBody(body);
  const k = { mesh, body, initialSize: size.clone(), createdAt: performance.now(), isShrinking: false };
  kekkaiList.push(k);
  spawnKanji("çµ", pos, "#0af");
  updateCounts();
  setTimeout(()=>{ if(kekkaiList.includes(k) && !k.isShrinking) removeKekkai(k); }, KEKKAI_DURATION);
}
function removeKekkai(k){
  try{ scene.remove(k.mesh); world.removeBody(k.body); }catch(e){}
  kekkaiList = kekkaiList.filter(x=>x!==k);
  updateCounts();
}

/* --------------------
  æ•µAI & Waveç®¡ç†
-------------------- */
let enemies = [];
let lastSpawnAttempt = performance.now();

// 3. æ•µã®ã‚µã‚¤ã‚ºã‚’ãƒ©ãƒ³ãƒ€ãƒ åŒ– (æœ€å¤§10å€)
function spawnEnemyByWave(){
  if(enemies.length >= MAX_ENEMIES) return;

  let wInfo = WAVE_INFO[currentWave];
  if(!wInfo) wInfo = WAVE_INFO[5]; 
  
  const type = wInfo.type;
  const baseSize = 0.5 + Math.random()*0.5;
  const sizeFactor = Math.random() < 0.1 ? 10 : (1 + Math.random() * 2); // 10%ã§å·¨å¤§åŒ–
  const size = baseSize * sizeFactor;
  
  const hue = Math.random();
  const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
  const emCol = new THREE.Color().setHSL(hue, 1.0, 0.3);

  let geo;
  if(Math.random()<0.33) geo = new THREE.SphereGeometry(size, 16, 16);
  else if(Math.random()<0.5) geo = new THREE.BoxGeometry(size*1.5, size*1.5, size*1.5);
  else geo = new THREE.IcosahedronGeometry(size*1.2, 0);

  const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:color, roughness:0.2, metalness:0.4, emissive: emCol, emissiveIntensity: 0.5}));
  
  const mass = 5 * sizeFactor * sizeFactor * sizeFactor; // ä½“ç©ã«æ¯”ä¾‹ã—ã¦è³ªé‡å¢—åŠ 
  const body = new CANNON.Body({ mass, shape: new CANNON.Sphere(size*0.8), material: matEnemy, linearDamping: 0.3, angularDamping: 0.3 });
  
  const angle = Math.random() * Math.PI * 2;
  const dist = 15 + Math.random() * 20;
  const spawnY = (type === 'high_flyer' || type === 'low_flyer') ? (5 + Math.random()*10) : (1 + Math.random()*3);
  
  body.position.set(Math.sin(angle)*dist, spawnY, Math.cos(angle)*dist);
  world.addBody(body);
  scene.add(mesh);

  const en = { 
    mesh, body, size, type, 
    trapped: false, 
    nextMoveTime: 0,
    moveDir: new THREE.Vector3(),
    hp: 1,
    isGiant: sizeFactor > 3 // å·¨å¤§æ•µãƒ•ãƒ©ã‚°
  };
  enemies.push(en);
  updateCounts();
  if(en.isGiant) pulseHUD("å·¨å¤§ãªå¦–ãŒå‡ºç¾ï¼", "#f00");
}

// 5. æ•µæ¥è§¦æ™‚ã®ãƒãƒƒã‚¯ãƒãƒƒã‚¯
playerBody.addEventListener('collide', (e) => {
  const otherBody = e.body;
  const enemy = enemies.find(en => en.body === otherBody);
  if(enemy){
    const relativeVelocity = new THREE.Vector3().copy(enemy.body.velocity).sub(new THREE.Vector3().copy(playerBody.velocity));
    const speed = relativeVelocity.length();
    
    if(speed > 5.0){
      const impactDirection = new CANNON.Vec3().copy(playerBody.position).vsub(enemy.body.position).unit();
      const knockbackForce = impactDirection.scale(speed * 300); // é€Ÿåº¦ã«å¿œã˜ã¦å¼·ããƒãƒƒã‚¯ãƒãƒƒã‚¯
      playerBody.applyImpulse(knockbackForce, playerBody.position);
      pulseHUD("ãƒãƒƒã‚¯ãƒãƒƒã‚¯ï¼", "#ff0");
    }
  }
});

function updateEnemies(dt){
  if(enemies.length < MAX_ENEMIES && (performance.now() - lastSpawnAttempt) > RESPAWN_SECONDS*1000) {
    spawnEnemyByWave(); lastSpawnAttempt = performance.now();
  }

  const ppos = playerBody.position;
  const now = performance.now();

  enemies.forEach(en=>{
    en.mesh.position.copy(en.body.position);
    en.mesh.quaternion.copy(en.body.quaternion);
    if(en.trapped) return;
    if(en.body.position.y < -30){ destroyEnemy(en); return; }

    // --- AI ---
    // ... (AIãƒ­ã‚¸ãƒƒã‚¯ã¯å¤‰æ›´ãªã—ã€å…ƒã®ã‚³ãƒ¼ãƒ‰ã®ã¾ã¾ã§è‰¯ã„) ...
    if(en.type === 'static'){
        // ä½•ã‚‚ã—ãªã„ï¼ˆé‡åŠ›ã®ã¿ï¼‰
      }
      else {
        const dx = ppos.x - en.body.position.x;
        const dz = ppos.z - en.body.position.z;
        const dist = Math.sqrt(dx*dx+dz*dz);
        const isChasing = (now > en.nextMoveTime); 
        let force = 0;
        let dir = new THREE.Vector3(dx, 0, dz).normalize();

        if(en.type === 'walker'){
          if(isChasing){
            if(Math.random() < 0.7) en.moveDir.copy(dir);
            else en.moveDir.set(Math.random()-0.5, 0, Math.random()-0.5).normalize();
            en.nextMoveTime = now + 2000;
          }
          force = 8;
          en.body.applyForce(new CANNON.Vec3(en.moveDir.x*force, 0, en.moveDir.z*force), en.body.position);
        }
        else if(en.type === 'jumper'){
          if(isChasing){
            if(Math.random() < 0.8) en.moveDir.copy(dir);
            else en.moveDir.set(Math.random()-0.5, 0, Math.random()-0.5).normalize();
            if(en.body.position.y < 2.0){
              en.body.velocity.y = 8 + Math.random()*4;
            }
            en.nextMoveTime = now + 1500;
          }
          force = 6;
          if(en.body.position.y < 2.0) en.body.applyForce(new CANNON.Vec3(en.moveDir.x*force, 0, en.moveDir.z*force), en.body.position);
        }
        else if(en.type === 'low_flyer'){
          const hoverY = 3.0 + Math.sin(now*0.002);
          const diffY = hoverY - en.body.position.y;
          const lift = 15 * en.body.mass + diffY * 10; 
          en.body.applyForce(new CANNON.Vec3(0, lift, 0), en.body.position);
          force = 4;
          en.body.applyForce(new CANNON.Vec3(dir.x*force, 0, dir.z*force), en.body.position);
        }
        else if(en.type === 'high_flyer'){
          const dy = (ppos.y + 1.0) - en.body.position.y;
          dir.set(dx, dy, dz).normalize();
          en.body.applyForce(new CANNON.Vec3(0, 15*en.body.mass, 0), en.body.position);
          if(isChasing){
            force = (Math.random()<0.3) ? 20 : 6;
            en.nextMoveTime = now + 1000;
          } else {
            force = 6;
          }
          en.body.applyForce(new CANNON.Vec3(dir.x*force, dir.y*force, dir.z*force), en.body.position);
        }
      }
  });
}

function destroyEnemy(en){
  spawnParticles(en.mesh.position, en.mesh.material.emissive.getHex(), en.isGiant ? 50 : 20); // å·¨å¤§ãªæ•µã¯æ´¾æ‰‹ã«
  // 4. éŸ³ã‚’è¿½åŠ  (ä»®ã®éŸ³ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ)
  pulseHUD("ğŸ’¥ æ’ƒç ´ï¼", "#f90"); 
  try{ scene.remove(en.mesh); world.removeBody(en.body); }catch(e){}
  enemies = enemies.filter(x=>x!==en);
  
  killCount++;
  killsToNextWave--;
  if(killsToNextWave <= 0){
    levelUpWave();
  }
  updateCounts();
}

function levelUpWave(){
  currentWave++;
  killsToNextWave = (currentWave < 5) ? 4 : 8; 
  pulseHUD("WAVE UP!", "#fe0");
  spawnKanji("å±", new THREE.Vector3(0,5,10), "#f40"); 
  updateCounts();
}

/* --------------------
  æ»… (Metsu) - ç¢ºæ®º
-------------------- */
function metsAction(){
  const target = pickClosestKekkai(30.0);
  if(!target) { 
    pulseHUD("å¯¾è±¡ãªã—", "#888"); 
    // 2. ç©ºç®±ã®æ»…ã¯åœ°å‘³ã«
    spawnKanji("æ»…", new THREE.Vector3().copy(playerBody.position).add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(3)), "#555");
    return; 
  }
  if(target.isShrinking) return;

  pulseHUD("æ»…ï¼", "#f24");
  spawnKanji("æ»…", target.mesh.position, "#f24");
  target.isShrinking = true;

  let currentScale = 1.0;
  const shrinkSpeed = 0.02;
  let killCountInKekkai = 0;

  function shrinkStep(){
    if(!kekkaiList.includes(target)) return;
    currentScale -= shrinkSpeed;
    const currentSize = Math.min(target.initialSize.x, target.initialSize.y, target.initialSize.z) * currentScale;

    const boxBox = new THREE.Box3().setFromObject(target.mesh);
    const center = target.body.position;
    
    enemies.forEach(en => {
      if(!en.trapped && boxBox.containsPoint(en.mesh.position)){
        en.trapped = true;
        killCountInKekkai++;
      }
      if(en.trapped && boxBox.containsPoint(en.mesh.position)){
        // ä¸­å¿ƒã¸å¸å¼•
        const dirToCenter = center.vsub(en.body.position);
        dirToCenter.scale(25, dirToCenter); 
        en.body.applyForce(dirToCenter, en.body.position);
        en.body.velocity.scale(0.8, en.body.velocity);

        // 2. æ•µã‚’å«ã‚€æ»…ã¯æ½°ã®æ–‡å­—ã¯ä¸è¦ã€‚æ´¾æ‰‹ã«ã€‚
        if(currentSize < en.size * 1.8){
          destroyEnemy(en);
          spawnParticles(en.mesh.position, 0xffaa00, en.isGiant ? 80 : 30);
          // spawnKanji("æ½°", en.mesh.position, "#fa0"); // æ½°ã®æ–‡å­—ã¯å‰Šé™¤
        }
      }
    });

    if(currentScale <= 0.05){
      // æ•µã‚’æ•ç²ã§ããªã‹ã£ãŸå ´åˆã¯åœ°å‘³ã«çµ‚äº†
      const particleCount = killCountInKekkai > 0 ? 30 : 5;
      const particleColor = killCountInKekkai > 0 ? 0xffaa00 : 0x555555;
      spawnParticles(target.mesh.position, particleColor, particleCount);
      removeKekkai(target);
      return;
    }

    target.mesh.scale.set(currentScale, currentScale, currentScale);
    // ... (ç‰©ç†ãƒœãƒ‡ã‚£ã®ã‚¹ã‚±ãƒ¼ãƒ«æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ã¯çœç•¥ã›ãšã«æ®‹ã™) ...
    const th = 0.5; 
    const hx = (target.initialSize.x * currentScale) / 2;
    const hy = (target.initialSize.y * currentScale) / 2;
    const hz = (target.initialSize.z * currentScale) / 2;
    const hth = th / 2;
    updateBoxShape(target.body, 0, new CANNON.Vec3(hth, hy, hz), new CANNON.Vec3(hx, 0, 0));
    updateBoxShape(target.body, 1, new CANNON.Vec3(hth, hy, hz), new CANNON.Vec3(-hx, 0, 0));
    updateBoxShape(target.body, 2, new CANNON.Vec3(hx, hth, hz), new CANNON.Vec3(0, hy, 0));
    updateBoxShape(target.body, 3, new CANNON.Vec3(hx, hth, hz), new CANNON.Vec3(0, -hy, 0));
    updateBoxShape(target.body, 4, new CANNON.Vec3(hx, hy, hth), new CANNON.Vec3(0, 0, hz));
    updateBoxShape(target.body, 5, new CANNON.Vec3(hx, hy, hth), new CANNON.Vec3(0, 0, -hz));
    target.body.updateBoundingRadius();
    target.body.aabbNeedsUpdate = true;
    target.mesh.material.opacity = 0.3 + (1.0-currentScale)*0.7; 

    requestAnimationFrame(shrinkStep);
  }
  shrinkStep();
}

function updateBoxShape(body, index, halfExtents, offset){
  if(!body.shapes[index]) return;
  body.shapes[index].halfExtents.copy(halfExtents);
  body.shapes[index].updateConvexPolyhedronRepresentation();
  body.shapeOffsets[index].copy(offset);
}

/* --------------------
  UI & Controls
-------------------- */
let moveState = { fwd:0, back:0, left:0, right:0 };
let wantsJump = false;

// 8. ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯å‡¦ç†
const joystickArea = document.getElementById('joystickArea');
const joystickHandle = document.getElementById('joystickHandle');
let stickTouch = null;
const MAX_DISTANCE = 50;

joystickArea.addEventListener('touchstart', (e)=>{
  e.preventDefault();
  stickTouch = e.touches[0];
  joystickArea.classList.add('active');
  updateJoystick(stickTouch.clientX, stickTouch.clientY);
}, {passive:false});

joystickArea.addEventListener('touchmove', (e)=>{
  e.preventDefault();
  stickTouch = e.touches[0];
  updateJoystick(stickTouch.clientX, stickTouch.clientY);
}, {passive:false});

joystickArea.addEventListener('touchend', (e)=>{
  e.preventDefault();
  stickTouch = null;
  joystickArea.classList.remove('active');
  joystickHandle.style.transform = `translate(-50%, -50%)`;
  moveState = { fwd:0, back:0, left:0, right:0 };
}, {passive:false});

function updateJoystick(touchX, touchY){
  const rect = joystickArea.getBoundingClientRect();
  const centerX = rect.left + rect.width / 2;
  const centerY = rect.top + rect.height / 2;

  let dx = touchX - centerX;
  let dy = touchY - centerY;

  const distance = Math.sqrt(dx*dx + dy*dy);
  if(distance > MAX_DISTANCE){
    const ratio = MAX_DISTANCE / distance;
    dx *= ratio;
    dy *= ratio;
  }
  
  joystickHandle.style.transform = `translate(${dx}px, ${dy}px)`;
  
  // ç§»å‹•æ–¹å‘ã®è¨ˆç®—
  const normX = dx / MAX_DISTANCE;
  const normY = dy / MAX_DISTANCE;
  
  // é–¾å€¤ã‚’è¨­ã‘ã¦ç§»å‹•çŠ¶æ…‹ã‚’æ›´æ–°
  const threshold = 0.3;
  moveState.fwd = normY < -threshold ? Math.abs(normY) : 0;
  moveState.back = normY > threshold ? Math.abs(normY) : 0;
  moveState.left = normX < -threshold ? Math.abs(normX) : 0;
  moveState.right = normX > threshold ? Math.abs(normX) : 0;
}

// ä»–ã®ãƒœã‚¿ãƒ³åˆ¶å¾¡ã¯ãã®ã¾ã¾
document.getElementById('btnJump').addEventListener('touchstart', (e)=>{ e.preventDefault(); wantsJump=true; });
document.getElementById('btnMets').addEventListener('touchstart', (e)=>{ e.preventDefault(); metsAction(); });
document.getElementById('btnKai').addEventListener('touchstart', (e)=>{ e.preventDefault();
  const k = pickClosestKekkai(15.0);
  if(k){ spawnKanji("è§£", k.mesh.position, "#8f8"); removeKekkai(k); } else pulseHUD("å¯¾è±¡ãªã—", "#888");
});

const btnDraw = document.getElementById('btnDraw');
btnDraw.addEventListener('touchstart', (e)=>{ e.preventDefault(); const t=e.touches[0]; drawStartTouch = {x:t.clientX, y:t.clientY}; startDrawing(); });
btnDraw.addEventListener('touchmove', (e)=>{ e.preventDefault(); const t=e.touches[0]; updateGhostShape(t.clientX, t.clientY); });
btnDraw.addEventListener('touchend', (e)=>{ e.preventDefault(); finalizeDrawing(); });

let lastX=0, lastY=0, camYaw=0, camPitch=0;
renderer.domElement.addEventListener('touchstart', e=>{ if(!isDrawing){ const t=e.touches[0]; lastX=t.clientX; lastY=t.clientY; } }, {passive:false});
renderer.domElement.addEventListener('touchmove', e=>{ e.preventDefault(); const t=e.touches[0]; if(!isDrawing){ const dx=t.clientX-lastX, dy=t.clientY-lastY; camYaw -= dx*0.004; camPitch -= dy*0.004; camPitch = Math.max(-1.4, Math.min(1.4, camPitch)); playerGroup.rotation.y = camYaw; camera.rotation.x = camPitch; } lastX=t.clientX; lastY=t.clientY; }, {passive:false});

function pickClosestKekkai(range){
  let best=null; let bestD2 = range*range;
  const px = playerBody.position.x, py=playerBody.position.y, pz=playerBody.position.z;
  kekkaiList.forEach(k=>{
    const dx = px - k.body.position.x, dy=py - k.body.position.y, dz=pz - k.body.position.z;
    const d2 = dx*dx+dy*dy+dz*dz;
    if(d2 < bestD2){ bestD2 = d2; best = k; }
  });
  return best;
}

function updateCounts(){ 
  document.getElementById('kCount').textContent = kekkaiList.length; 
  document.getElementById('eCount').textContent = enemies.length; 
  document.getElementById('killCount').textContent = killCount;
  document.getElementById('nextWave').textContent = killsToNextWave;
  
  const w = WAVE_INFO[currentWave] || WAVE_INFO[5];
  document.getElementById('waveVal').textContent = currentWave;
  document.getElementById('waveName').textContent = w.name;
}

function spawnKanji(text, pos, color="#4af"){
  const cvs=document.createElement('canvas'); cvs.width=128; cvs.height=128;
  const ctx=cvs.getContext('2d'); ctx.font="bold 96px serif"; ctx.fillStyle=color; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(text,64,64);
  const tex=new THREE.CanvasTexture(cvs);
  const mat = new THREE.SpriteMaterial({map:tex, transparent:true, depthTest:false});
  const sp = new THREE.Sprite(mat); sp.position.copy(pos); sp.scale.set(0.001,0.001,0.001); scene.add(sp);
  let f=0; (function a(){ f+=0.04; const s = Math.min(1, f*2); sp.scale.setScalar(s*0.6); sp.position.y+=0.02; sp.material.opacity = 1-f; if(f<1) requestAnimationFrame(a); else { try{ scene.remove(sp); tex.dispose(); mat.dispose(); } catch(e){} } })();
}
function spawnParticles(pos, colorInt, count=14){
  for(let i=0;i<count;i++){
    const box = new THREE.Mesh(new THREE.BoxGeometry(0.12,0.12,0.12), new THREE.MeshBasicMaterial({color: colorInt}));
    box.position.copy(pos); scene.add(box);
    const v = new THREE.Vector3((Math.random()-0.5),(Math.random()-0.5),(Math.random()-0.5)).multiplyScalar(0.6);
    (function pAnim(m, vel){
      m.position.add(vel); m.scale.multiplyScalar(0.9); m.rotation.x+=0.2;
      if(m.scale.x>0.02) requestAnimationFrame(()=>pAnim(m, vel));
      else { try{ scene.remove(m); m.geometry.dispose(); m.material.dispose(); }catch(e){} }
    })(box, v);
  }
}
function pulseHUD(text, col="#fff"){ const el=document.getElementById('statusText'); el.textContent=text; el.style.color = col || "#fff"; setTimeout(()=>el.style.color="#f0a", 1500); }

const clock = new THREE.Clock();
renderer.setAnimationLoop(()=>{
  const dt = Math.min(clock.getDelta(), 0.1);
  world.step(1/60, dt, 5);

  const speed = 6.0;
  const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
  const theta = Math.atan2(dir.x, dir.z);
  
  let vx=0, vz=0;
  // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã®å…¥åŠ›ã«å¿œã˜ã¦é€Ÿåº¦ã‚’è¨­å®š
  if(moveState.fwd){ vx += Math.sin(theta) * moveState.fwd; vz += Math.cos(theta) * moveState.fwd; }
  if(moveState.back){ vx -= Math.sin(theta) * moveState.back; vz -= Math.cos(theta) * moveState.back; }
  if(moveState.left){ vx += Math.sin(theta + Math.PI/2) * moveState.left; vz += Math.cos(theta + Math.PI/2) * moveState.left; }
  if(moveState.right){ vx += Math.sin(theta - Math.PI/2) * moveState.right; vz += Math.cos(theta - Math.PI/2) * moveState.right; }
  
  if(vx!==0 || vz!==0){ 
    playerBody.velocity.x = vx*speed; 
    playerBody.velocity.z = vz*speed; 
  } else { 
    playerBody.velocity.x *= 0.88; 
    playerBody.velocity.z *= 0.88; 
  }
  if(wantsJump){ if(Math.abs(playerBody.velocity.y) < 0.2) playerBody.velocity.y = 8; wantsJump=false; }
  
  playerGroup.position.set(playerBody.position.x, playerBody.position.y, playerBody.position.z);
  camera.position.set(0, 0.6, 0);

  kekkaiList.forEach(k => { k.mesh.position.copy(k.body.position); k.mesh.quaternion.copy(k.body.quaternion); });
  updateEnemies(dt);
  renderer.render(scene, camera);
});

// 1. VRãƒ¢ãƒ¼ãƒ‰ãŒãƒ¡ã‚¿ã‚¯ã‚¨ã‚¹ãƒˆ2ã®ãƒ–ãƒ©ã‚¦ã‚¶ã§å‹•ãã‚ˆã†ã«
document.getElementById('vrToggle').addEventListener('click', async ()=>{
  if(!isVRMode && navigator.xr){
    try{ 
      // ãƒ¡ã‚¿ã‚¯ã‚¨ã‚¹ãƒˆ2ã§ã¯ã€'requiredFeatures'ã«'local-floor'ã¾ãŸã¯'viewer'ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒæ¨å¥¨ã•ã‚Œã¾ã™
      // 'optionalFeatures'ã«'hand-tracking'ã‚„'depth-sensing'ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚
      const s = await navigator.xr.requestSession('immersive-vr', {
          requiredFeatures: ['local-floor', 'viewer'],
          optionalFeatures: ['hand-tracking']
      }); 
      renderer.xr.setSession(s); 
      isVRMode=true; 
      document.getElementById('mobileUI').style.display='none'; 
      pulseHUD("VRãƒ¢ãƒ¼ãƒ‰èµ·å‹•", "#0f0");
    }catch(e){ 
      console.warn("VRã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ã«å¤±æ•—:", e); 
      pulseHUD("VRå¤±æ•—: " + e.message.substring(0, 20), "#f00");
    }
  } else if(isVRMode) {
      // VRãƒ¢ãƒ¼ãƒ‰è§£é™¤ã®ãƒ­ã‚¸ãƒƒã‚¯
      renderer.xr.getSession().end();
      isVRMode = false;
      document.getElementById('mobileUI').style.display='flex';
      pulseHUD("VRãƒ¢ãƒ¼ãƒ‰çµ‚äº†", "#ff0");
  } else {
      pulseHUD("VRæœªå¯¾å¿œ", "#f00");
  }
});

// åˆæœŸSpawn
for(let i=0;i<3;i++) spawnEnemyByWave();
updateCounts();
window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
</script>
</body>
</html>
